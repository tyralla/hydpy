<html>
  <head>
    <title>pycobertura report</title>
    <meta charset="UTF-8">
    <style>
/*! normalize.css v3.0.2 | MIT License | git.io/normalize */

/**
 * 1. Set default font family to sans-serif.
 * 2. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
  font-family: sans-serif; /* 1 */
  -ms-text-size-adjust: 100%; /* 2 */
  -webkit-text-size-adjust: 100%; /* 2 */
}

/**
 * Remove default margin.
 */

body {
  margin: 0;
}

/* HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined for any HTML5 element in IE 8/9.
 * Correct `block` display not defined for `details` or `summary` in IE 10/11
 * and Firefox.
 * Correct `block` display not defined for `main` in IE 11.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
menu,
nav,
section,
summary {
  display: block;
}

/**
 * 1. Correct `inline-block` display not defined in IE 8/9.
 * 2. Normalize vertical alignment of `progress` in Chrome, Firefox, and Opera.
 */

audio,
canvas,
progress,
video {
  display: inline-block; /* 1 */
  vertical-align: baseline; /* 2 */
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
  display: none;
  height: 0;
}

/**
 * Address `[hidden]` styling not present in IE 8/9/10.
 * Hide the `template` element in IE 8/9/11, Safari, and Firefox < 22.
 */

[hidden],
template {
  display: none;
}

/* Links
   ========================================================================== */

/**
 * Remove the gray background color from active links in IE 10.
 */

a {
  background-color: transparent;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
  outline: 0;
}

/* Text-level semantics
   ========================================================================== */

/**
 * Address styling not present in IE 8/9/10/11, Safari, and Chrome.
 */

abbr[title] {
  border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 4+, Safari, and Chrome.
 */

b,
strong {
  font-weight: bold;
}

/**
 * Address styling not present in Safari and Chrome.
 */

dfn {
  font-style: italic;
}

/**
 * Address variable `h1` font-size and margin within `section` and `article`
 * contexts in Firefox 4+, Safari, and Chrome.
 */

h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

/**
 * Address styling not present in IE 8/9.
 */

mark {
  background: #ff0;
  color: #000;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
  font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

sup {
  top: -0.5em;
}

sub {
  bottom: -0.25em;
}

/* Embedded content
   ========================================================================== */

/**
 * Remove border when inside `a` element in IE 8/9/10.
 */

img {
  border: 0;
}

/**
 * Correct overflow not hidden in IE 9/10/11.
 */

svg:not(:root) {
  overflow: hidden;
}

/* Grouping content
   ========================================================================== */

/**
 * Address margin not present in IE 8/9 and Safari.
 */

figure {
  margin: 1em 40px;
}

/**
 * Address differences between Firefox and other browsers.
 */

hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  height: 0;
}

/**
 * Contain overflow in all browsers.
 */

pre {
  overflow: auto;
}

/**
 * Address odd `em`-unit font size rendering in all browsers.
 */

code,
kbd,
pre,
samp {
  font-family: monospace, monospace;
  font-size: 1em;
}

/* Forms
   ========================================================================== */

/**
 * Known limitation: by default, Chrome and Safari on OS X allow very limited
 * styling of `select`, unless a `border` property is set.
 */

/**
 * 1. Correct color not being inherited.
 *    Known issue: affects color of disabled elements.
 * 2. Correct font properties not being inherited.
 * 3. Address margins set differently in Firefox 4+, Safari, and Chrome.
 */

button,
input,
optgroup,
select,
textarea {
  color: inherit; /* 1 */
  font: inherit; /* 2 */
  margin: 0; /* 3 */
}

/**
 * Address `overflow` set to `hidden` in IE 8/9/10/11.
 */

button {
  overflow: visible;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Firefox, IE 8/9/10/11, and Opera.
 * Correct `select` style inheritance in Firefox.
 */

button,
select {
  text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
  -webkit-appearance: button; /* 2 */
  cursor: pointer; /* 3 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
  cursor: default;
}

/**
 * Remove inner padding and border in Firefox 4+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
  border: 0;
  padding: 0;
}

/**
 * Address Firefox 4+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

input {
  line-height: normal;
}

/**
 * It's recommended that you don't attempt to style these elements.
 * Firefox's implementation doesn't respect box-sizing, padding, or width.
 *
 * 1. Address box sizing set to `content-box` in IE 8/9/10.
 * 2. Remove excess padding in IE 8/9/10.
 */

input[type="checkbox"],
input[type="radio"] {
  box-sizing: border-box; /* 1 */
  padding: 0; /* 2 */
}

/**
 * Fix the cursor style for Chrome's increment/decrement buttons. For certain
 * `font-size` values of the `input`, it causes the cursor style of the
 * decrement button to change from `default` to `text`.
 */

input[type="number"]::-webkit-inner-spin-button,
input[type="number"]::-webkit-outer-spin-button {
  height: auto;
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
  -webkit-appearance: textfield; /* 1 */
  -moz-box-sizing: content-box;
  -webkit-box-sizing: content-box; /* 2 */
  box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari and Chrome on OS X.
 * Safari (but not Chrome) clips the cancel button when the search input has
 * padding (and `textfield` appearance).
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
  -webkit-appearance: none;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
  border: 1px solid #c0c0c0;
  margin: 0 2px;
  padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct `color` not being inherited in IE 8/9/10/11.
 * 2. Remove padding so people aren't caught out if they zero out fieldsets.
 */

legend {
  border: 0; /* 1 */
  padding: 0; /* 2 */
}

/**
 * Remove default vertical scrollbar in IE 8/9/10/11.
 */

textarea {
  overflow: auto;
}

/**
 * Don't inherit the `font-weight` (applied by a rule above).
 * NOTE: the default cannot safely be changed in Chrome and Safari on OS X.
 */

optgroup {
  font-weight: bold;
}

/* Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
  border-collapse: collapse;
  border-spacing: 0;
}

td,
th {
  padding: 0;
}
/*
* Skeleton V2.0.4
* Copyright 2014, Dave Gamache
* www.getskeleton.com
* Free to use under the MIT license.
* http://www.opensource.org/licenses/mit-license.php
* 12/29/2014
*/


/* Table of contents
––––––––––––––––––––––––––––––––––––––––––––––––––
- Grid
- Base Styles
- Typography
- Links
- Buttons
- Forms
- Lists
- Code
- Tables
- Spacing
- Utilities
- Clearing
- Media Queries
*/


/* Grid
–––––––––––––––––––––––––––––––––––––––––––––––––– */
.container {
  position: relative;
  width: 100%;
  max-width: 960px;
  margin: 0 auto;
  padding: 0 20px;
  box-sizing: border-box; }
.column,
.columns {
  width: 100%;
  float: left;
  box-sizing: border-box; }

/* For devices larger than 400px */
@media (min-width: 400px) {
  .container {
    width: 85%;
    padding: 0; }
}

/* For devices larger than 550px */
@media (min-width: 550px) {
  .container {
    width: 80%; }
  .column,
  .columns {
    margin-left: 4%; }
  .column:first-child,
  .columns:first-child {
    margin-left: 0; }

  .one.column,
  .one.columns                    { width: 4.66666666667%; }
  .two.columns                    { width: 13.3333333333%; }
  .three.columns                  { width: 22%;            }
  .four.columns                   { width: 30.6666666667%; }
  .five.columns                   { width: 39.3333333333%; }
  .six.columns                    { width: 48%;            }
  .seven.columns                  { width: 56.6666666667%; }
  .eight.columns                  { width: 65.3333333333%; }
  .nine.columns                   { width: 74.0%;          }
  .ten.columns                    { width: 82.6666666667%; }
  .eleven.columns                 { width: 91.3333333333%; }
  .twelve.columns                 { width: 100%; margin-left: 0; }

  .one-third.column               { width: 30.6666666667%; }
  .two-thirds.column              { width: 65.3333333333%; }

  .one-half.column                { width: 48%; }

  /* Offsets */
  .offset-by-one.column,
  .offset-by-one.columns          { margin-left: 8.66666666667%; }
  .offset-by-two.column,
  .offset-by-two.columns          { margin-left: 17.3333333333%; }
  .offset-by-three.column,
  .offset-by-three.columns        { margin-left: 26%;            }
  .offset-by-four.column,
  .offset-by-four.columns         { margin-left: 34.6666666667%; }
  .offset-by-five.column,
  .offset-by-five.columns         { margin-left: 43.3333333333%; }
  .offset-by-six.column,
  .offset-by-six.columns          { margin-left: 52%;            }
  .offset-by-seven.column,
  .offset-by-seven.columns        { margin-left: 60.6666666667%; }
  .offset-by-eight.column,
  .offset-by-eight.columns        { margin-left: 69.3333333333%; }
  .offset-by-nine.column,
  .offset-by-nine.columns         { margin-left: 78.0%;          }
  .offset-by-ten.column,
  .offset-by-ten.columns          { margin-left: 86.6666666667%; }
  .offset-by-eleven.column,
  .offset-by-eleven.columns       { margin-left: 95.3333333333%; }

  .offset-by-one-third.column,
  .offset-by-one-third.columns    { margin-left: 34.6666666667%; }
  .offset-by-two-thirds.column,
  .offset-by-two-thirds.columns   { margin-left: 69.3333333333%; }

  .offset-by-one-half.column,
  .offset-by-one-half.columns     { margin-left: 52%; }

}


/* Base Styles
–––––––––––––––––––––––––––––––––––––––––––––––––– */
/* NOTE
html is set to 62.5% so that all the REM measurements throughout Skeleton
are based on 10px sizing. So basically 1.5rem = 15px :) */
html {
  font-size: 62.5%; }
body {
  font-size: 1.5em; /* currently ems cause chrome bug misinterpreting rems on body element */
  line-height: 1.6;
  font-weight: 400;
  font-family: "Raleway", "HelveticaNeue", "Helvetica Neue", Helvetica, Arial, sans-serif;
  color: #222; }


/* Typography
–––––––––––––––––––––––––––––––––––––––––––––––––– */
h1, h2, h3, h4, h5, h6 {
  margin-top: 0;
  margin-bottom: 2rem;
  font-weight: 300; }
h1 { font-size: 4.0rem; line-height: 1.2;  letter-spacing: -.1rem;}
h2 { font-size: 3.6rem; line-height: 1.25; letter-spacing: -.1rem; }
h3 { font-size: 3.0rem; line-height: 1.3;  letter-spacing: -.1rem; }
h4 { font-size: 2.4rem; line-height: 1.35; letter-spacing: -.08rem; }
h5 { font-size: 1.8rem; line-height: 1.5;  letter-spacing: -.05rem; }
h6 { font-size: 1.5rem; line-height: 1.6;  letter-spacing: 0; }

/* Larger than phablet */
@media (min-width: 550px) {
  h1 { font-size: 5.0rem; }
  h2 { font-size: 4.2rem; }
  h3 { font-size: 3.6rem; }
  h4 { font-size: 3.0rem; }
  h5 { font-size: 2.4rem; }
  h6 { font-size: 1.5rem; }
}

p {
  margin-top: 0; }


/* Links
–––––––––––––––––––––––––––––––––––––––––––––––––– */
a {
  color: #1EAEDB; }
a:hover {
  color: #0FA0CE; }


/* Buttons
–––––––––––––––––––––––––––––––––––––––––––––––––– */
.button,
button,
input[type="submit"],
input[type="reset"],
input[type="button"] {
  display: inline-block;
  height: 38px;
  padding: 0 30px;
  color: #555;
  text-align: center;
  font-size: 11px;
  font-weight: 600;
  line-height: 38px;
  letter-spacing: .1rem;
  text-transform: uppercase;
  text-decoration: none;
  white-space: nowrap;
  background-color: transparent;
  border-radius: 4px;
  border: 1px solid #bbb;
  cursor: pointer;
  box-sizing: border-box; }
.button:hover,
button:hover,
input[type="submit"]:hover,
input[type="reset"]:hover,
input[type="button"]:hover,
.button:focus,
button:focus,
input[type="submit"]:focus,
input[type="reset"]:focus,
input[type="button"]:focus {
  color: #333;
  border-color: #888;
  outline: 0; }
.button.button-primary,
button.button-primary,
input[type="submit"].button-primary,
input[type="reset"].button-primary,
input[type="button"].button-primary {
  color: #FFF;
  background-color: #33C3F0;
  border-color: #33C3F0; }
.button.button-primary:hover,
button.button-primary:hover,
input[type="submit"].button-primary:hover,
input[type="reset"].button-primary:hover,
input[type="button"].button-primary:hover,
.button.button-primary:focus,
button.button-primary:focus,
input[type="submit"].button-primary:focus,
input[type="reset"].button-primary:focus,
input[type="button"].button-primary:focus {
  color: #FFF;
  background-color: #1EAEDB;
  border-color: #1EAEDB; }


/* Forms
–––––––––––––––––––––––––––––––––––––––––––––––––– */
input[type="email"],
input[type="number"],
input[type="search"],
input[type="text"],
input[type="tel"],
input[type="url"],
input[type="password"],
textarea,
select {
  height: 38px;
  padding: 6px 10px; /* The 6px vertically centers text on FF, ignored by Webkit */
  background-color: #fff;
  border: 1px solid #D1D1D1;
  border-radius: 4px;
  box-shadow: none;
  box-sizing: border-box; }
/* Removes awkward default styles on some inputs for iOS */
input[type="email"],
input[type="number"],
input[type="search"],
input[type="text"],
input[type="tel"],
input[type="url"],
input[type="password"],
textarea {
  -webkit-appearance: none;
     -moz-appearance: none;
          appearance: none; }
textarea {
  min-height: 65px;
  padding-top: 6px;
  padding-bottom: 6px; }
input[type="email"]:focus,
input[type="number"]:focus,
input[type="search"]:focus,
input[type="text"]:focus,
input[type="tel"]:focus,
input[type="url"]:focus,
input[type="password"]:focus,
textarea:focus,
select:focus {
  border: 1px solid #33C3F0;
  outline: 0; }
label,
legend {
  display: block;
  margin-bottom: .5rem;
  font-weight: 600; }
fieldset {
  padding: 0;
  border-width: 0; }
input[type="checkbox"],
input[type="radio"] {
  display: inline; }
label > .label-body {
  display: inline-block;
  margin-left: .5rem;
  font-weight: normal; }


/* Lists
–––––––––––––––––––––––––––––––––––––––––––––––––– */
ul {
  list-style: circle inside; }
ol {
  list-style: decimal inside; }
ol, ul {
  padding-left: 0;
  margin-top: 0; }
ul ul,
ul ol,
ol ol,
ol ul {
  margin: 1.5rem 0 1.5rem 3rem;
  font-size: 90%; }
li {
  margin-bottom: 1rem; }


/* Code
–––––––––––––––––––––––––––––––––––––––––––––––––– */
code {
  padding: .2rem .5rem;
  margin: 0 .2rem;
  font-size: 90%;
  white-space: nowrap;
  background: #F1F1F1;
  border: 1px solid #E1E1E1;
  border-radius: 4px; }
pre > code {
  display: block;
  padding: 1rem 1.5rem;
  white-space: pre; }


/* Tables
–––––––––––––––––––––––––––––––––––––––––––––––––– */
th,
td {
  padding: 12px 15px;
  text-align: left;
  border-bottom: 1px solid #E1E1E1; }
th:first-child,
td:first-child {
  padding-left: 0; }
th:last-child,
td:last-child {
  padding-right: 0; }


/* Spacing
–––––––––––––––––––––––––––––––––––––––––––––––––– */
button,
.button {
  margin-bottom: 1rem; }
input,
textarea,
select,
fieldset {
  margin-bottom: 1.5rem; }
pre,
blockquote,
dl,
figure,
table,
p,
ul,
ol,
form {
  margin-bottom: 2.5rem; }


/* Utilities
–––––––––––––––––––––––––––––––––––––––––––––––––– */
.u-full-width {
  width: 100%;
  box-sizing: border-box; }
.u-max-full-width {
  max-width: 100%;
  box-sizing: border-box; }
.u-pull-right {
  float: right; }
.u-pull-left {
  float: left; }


/* Misc
–––––––––––––––––––––––––––––––––––––––––––––––––– */
hr {
  margin-top: 3rem;
  margin-bottom: 3.5rem;
  border-width: 0;
  border-top: 1px solid #E1E1E1; }


/* Clearing
–––––––––––––––––––––––––––––––––––––––––––––––––– */

/* Self Clearing Goodness */
.container:after,
.row:after,
.u-cf {
  content: "";
  display: table;
  clear: both; }


/* Media Queries
–––––––––––––––––––––––––––––––––––––––––––––––––– */
/*
Note: The best way to structure the use of media queries is to create the queries
near the relevant code. For example, if you wanted to change the styles for buttons
on small devices, paste the mobile query code up in the buttons section and style it
there.
*/


/* Larger than mobile */
@media (min-width: 400px) {}

/* Larger than phablet (also point when grid becomes active) */
@media (min-width: 550px) {}

/* Larger than tablet */
@media (min-width: 750px) {}

/* Larger than desktop */
@media (min-width: 1000px) {}

/* Larger than Desktop HD */
@media (min-width: 1200px) {}
.hit {background-color: #EAFFEA}
.miss {background-color: #FFECEC}
.container .code {margin-left: 0}
pre {line-height: 1.3}
    </style>
  </head>
  <body>
    <div class="container">
      <table class="u-full-width">
        <thead>
          <tr>
            <th>Filename</th>
            <th>Stmts</th>
            <th>Miss</th>
            <th>Cover</th>
            <th>Missing</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><a href="#__init__.py">__init__.py</a></td>
            <td>0</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#unittests_01_pointer.py">unittests_01_pointer.py</a></td>
            <td>191</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#unittests_02_timetools.py">unittests_02_timetools.py</a></td>
            <td>405</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#unittests_03_filetools.py">unittests_03_filetools.py</a></td>
            <td>0</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#unittests_04_devicetools.py">unittests_04_devicetools.py</a></td>
            <td>320</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#unittests_05_connectiontools.py">unittests_05_connectiontools.py</a></td>
            <td>53</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#unittests_06_selectiontools.py">unittests_06_selectiontools.py</a></td>
            <td>133</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#unittests_07_parametertools.py">unittests_07_parametertools.py</a></td>
            <td>1</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#unittests_08_indextools.py">unittests_08_indextools.py</a></td>
            <td>100</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/__init__.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/__init__.py</a></td>
            <td>24</td>
            <td>1</td>
            <td>95.83%</td>
            <td>32</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/pub.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/pub.py</a></td>
            <td>12</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/__init__.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/__init__.py</a></td>
            <td>0</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/connectiontools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/connectiontools.py</a></td>
            <td>33</td>
            <td>4</td>
            <td>87.88%</td>
            <td>18, 36, 44, 58</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/devicetools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/devicetools.py</a></td>
            <td>376</td>
            <td>113</td>
            <td>69.95%</td>
            <td>47, 60-62, 68, 122, 135-137, 148-149, 154, 166, 172, 181-183, 189-191, 196, 198-199, 202-203, 206, 209, 212-216, 219-229, 315-317, 320-323, 327-329, 337-338, 343-345, 348, 363, 366-376, 379, 382, 385, 399-404, 491, 494, 500, 503, 506, 509-512, 515-527, 530, 538-539, 542-543, 546-547, 555-556, 559-560, 563-564, 567-568</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/filetools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/filetools.py</a></td>
            <td>568</td>
            <td>391</td>
            <td>31.16%</td>
            <td>20-33, 36, 40-41, 46-53, 56, 59-60, 63-71, 74-87, 90, 97-98, 102, 108, 111-116, 122, 128, 135-136, 147-175, 184-197, 204-214, 217, 228-230, 234, 240, 243-248, 254, 260-266, 272-275, 281-297, 303-308, 313, 320, 332-344, 362-374, 383-386, 389-394, 399, 402, 405, 408-420, 423, 436, 440, 444, 448, 452, 456, 460, 464, 468, 478, 483, 486-491, 497, 503-509, 515-518, 524-541, 548-553, 558, 565-582, 589-594, 599, 606-623, 630-635, 640, 648-665, 672-677, 682, 689, 694, 699, 704, 710, 713-717, 726, 731, 742, 745-749, 757, 760, 765, 768, 773, 776, 781, 784, 789, 796-799, 803, 811, 814-819, 825, 833-839, 845-867, 874-879, 884, 891-913, 920-925, 930, 937, 943, 948-958</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/hydpytools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/hydpytools.py</a></td>
            <td>263</td>
            <td>133</td>
            <td>49.43%</td>
            <td>26, 31, 49-53, 56, 59-61, 64-85, 89-101, 105, 110, 115-142, 145-146, 149-150, 153-154, 158-162, 166-181, 193-194, 204, 224-227, 262, 271, 282-283, 290-291, 295, 299, 302, 305, 308, 311, 314, 317, 320-322, 325, 328, 331, 334-342, 348-349, 352, 355, 358-364</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/indextools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/indextools.py</a></td>
            <td>82</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/magictools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/magictools.py</a></td>
            <td>237</td>
            <td>103</td>
            <td>56.54%</td>
            <td>34-37, 41, 45-99, 114, 120-124, 127-129, 132-140, 143, 146-147, 150, 210-212, 230, 240-270, 357</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/modelimports.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/modelimports.py</a></td>
            <td>10</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/modeltools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/modeltools.py</a></td>
            <td>111</td>
            <td>11</td>
            <td>90.09%</td>
            <td>60, 72-73, 96-102, 114-116, 147, 150, 175</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/objecttools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/objecttools.py</a></td>
            <td>367</td>
            <td>87</td>
            <td>76.29%</td>
            <td>51, 102, 148, 382, 385, 393, 396, 405, 408, 417, 420, 472, 481, 489, 494, 516, 523, 527, 542, 614, 621-622, 628-629, 634-635, 640-641, 644-645, 650-651, 663-664, 669-670, 677-680, 683-686, 689-690, 693-696, 699-702, 705-706, 709-712, 715-718, 721-722, 725, 728, 731, 734, 739-740, 745-746, 751-752, 757-758, 761-764, 769-770, 776, 785, 788</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/parametertools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/parametertools.py</a></td>
            <td>661</td>
            <td>135</td>
            <td>79.58%</td>
            <td>51-52, 58-81, 85-96, 100-103, 111, 114, 215-216, 232-235, 240-241, 245, 271, 276, 280-282, 300-320, 335, 346, 352-355, 372-373, 386, 409, 451, 461, 464, 485, 488, 503, 511-512, 526-527, 546-549, 585-586, 592, 605, 616-617, 634, 645-650, 673-674, 678, 692, 696, 716-717, 727, 730-741, 774, 792, 960, 1128, 1147-1148, 1177-1183, 1187, 1202, 1208, 1365-1366, 1373-1374, 1382-1383, 1420, 1433, 1442</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/selectiontools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/selectiontools.py</a></td>
            <td>210</td>
            <td>104</td>
            <td>50.48%</td>
            <td>20-21, 25, 31, 36, 39, 42, 45-48, 51-52, 55, 67-78, 87-91, 94-97, 100-107, 110-116, 119, 127-137, 140, 200-203, 251-253, 263-265, 275-284, 384, 388, 392, 396, 400, 404, 408, 411, 419-443, 446</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/sequencetools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/sequencetools.py</a></td>
            <td>921</td>
            <td>363</td>
            <td>60.59%</td>
            <td>43, 46-48, 51-53, 56-58, 61-63, 86-88, 100-102, 109-111, 115-126, 132-143, 148-167, 170-171, 174, 291-292, 306, 311-314, 319-320, 324, 341-342, 345-346, 349-350, 353-354, 357-358, 406-407, 415-416, 462-464, 490, 503, 514-515, 527-528, 548-549, 561-565, 569-581, 594-595, 599, 617, 620-632, 637, 655-667, 677, 680, 687-690, 693, 696, 703, 709-720, 729, 732, 738-744, 753, 756, 761-764, 767, 770, 776-779, 782, 785, 793, 809, 822, 831, 840, 857, 861, 870, 874, 879-882, 890-933, 940-950, 956-969, 972-977, 981-984, 990, 994, 999, 1003-1010, 1015-1016, 1024, 1031-1033, 1037-1041, 1045-1049, 1062-1071, 1079, 1082, 1104, 1107, 1114, 1117, 1133, 1140-1141, 1191, 1202-1206, 1211-1212, 1222-1223, 1246-1248, 1286, 1292, 1301, 1324-1333, 1341, 1344, 1356-1360, 1377-1383, 1389-1395, 1409-1415, 1421-1427, 1434, 1446, 1449, 1485-1493, 1499-1500, 1510-1522, 1530, 1541-1551</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/testtools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/testtools.py</a></td>
            <td>88</td>
            <td>7</td>
            <td>92.05%</td>
            <td>83, 100, 118, 125-126, 131-132</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/timetools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/timetools.py</a></td>
            <td>547</td>
            <td>107</td>
            <td>80.44%</td>
            <td>370, 408-411, 417, 454-455, 569-570, 611, 614, 633, 653-654, 660, 680-681, 697, 738-739, 748, 804-805, 811, 856-861, 869-873, 941, 961, 978-997, 1001, 1004-1006, 1014-1046, 1056, 1065, 1069, 1072-1073, 1076, 1079-1086, 1089, 1110, 1114, 1122-1124, 1133, 1139, 1145, 1151, 1157, 1162, 1167, 1170, 1180, 1193, 1196-1197, 1200, 1203, 1211-1222, 1225</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/cythons/__init__.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/cythons/__init__.py</a></td>
            <td>1</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/cythons/modelutils.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/cythons/modelutils.py</a></td>
            <td>483</td>
            <td>31</td>
            <td>93.58%</td>
            <td>30-31, 80-81, 84-85, 140, 175, 214-228, 236, 407, 413-419, 553, 570, 623, 634, 637, 663, 671, 675, 751-752</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/docs/__init__.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/docs/__init__.py</a></td>
            <td>0</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/docs/apidoc.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/docs/apidoc.py</a></td>
            <td>18</td>
            <td>18</td>
            <td>0.00%</td>
            <td>2-28</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/docs/conf.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/docs/conf.py</a></td>
            <td>35</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/__init__.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/__init__.py</a></td>
            <td>0</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hbranch_v1.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hbranch_v1.py</a></td>
            <td>25</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland_v1.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland_v1.py</a></td>
            <td>37</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream_v1.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream_v1.py</a></td>
            <td>27</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake_v1.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake_v1.py</a></td>
            <td>34</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland_v1.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland_v1.py</a></td>
            <td>35</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream_v1.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream_v1.py</a></td>
            <td>34</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hbranch/__init__.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hbranch/__init__.py</a></td>
            <td>13</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hbranch/hbranch_control.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hbranch/hbranch_control.py</a></td>
            <td>56</td>
            <td>21</td>
            <td>62.50%</td>
            <td>22, 28, 47-48, 58, 65, 73, 77-86, 91-100</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hbranch/hbranch_derived.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hbranch/hbranch_derived.py</a></td>
            <td>14</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hbranch/hbranch_fluxes.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hbranch/hbranch_fluxes.py</a></td>
            <td>18</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hbranch/hbranch_inlets.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hbranch/hbranch_inlets.py</a></td>
            <td>6</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hbranch/hbranch_model.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hbranch/hbranch_model.py</a></td>
            <td>41</td>
            <td>5</td>
            <td>87.80%</td>
            <td>177, 184-191</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hbranch/hbranch_outlets.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hbranch/hbranch_outlets.py</a></td>
            <td>6</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/__init__.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/__init__.py</a></td>
            <td>18</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_aides.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_aides.py</a></td>
            <td>8</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_constants.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_constants.py</a></td>
            <td>7</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_control.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_control.py</a></td>
            <td>122</td>
            <td>4</td>
            <td>96.72%</td>
            <td>301, 305, 314-315</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_derived.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_derived.py</a></td>
            <td>25</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_fluxes.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_fluxes.py</a></td>
            <td>66</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_inputs.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_inputs.py</a></td>
            <td>12</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_logs.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_logs.py</a></td>
            <td>17</td>
            <td>7</td>
            <td>58.82%</td>
            <td>19-29</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_model.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_model.py</a></td>
            <td>269</td>
            <td>5</td>
            <td>98.14%</td>
            <td>1782, 2198-2201</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_outlets.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_outlets.py</a></td>
            <td>6</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_parameters.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_parameters.py</a></td>
            <td>98</td>
            <td>7</td>
            <td>92.86%</td>
            <td>178-184</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_states.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_states.py</a></td>
            <td>47</td>
            <td>1</td>
            <td>97.87%</td>
            <td>56</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream/__init__.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream/__init__.py</a></td>
            <td>14</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream/hstream_control.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream/hstream_control.py</a></td>
            <td>8</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream/hstream_derived.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream/hstream_derived.py</a></td>
            <td>12</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream/hstream_inlets.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream/hstream_inlets.py</a></td>
            <td>6</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream/hstream_model.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream/hstream_model.py</a></td>
            <td>19</td>
            <td>7</td>
            <td>63.16%</td>
            <td>111-113, 119-122</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream/hstream_outlets.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream/hstream_outlets.py</a></td>
            <td>6</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream/hstream_parameters.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream/hstream_parameters.py</a></td>
            <td>17</td>
            <td>2</td>
            <td>88.24%</td>
            <td>19-20</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream/hstream_states.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream/hstream_states.py</a></td>
            <td>16</td>
            <td>6</td>
            <td>62.50%</td>
            <td>19-24</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake/__init__.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake/__init__.py</a></td>
            <td>15</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake/llake_aides.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake/llake_aides.py</a></td>
            <td>10</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake/llake_control.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake/llake_control.py</a></td>
            <td>43</td>
            <td>2</td>
            <td>95.35%</td>
            <td>152-153</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake/llake_derived.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake/llake_derived.py</a></td>
            <td>28</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake/llake_fluxes.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake/llake_fluxes.py</a></td>
            <td>8</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake/llake_inlets.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake/llake_inlets.py</a></td>
            <td>6</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake/llake_model.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake/llake_model.py</a></td>
            <td>82</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake/llake_outlets.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake/llake_outlets.py</a></td>
            <td>6</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake/llake_states.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake/llake_states.py</a></td>
            <td>8</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/__init__.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/__init__.py</a></td>
            <td>17</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_aides.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_aides.py</a></td>
            <td>18</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_constants.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_constants.py</a></td>
            <td>19</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_control.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_control.py</a></td>
            <td>193</td>
            <td>6</td>
            <td>96.89%</td>
            <td>229, 234, 354, 416, 520, 525</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_derived.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_derived.py</a></td>
            <td>55</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_fluxes.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_fluxes.py</a></td>
            <td>38</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_inputs.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_inputs.py</a></td>
            <td>10</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_model.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_model.py</a></td>
            <td>274</td>
            <td>5</td>
            <td>98.18%</td>
            <td>1464, 1529, 1594, 1658, 1722</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_outlets.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_outlets.py</a></td>
            <td>6</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_parameters.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_parameters.py</a></td>
            <td>18</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_sequences.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_sequences.py</a></td>
            <td>3</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_states.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_states.py</a></td>
            <td>51</td>
            <td>1</td>
            <td>98.04%</td>
            <td>53</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream/__init__.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream/__init__.py</a></td>
            <td>15</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream/lstream_aides.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream/lstream_aides.py</a></td>
            <td>16</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream/lstream_control.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream/lstream_control.py</a></td>
            <td>36</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream/lstream_derived.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream/lstream_derived.py</a></td>
            <td>36</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream/lstream_fluxes.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream/lstream_fluxes.py</a></td>
            <td>34</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream/lstream_inlets.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream/lstream_inlets.py</a></td>
            <td>6</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream/lstream_model.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream/lstream_model.py</a></td>
            <td>166</td>
            <td>3</td>
            <td>98.19%</td>
            <td>865-866, 942</td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream/lstream_outlets.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream/lstream_outlets.py</a></td>
            <td>6</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
          <tr>
            <td><a href="#/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream/lstream_states.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream/lstream_states.py</a></td>
            <td>8</td>
            <td>0</td>
            <td>100.00%</td>
            <td></td>
          </tr>
        </tbody>
        <tfoot>
          <tr>
            <td>TOTAL</td>
            <td>8620</td>
            <td>1690</td>
            <td>80.39%</td>
            <td></td>
          </tr>
        </tfoot>
      </table>
<h4 id="__init__.py">__init__.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre></pre>
      </td>
      <td class="source">
        <pre></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="unittests_01_pointer.py">unittests_01_pointer.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import unittest
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.cythons import pointer
</span><span class="noop">
</span><span class="hit">class Test1Initialization(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.test_1_init_double()
</span><span class="hit">        self.test_2_init_p_double()
</span><span class="hit">        self.test_3_change_double()
</span><span class="hit">        self.test_4_change_p_double()
</span><span class="noop">
</span><span class="hit">    def test_1_init_double(self):
</span><span class="hit">        self.d = pointer.Double(2.)
</span><span class="hit">    def test_2_init_p_double(self):
</span><span class="hit">        self.p = pointer.PDouble(self.d)
</span><span class="hit">    def test_3_change_double(self):
</span><span class="hit">        self.d.setvalue(4.)
</span><span class="hit">        self.assertEqual(self.d, self.p)
</span><span class="hit">    def test_4_change_p_double(self):
</span><span class="hit">        self.p.setvalue(-3.)
</span><span class="hit">        self.assertEqual(self.d, self.p)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test2InputConversion(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.f_x = 2.1
</span><span class="hit">        self.f_y = 5.6
</span><span class="hit">        self.d_x = pointer.Double(self.f_x)
</span><span class="hit">        self.d_y = pointer.Double(self.f_y)
</span><span class="hit">        self.p_x = pointer.PDouble(self.d_x)
</span><span class="hit">        self.p_y = pointer.PDouble(self.d_y)
</span><span class="noop">
</span><span class="hit">    def test_double_add_float(self):
</span><span class="hit">        self.assertEqual(self.d_x + self.f_y,
</span><span class="noop">                         self.f_x + self.f_y)
</span><span class="hit">    def test_float_add_double(self):
</span><span class="hit">        self.assertEqual(self.f_x + self.d_y,
</span><span class="noop">                         self.f_x + self.f_y)
</span><span class="hit">    def test_p_double_add_float(self):
</span><span class="hit">        self.assertEqual(self.p_x + self.f_y,
</span><span class="noop">                         self.f_x + self.f_y)
</span><span class="hit">    def test_float_add_p_double(self):
</span><span class="hit">        self.assertEqual(self.f_x + self.p_y,
</span><span class="noop">                         self.f_x + self.f_y)
</span><span class="hit">    def test_double_add_p_double(self):
</span><span class="hit">        self.assertEqual(self.d_x + self.p_y,
</span><span class="noop">                         self.f_x + self.f_y)
</span><span class="hit">    def test_p_double_add_double(self):
</span><span class="hit">        self.assertEqual(self.p_x + self.d_y,
</span><span class="noop">                         self.f_x + self.f_y)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TestRhichCompare(object):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.f_small = 2.1
</span><span class="hit">        self.f_large = 5.3
</span><span class="noop">
</span><span class="hit">    def test_small_lt_large(self):
</span><span class="hit">        self.assertEqual(self.d_small &gt; self.d_large,
</span><span class="noop">                         self.f_large &gt; self.f_large)
</span><span class="hit">    def test_large_lt_small(self):
</span><span class="hit">        self.assertEqual(self.d_large &lt; self.d_small,
</span><span class="noop">                         self.f_large &lt; self.f_small)
</span><span class="hit">    def test_small_lt_small(self):
</span><span class="hit">        self.assertEqual(self.d_small &lt; self.d_small,
</span><span class="noop">                         self.f_small &lt; self.f_small)
</span><span class="hit">    def test_small_le_large(self):
</span><span class="hit">        self.assertEqual(self.d_small &lt;= self.d_large,
</span><span class="noop">                         self.f_small &lt;= self.f_large)
</span><span class="hit">    def test_large_le_small(self):
</span><span class="hit">        self.assertEqual(self.d_large &lt;= self.d_small,
</span><span class="noop">                         self.f_large &lt;= self.f_small)
</span><span class="hit">    def test_small_le_small(self):
</span><span class="hit">        self.assertEqual(self.d_small &lt;= self.d_small,
</span><span class="noop">                         self.f_small &lt;= self.f_small)
</span><span class="hit">    def test_small_eq_large(self):
</span><span class="hit">        self.assertEqual(self.d_small == self.d_large,
</span><span class="noop">                         self.f_small == self.f_large)
</span><span class="hit">    def test_large_eq_small(self):
</span><span class="hit">        self.assertEqual(self.d_large == self.d_small,
</span><span class="noop">                         self.f_large == self.f_small)
</span><span class="hit">    def test_small_eq_small(self):
</span><span class="hit">        self.assertEqual(self.d_small == self.d_small,
</span><span class="noop">                         self.f_small == self.f_small)
</span><span class="hit">    def test_small_gt_large(self):
</span><span class="hit">        self.assertEqual(self.d_small &gt; self.d_large,
</span><span class="noop">                         self.f_small &gt; self.f_large)
</span><span class="hit">    def test_large_gt_small(self):
</span><span class="hit">        self.assertEqual(self.d_large &gt; self.d_small,
</span><span class="noop">                         self.f_large &gt; self.f_small)
</span><span class="hit">    def test_small_gt_small(self):
</span><span class="hit">        self.assertEqual(self.d_small &gt; self.d_small,
</span><span class="noop">                         self.f_small &gt; self.f_small)
</span><span class="hit">    def test_small_ge_large(self):
</span><span class="hit">        self.assertEqual(self.d_small &gt;= self.d_large,
</span><span class="noop">                         self.f_small &gt;= self.f_large)
</span><span class="hit">    def test_large_ge_small(self):
</span><span class="hit">        self.assertEqual(self.d_large &gt;= self.d_small,
</span><span class="noop">                         self.f_large &gt;= self.f_small)
</span><span class="hit">    def test_small_ge_small(self):
</span><span class="hit">        self.assertEqual(self.d_small &gt;= self.d_small,
</span><span class="noop">                         self.f_small &gt;= self.f_small)
</span><span class="hit">    def test_small_ne_large(self):
</span><span class="hit">        self.assertEqual(self.d_small != self.d_large,
</span><span class="noop">                         self.f_small != self.f_large)
</span><span class="hit">    def test_large_ne_small(self):
</span><span class="hit">        self.assertEqual(self.d_large != self.d_small,
</span><span class="noop">                         self.f_large != self.f_small)
</span><span class="hit">    def test_small_ne_small(self):
</span><span class="hit">        self.assertEqual(self.d_small != self.d_small,
</span><span class="noop">                         self.f_small != self.f_small)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test3RhichCompareDouble(unittest.TestCase, TestRhichCompare):
</span><span class="hit">    def setUp(self):
</span><span class="hit">        TestRhichCompare.setUp(self)
</span><span class="hit">        self.d_small = pointer.Double(self.f_small)
</span><span class="hit">        self.d_large = pointer.Double(self.f_large)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test4RhichComparePDouble(unittest.TestCase, TestRhichCompare):
</span><span class="hit">    def setUp(self):
</span><span class="hit">        TestRhichCompare.setUp(self)
</span><span class="hit">        self._small = pointer.Double(self.f_small)
</span><span class="hit">        self._large = pointer.Double(self.f_large)
</span><span class="hit">        self.d_small = pointer.PDouble(self._small)
</span><span class="hit">        self.d_large = pointer.PDouble(self._large)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TestArithmetic(object):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.f_x = 2.1
</span><span class="hit">        self.f_y = 5.3
</span><span class="noop">
</span><span class="hit">    def test_add(self):
</span><span class="hit">        self.assertEqual(self.d_x + self.d_y,
</span><span class="noop">                         self.f_x + self.f_y)
</span><span class="hit">    def test_sub(self):
</span><span class="hit">        self.assertEqual(self.d_x - self.d_y,
</span><span class="noop">                         self.f_x - self.f_y)
</span><span class="hit">    def test_mul(self):
</span><span class="hit">        self.assertEqual(self.d_x * self.d_y,
</span><span class="noop">                         self.f_x * self.f_y)
</span><span class="hit">    def test_div(self):
</span><span class="hit">        self.assertEqual(self.d_x / self.d_y,
</span><span class="noop">                         self.f_x / self.f_y)
</span><span class="hit">    def test_floordiv(self):
</span><span class="hit">        self.assertEqual(self.d_x // self.d_y,
</span><span class="noop">                         self.f_x // self.f_y)
</span><span class="hit">    def test_truediv(self):
</span><span class="hit">        self.assertEqual(self.d_x / self.d_y,
</span><span class="noop">                         self.f_x / self.f_y)
</span><span class="hit">    def test_mod(self):
</span><span class="hit">        self.assertEqual(self.d_x % self.d_y,
</span><span class="noop">                         self.f_x % self.f_y)
</span><span class="hit">    def test_pow(self):
</span><span class="hit">        self.assertEqual(self.d_x ** self.d_y,
</span><span class="noop">                         self.f_x ** self.f_y)
</span><span class="hit">    def test_neg(self):
</span><span class="hit">        self.assertEqual(-self.d_x,
</span><span class="noop">                         -self.f_x)
</span><span class="hit">    def test_pos(self):
</span><span class="hit">        self.assertEqual(+self.d_x,
</span><span class="noop">                         +self.f_x)
</span><span class="hit">    def test_nonzero(self):
</span><span class="hit">        self.assertEqual(bool(self.d_x),
</span><span class="noop">                         bool(self.f_x))
</span><span class="hit">    def test_invert(self):
</span><span class="hit">        self.assertEqual(~self.d_x,
</span><span class="noop">                         1./self.f_x)
</span><span class="noop">
</span><span class="hit">class Test5ArithmeticDouble(unittest.TestCase, TestArithmetic):
</span><span class="hit">    def setUp(self):
</span><span class="hit">        TestArithmetic.setUp(self)
</span><span class="hit">        self.d_x = pointer.Double(self.f_x)
</span><span class="hit">        self.d_y = pointer.Double(self.f_y)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test6ArithmeticPDouble(unittest.TestCase, TestArithmetic):
</span><span class="hit">    def setUp(self):
</span><span class="hit">        TestArithmetic.setUp(self)
</span><span class="hit">        self._d_x = pointer.Double(self.f_x)
</span><span class="hit">        self._d_y = pointer.Double(self.f_y)
</span><span class="hit">        self.d_x = pointer.PDouble(self._d_x)
</span><span class="hit">        self.d_y = pointer.PDouble(self._d_y)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TestNumericConversion(object):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.f_x = 2.1
</span><span class="noop">
</span><span class="hit">    def test_int(self):
</span><span class="hit">        self.assertEqual(int(self.d_x),
</span><span class="noop">                         int(self.f_x))
</span><span class="noop">
</span><span class="hit">    def test_float(self):
</span><span class="hit">        self.assertEqual(float(self.d_x),
</span><span class="noop">                         float(self.f_x))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test7NumericConversionDouble(unittest.TestCase, TestNumericConversion):
</span><span class="hit">    def setUp(self):
</span><span class="hit">        TestNumericConversion.setUp(self)
</span><span class="hit">        self.d_x = pointer.Double(self.f_x)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test8NumericConversionPDouble(unittest.TestCase, TestNumericConversion):
</span><span class="hit">    def setUp(self):
</span><span class="hit">        TestNumericConversion.setUp(self)
</span><span class="hit">        self._d_x = pointer.Double(self.f_x)
</span><span class="hit">        self.d_x = pointer.PDouble(self._d_x)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TestInPlaceOperators(object):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.f_x = 2.1
</span><span class="hit">        self.f_y = 5.3
</span><span class="noop">
</span><span class="hit">    def test_iadd(self):
</span><span class="hit">        self.d_x += self.d_y
</span><span class="hit">        self.f_x += self.f_y
</span><span class="hit">        self.assertEqual(self.d_x, self.f_x)
</span><span class="hit">    def test_isub(self):
</span><span class="hit">        self.d_x -= self.d_y
</span><span class="hit">        self.f_x -= self.f_y
</span><span class="hit">        self.assertEqual(self.d_x, self.f_x)
</span><span class="hit">    def test_imul(self):
</span><span class="hit">        self.d_x *= self.d_y
</span><span class="hit">        self.f_x *= self.f_y
</span><span class="hit">        self.assertEqual(self.d_x, self.f_x)
</span><span class="hit">    def test_idiv(self):
</span><span class="hit">        self.d_x /= self.d_y
</span><span class="hit">        self.f_x /= self.f_y
</span><span class="hit">        self.assertEqual(self.d_x, self.f_x)
</span><span class="hit">    def test_ifloordiv(self):
</span><span class="hit">        self.d_x //= self.d_y
</span><span class="hit">        self.f_x //= self.f_y
</span><span class="hit">        self.assertEqual(self.d_x, self.f_x)
</span><span class="hit">    def test_itruediv(self):
</span><span class="hit">        self.d_x /= self.d_y
</span><span class="hit">        self.f_x /= self.f_y
</span><span class="hit">        self.assertEqual(self.d_x, self.f_x)
</span><span class="hit">    def test_imod(self):
</span><span class="hit">        self.d_x %= self.d_y
</span><span class="hit">        self.f_x %= self.f_y
</span><span class="hit">        self.assertEqual(self.d_x, self.f_x)
</span><span class="noop">
</span><span class="hit">class Test9InPlaceOperatorsDouble(unittest.TestCase, TestInPlaceOperators):
</span><span class="hit">    def setUp(self):
</span><span class="hit">        TestInPlaceOperators.setUp(self)
</span><span class="hit">        self.d_x = pointer.Double(self.f_x)
</span><span class="hit">        self.d_y = pointer.Double(self.f_y)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test10InPlaceOperatorsPDouble(unittest.TestCase, TestInPlaceOperators):
</span><span class="hit">    def setUp(self):
</span><span class="hit">        TestInPlaceOperators.setUp(self)
</span><span class="hit">        self._d_x = pointer.Double(self.f_x)
</span><span class="hit">        self._d_y = pointer.Double(self.f_y)
</span><span class="hit">        self.d_x = pointer.PDouble(self._d_x)
</span><span class="hit">        self.d_y = pointer.PDouble(self._d_y)
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="unittests_02_timetools.py">unittests_02_timetools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import unittest
</span><span class="hit">import datetime
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core import timetools
</span><span class="noop">
</span><span class="hit">class Test01DateInitialization(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.refdate_day = datetime.datetime(1996, 11, 1)
</span><span class="hit">        self.refdate_hour = datetime.datetime(1996, 11, 1, 12)
</span><span class="hit">        self.refdate_minute = datetime.datetime(1996, 11, 1, 12, 30)
</span><span class="hit">        self.refdate_second = datetime.datetime(1996, 11, 1, 12, 30, 5)
</span><span class="noop">
</span><span class="hit">    def test_01_os_style_day(self):
</span><span class="hit">        self.assertEqual(self.refdate_day,
</span><span class="noop">                         timetools.Date(&#39;1996_11_01&#39;).datetime)
</span><span class="hit">    def test_02_os_style_hour(self):
</span><span class="hit">        self.assertEqual(self.refdate_hour,
</span><span class="noop">                         timetools.Date(&#39;1996_11_01_12&#39;).datetime)
</span><span class="hit">    def test_03_os_style_minute(self):
</span><span class="hit">        self.assertEqual(self.refdate_minute,
</span><span class="noop">                         timetools.Date(&#39;1996_11_01_12_30&#39;).datetime)
</span><span class="hit">    def test_03_os_style_second(self):
</span><span class="hit">        self.assertEqual(self.refdate_second,
</span><span class="noop">                         timetools.Date(&#39;1996_11_01_12_30_05&#39;).datetime)
</span><span class="noop">
</span><span class="hit">    def test_04_iso_style_day(self):
</span><span class="hit">        self.assertEqual(self.refdate_day,
</span><span class="noop">                         timetools.Date(&#39;1996.11.01&#39;).datetime)
</span><span class="hit">    def test_05_iso_style_day(self):
</span><span class="hit">        self.assertEqual(self.refdate_hour,
</span><span class="noop">                         timetools.Date(&#39;1996.11.01 12&#39;).datetime)
</span><span class="hit">    def test_06_iso_style_minute(self):
</span><span class="hit">        self.assertEqual(self.refdate_minute,
</span><span class="noop">                         timetools.Date(&#39;1996.11.01 12:30&#39;).datetime)
</span><span class="hit">    def test_07_iso_style_second(self):
</span><span class="hit">        self.assertEqual(self.refdate_second,
</span><span class="noop">                         timetools.Date(&#39;1996.11.01 12:30:05&#39;).datetime)
</span><span class="noop">
</span><span class="hit">    def test_08_din_style_day(self):
</span><span class="hit">        self.assertEqual(self.refdate_day,
</span><span class="noop">                         timetools.Date(&#39;01.11.1996&#39;).datetime)
</span><span class="hit">    def test_09_din_style_day(self):
</span><span class="hit">        self.assertEqual(self.refdate_hour,
</span><span class="noop">                         timetools.Date(&#39;01.11.1996 12&#39;).datetime)
</span><span class="hit">    def test_10_din_style_minute(self):
</span><span class="hit">        self.assertEqual(self.refdate_minute,
</span><span class="noop">                         timetools.Date(&#39;01.11.1996 12:30&#39;).datetime)
</span><span class="hit">    def test_11_din_style_second(self):
</span><span class="hit">        self.assertEqual(self.refdate_second,
</span><span class="noop">                         timetools.Date(&#39;01.11.1996 12:30:05&#39;).datetime)
</span><span class="noop">
</span><span class="hit">    def test_11_datetime_second(self):
</span><span class="hit">        self.assertEqual(self.refdate_second,
</span><span class="noop">                         timetools.Date(self.refdate_second).datetime)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test02DateProperties(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.refdate = datetime.datetime(1996, 11, 1, 12, 30, 5)
</span><span class="hit">        self.testdate = timetools.Date(self.refdate)
</span><span class="noop">
</span><span class="hit">    def test_01_get_year(self):
</span><span class="hit">        self.assertEqual(self.refdate.year, self.testdate.year)
</span><span class="hit">    def test_02_get_month(self):
</span><span class="hit">        self.assertEqual(self.refdate.month, self.testdate.month)
</span><span class="hit">    def test_03_get_day(self):
</span><span class="hit">        self.assertEqual(self.refdate.day, self.testdate.day)
</span><span class="hit">    def test_04_get_hour(self):
</span><span class="hit">        self.assertEqual(self.refdate.hour, self.testdate.hour)
</span><span class="hit">    def test_05_get_minute(self):
</span><span class="hit">        self.assertEqual(self.refdate.minute, self.testdate.minute)
</span><span class="hit">    def test_06_get_second(self):
</span><span class="hit">        self.assertEqual(self.refdate.second, self.testdate.second)
</span><span class="noop">
</span><span class="hit">    def test_07_set_year(self):
</span><span class="hit">        self.testdate.year = 2000
</span><span class="hit">        refdate = datetime.datetime(2000, 11, 1, 12, 30, 5)
</span><span class="hit">        self.assertEqual(refdate.year, self.testdate.datetime.year)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.testdate.year = &#39;wrong&#39;
</span><span class="hit">    def test_08_set_month(self):
</span><span class="hit">        self.testdate.month = 5
</span><span class="hit">        refdate = datetime.datetime(1996, 5, 1, 12, 30, 5)
</span><span class="hit">        self.assertEqual(refdate.month, self.testdate.datetime.month)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.testdate.month = &#39;wrong&#39;
</span><span class="hit">    def test_09_set_day(self):
</span><span class="hit">        self.testdate.day = 30
</span><span class="hit">        refdate = datetime.datetime(1996, 11, 30, 12, 30, 5)
</span><span class="hit">        self.assertEqual(refdate.day, self.testdate.datetime.day)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.testdate.day = &#39;wrong&#39;
</span><span class="hit">    def test_10_set_hour(self):
</span><span class="hit">        self.testdate.hour = 0
</span><span class="hit">        refdate = datetime.datetime(1996, 11, 1, 0, 30, 5)
</span><span class="hit">        self.assertEqual(refdate.hour, self.testdate.datetime.hour)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.testdate.hour = &#39;wrong&#39;
</span><span class="hit">    def test_11_set_minute(self):
</span><span class="hit">        self.testdate.minute = 59
</span><span class="hit">        refdate = datetime.datetime(1996, 11, 1, 12, 59, 5)
</span><span class="hit">        self.assertEqual(refdate.minute, self.testdate.datetime.minute)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.testdate.minute = &#39;wrong&#39;
</span><span class="hit">    def test_12_set_second(self):
</span><span class="hit">        self.testdate.second = 7
</span><span class="hit">        refdate = datetime.datetime(1996, 11, 1, 12, 30, 7)
</span><span class="hit">        self.assertEqual(refdate.second, self.testdate.datetime.second)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.testdate.second = &#39;wrong&#39;
</span><span class="hit">    def test_13_get_wateryear(self):
</span><span class="hit">        self.assertEqual(self.testdate.wateryear, self.testdate.year+1)
</span><span class="hit">        self.testdate.month = 10
</span><span class="hit">        self.assertEqual(self.testdate.wateryear, self.testdate.year)
</span><span class="hit">    def test_14_set_refmonth(self):
</span><span class="hit">        self.testdate.refmonth = 3
</span><span class="hit">        self.assertEqual(self.testdate.refmonth, 3)
</span><span class="hit">        self.testdate.refmonth = &#39;July&#39;
</span><span class="hit">        self.assertEqual(self.testdate.refmonth, 7)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.testdate.refmonth = &#39;Ju&#39;
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test03DateStyle(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.date = timetools.Date(&#39;01.11.1996&#39;)
</span><span class="noop">
</span><span class="hit">    def test_01_remember_style(self):
</span><span class="hit">        self.assertEqual(self.date.style, &#39;din&#39;)
</span><span class="hit">    def test_02_dontforget_style(self):
</span><span class="hit">        self.date.string(&#39;iso&#39;)
</span><span class="hit">        self.assertEqual(self.date.style, &#39;din&#39;)
</span><span class="hit">    def test_03_change_style(self):
</span><span class="hit">        self.date.style = &#39;iso&#39;
</span><span class="hit">        self.assertEqual(self.date.style, &#39;iso&#39;)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test04DateCopy(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.date = timetools.Date(&#39;01.11.1996&#39;)
</span><span class="noop">
</span><span class="hit">    def test_01_ids(self):
</span><span class="hit">        testdate = self.date.copy()
</span><span class="hit">        self.assertNotEqual(id(testdate), id(self.date))
</span><span class="hit">    def test_02_values(self):
</span><span class="hit">        testdate = self.date.copy()
</span><span class="hit">        testdate.year = 2000
</span><span class="hit">        self.assertNotEqual(testdate.datetime.year, self.date.datetime.year)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test05DateComparisons(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.early1 = timetools.Date(&#39;01.11.1996&#39;)
</span><span class="hit">        self.early2 = timetools.Date(&#39;01.11.1996&#39;)
</span><span class="hit">        self.late = timetools.Date(&#39;01.11.1997&#39;)
</span><span class="noop">
</span><span class="hit">    def test_01_lt(self):
</span><span class="hit">        self.assertTrue(self.early1 &lt; self.late)
</span><span class="hit">        self.assertFalse(self.early1 &lt; self.early2)
</span><span class="hit">        self.assertFalse(self.late &lt; self.early2)
</span><span class="hit">    def test_021_le(self):
</span><span class="hit">        self.assertTrue(self.early1 &lt;= self.late)
</span><span class="hit">        self.assertTrue(self.early1 &lt;= self.early2)
</span><span class="hit">        self.assertFalse(self.late &lt;= self.early2)
</span><span class="hit">    def test_03_eq(self):
</span><span class="hit">        self.assertFalse(self.early1 == self.late)
</span><span class="hit">        self.assertTrue(self.early1 == self.early2)
</span><span class="hit">        self.assertFalse(self.late == self.early2)
</span><span class="hit">    def test_04_ne(self):
</span><span class="hit">        self.assertTrue(self.early1 != self.late)
</span><span class="hit">        self.assertFalse(self.early1 != self.early2)
</span><span class="hit">        self.assertTrue(self.late != self.early2)
</span><span class="hit">    def test_05_gt(self):
</span><span class="hit">        self.assertFalse(self.early1 &gt; self.late)
</span><span class="hit">        self.assertFalse(self.early1 &gt; self.early2)
</span><span class="hit">        self.assertTrue(self.late &gt; self.early2)
</span><span class="hit">    def test_06_ge(self):
</span><span class="hit">        self.assertFalse(self.early1 &gt;= self.late)
</span><span class="hit">        self.assertTrue(self.early1 &gt;= self.early2)
</span><span class="hit">        self.assertTrue(self.late &gt;= self.early2)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test06DateArithmetic(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.earlydate = timetools.Date(&#39;01.11.1996&#39;)
</span><span class="hit">        self.latedate = timetools.Date(&#39;01.11.1997&#39;)
</span><span class="hit">        self.period = timetools.Period(&#39;365d&#39;)
</span><span class="noop">
</span><span class="hit">    def test_01_add(self):
</span><span class="hit">        testdate = self.earlydate + self.period
</span><span class="hit">        self.assertEqual(self.latedate, testdate)
</span><span class="hit">        self.assertEqual(testdate.style, &#39;din&#39;)
</span><span class="hit">    def test_02_iadd(self):
</span><span class="hit">        self.earlydate += self.period
</span><span class="hit">        self.assertEqual(self.earlydate, self.latedate)
</span><span class="hit">        self.assertEqual(self.earlydate.style, &#39;din&#39;)
</span><span class="hit">    def test_03_sub(self):
</span><span class="hit">        testdate = self.latedate - self.period
</span><span class="hit">        self.assertEqual(self.earlydate, testdate)
</span><span class="hit">        self.assertEqual(testdate.style, &#39;din&#39;)
</span><span class="hit">    def test_04_isub(self):
</span><span class="hit">        self.latedate -= self.period
</span><span class="hit">        self.assertEqual(self.latedate, self.earlydate)
</span><span class="hit">        self.assertEqual(self.latedate.style, &#39;din&#39;)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test07PeriodInitialization(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def test_01_string_day(self):
</span><span class="hit">        self.assertEqual(datetime.timedelta(1),
</span><span class="noop">                         timetools.Period(&#39;1d&#39;).timedelta)
</span><span class="hit">        self.assertEqual(datetime.timedelta(365),
</span><span class="noop">                         timetools.Period(&#39;365d&#39;).timedelta)
</span><span class="hit">    def test_02_string_hour(self):
</span><span class="hit">        self.assertEqual(datetime.timedelta(0, 60*60),
</span><span class="noop">                         timetools.Period(&#39;1h&#39;).timedelta)
</span><span class="hit">    def test_03_string_minute(self):
</span><span class="hit">        self.assertEqual(datetime.timedelta(0, 60),
</span><span class="noop">                         timetools.Period(&#39;1m&#39;).timedelta)
</span><span class="hit">    def test_04_string_second(self):
</span><span class="hit">        self.assertEqual(datetime.timedelta(0, 1),
</span><span class="noop">                         timetools.Period(&#39;1s&#39;).timedelta)
</span><span class="hit">    def test_05_timedelta(self):
</span><span class="hit">        timedelta = datetime.timedelta(365)
</span><span class="hit">        self.assertEqual(timedelta, timetools.Period(timedelta).timedelta)
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test08PeriodProperties(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        seconds = int(60*60*24*365*3.2)
</span><span class="hit">        self.refperiod = datetime.timedelta(0, seconds)
</span><span class="hit">        self.testperiod = timetools.Period(&#39;%ds&#39; % seconds)
</span><span class="noop">
</span><span class="hit">    def test_01_get_days(self):
</span><span class="hit">        self.assertEqual(self.refperiod.total_seconds()/60/60/24,
</span><span class="noop">                         self.testperiod.days)
</span><span class="hit">    def test_02_get_hours(self):
</span><span class="hit">        self.assertEqual(self.refperiod.total_seconds()/60/60,
</span><span class="noop">                         self.testperiod.hours)
</span><span class="hit">    def test_03_get_minutes(self):
</span><span class="hit">        self.assertEqual(self.refperiod.total_seconds()/60,
</span><span class="noop">                         self.testperiod.minutes)
</span><span class="hit">    def test_04_get_seconds(self):
</span><span class="hit">        self.assertEqual(self.refperiod.total_seconds(),
</span><span class="noop">                         self.testperiod.seconds)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test09PeriodUnit(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def test_01_day(self):
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;365d&#39;).unit, &#39;d&#39;)
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;1d&#39;).unit, &#39;d&#39;)
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;24h&#39;).unit, &#39;d&#39;)
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;1440m&#39;).unit, &#39;d&#39;)
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;86400m&#39;).unit, &#39;d&#39;)
</span><span class="hit">    def test_02_hour(self):
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;25h&#39;).unit, &#39;h&#39;)
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;1h&#39;).unit, &#39;h&#39;)
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;60m&#39;).unit, &#39;h&#39;)
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;3600s&#39;).unit, &#39;h&#39;)
</span><span class="hit">    def test_03_minute(self):
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;777m&#39;).unit, &#39;m&#39;)
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;1m&#39;).unit, &#39;m&#39;)
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;60s&#39;).unit, &#39;m&#39;)
</span><span class="hit">    def test_04_second(self):
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;999s&#39;).unit, &#39;s&#39;)
</span><span class="hit">        self.assertEqual(timetools.Period(&#39;1s&#39;).unit, &#39;s&#39;)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test10PeriodCopy(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.period = timetools.Period(&#39;1d&#39;)
</span><span class="noop">
</span><span class="hit">    def test_01_ids(self):
</span><span class="hit">        testperiod = self.period.copy()
</span><span class="hit">        self.assertNotEqual(id(testperiod), id(self.period))
</span><span class="hit">    def test_02_values(self):
</span><span class="hit">        testperiod = self.period.copy()
</span><span class="hit">        testperiod += &#39;1d&#39;
</span><span class="hit">        self.assertNotEqual(testperiod.timedelta,
</span><span class="noop">                            self.period.timedelta)
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test11PeriodComparisons(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.short1 = timetools.Period(&#39;1h&#39;)
</span><span class="hit">        self.short2 = timetools.Period(&#39;1h&#39;)
</span><span class="hit">        self.long = timetools.Period(&#39;1d&#39;)
</span><span class="noop">
</span><span class="hit">    def test_01_lt(self):
</span><span class="hit">        self.assertTrue(self.short1 &lt; self.long)
</span><span class="hit">        self.assertFalse(self.short1 &lt; self.short2)
</span><span class="hit">        self.assertFalse(self.long &lt; self.short2)
</span><span class="hit">    def test_021_le(self):
</span><span class="hit">        self.assertTrue(self.short1 &lt;= self.long)
</span><span class="hit">        self.assertTrue(self.short1 &lt;= self.short2)
</span><span class="hit">        self.assertFalse(self.long &lt;= self.short2)
</span><span class="hit">    def test_03_eq(self):
</span><span class="hit">        self.assertFalse(self.short1 == self.long)
</span><span class="hit">        self.assertTrue(self.short1 == self.short2)
</span><span class="hit">        self.assertFalse(self.long == self.short2)
</span><span class="hit">    def test_04_ne(self):
</span><span class="hit">        self.assertTrue(self.short1 != self.long)
</span><span class="hit">        self.assertFalse(self.short1 != self.short2)
</span><span class="hit">        self.assertTrue(self.long != self.short2)
</span><span class="hit">    def test_05_gt(self):
</span><span class="hit">        self.assertFalse(self.short1 &gt; self.long)
</span><span class="hit">        self.assertFalse(self.short1 &gt; self.short2)
</span><span class="hit">        self.assertTrue(self.long &gt; self.short2)
</span><span class="hit">    def test_06_ge(self):
</span><span class="hit">        self.assertFalse(self.short1 &gt;= self.long)
</span><span class="hit">        self.assertTrue(self.short1 &gt;= self.short2)
</span><span class="hit">        self.assertTrue(self.long &gt;= self.short2)
</span><span class="noop">#    def test_07_true(self):
</span><span class="noop">#        self.assertTrue(self.short1)
</span><span class="noop">#        self.assertTrue(self.long)
</span><span class="noop">#        self.assertFalse(timetools.Period(&#39;0d&#39;))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test12PeriodArithmetic(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.year97 = timetools.Date(&#39;01.11.1996&#39;)
</span><span class="hit">        self.year98 = timetools.Date(&#39;01.11.1997&#39;)
</span><span class="hit">        self.oneyear = timetools.Period(&#39;365d&#39;)
</span><span class="hit">        self.oneday = timetools.Period(&#39;1d&#39;)
</span><span class="noop">
</span><span class="hit">    def test_01_add(self):
</span><span class="hit">        testdate = self.oneyear + self.year97
</span><span class="hit">        self.assertEqual(self.year98, testdate)
</span><span class="hit">        self.assertEqual(testdate.style, &#39;din&#39;)
</span><span class="hit">        self.assertEqual(self.oneyear + self.oneday, timetools.Period(&#39;366d&#39;))
</span><span class="hit">    def test_02_iadd(self):
</span><span class="hit">        self.oneyear += self.oneday
</span><span class="hit">        self.assertEqual(self.oneyear, timetools.Period(&#39;366d&#39;))
</span><span class="hit">    def test_03_sub(self):
</span><span class="hit">        testdate = self.year98 - self.oneyear
</span><span class="hit">        self.assertEqual(self.year97, testdate)
</span><span class="hit">    def test_04_isub(self):
</span><span class="hit">        self.oneyear -= self.oneday
</span><span class="hit">        self.assertEqual(self.oneyear, timetools.Period(&#39;364d&#39;))
</span><span class="hit">    def test_05_mul(self):
</span><span class="hit">        testperiod = self.oneday * 365
</span><span class="hit">        self.assertEqual(testperiod, self.oneyear)
</span><span class="hit">    def test_06_rmul(self):
</span><span class="hit">        testperiod = 365 * self.oneday
</span><span class="hit">        self.assertEqual(testperiod, self.oneyear)
</span><span class="hit">    def test_07_imul(self):
</span><span class="hit">        self.oneday *= 365
</span><span class="hit">        self.assertEqual(self.oneday, self.oneyear)
</span><span class="hit">    def test_08_div(self):
</span><span class="hit">        testperiod = self.oneyear / self.oneday
</span><span class="hit">        self.assertEqual(testperiod, 365)
</span><span class="hit">        testinteger = self.oneyear / 365
</span><span class="hit">        self.assertEqual(testinteger, self.oneday)
</span><span class="hit">    def test_09_idiv(self):
</span><span class="hit">        self.oneyear /= 365
</span><span class="hit">        self.assertEqual(self.oneyear,  self.oneday)
</span><span class="hit">    def test_10_mod(self):
</span><span class="hit">        self.assertFalse(self.oneyear % self.oneday)
</span><span class="hit">        self.assertTrue(self.oneyear % timetools.Period(&#39;360d&#39;))
</span><span class="hit">    def test_11_floordiv(self):
</span><span class="hit">        self.assertTrue(self.oneyear // self.oneday)
</span><span class="hit">        self.assertFalse(self.oneyear // timetools.Period(&#39;360d&#39;))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test13TimegridInitialization(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.year97 = timetools.Date(&#39;01.11.1996&#39;)
</span><span class="hit">        self.year98 = timetools.Date(&#39;01.11.1997&#39;)
</span><span class="hit">        self.oneday = timetools.Period(&#39;1d&#39;)
</span><span class="noop">
</span><span class="hit">    def test_01_right(self):
</span><span class="hit">        timetools.Timegrid(self.year97, self.year98, self.oneday)
</span><span class="hit">    def test_02_wrong(self):
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            timetools.Timegrid(self.year97, self.year97, self.oneday)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            timetools.Timegrid(self.year98, self.year97, self.oneday)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            timetools.Timegrid(self.year97, self.year98,
</span><span class="noop">                               timetools.Period(&#39;360d&#39;))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test14TimegridIterable(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.year97 = timetools.Date(&#39;01.11.1996&#39;)
</span><span class="hit">        self.year98 = timetools.Date(&#39;01.11.1997&#39;)
</span><span class="hit">        self.oneday = timetools.Period(&#39;1d&#39;)
</span><span class="hit">        self.timegrid = timetools.Timegrid(self.year97, self.year98,
</span><span class="noop">                                           self.oneday)
</span><span class="noop">
</span><span class="hit">    def test_01_indexing_with_integers(self):
</span><span class="hit">        self.assertEqual(self.timegrid[0], self.year97)
</span><span class="hit">        self.assertEqual(self.timegrid[365], self.year98)
</span><span class="hit">        self.assertEqual(self.timegrid[1], self.year97+self.oneday)
</span><span class="hit">        self.assertEqual(self.timegrid[-1], self.year97-self.oneday)
</span><span class="hit">        self.assertEqual(self.timegrid[366], self.year98+self.oneday)
</span><span class="hit">        self.assertEqual(self.timegrid[364], self.year98-self.oneday)
</span><span class="noop">
</span><span class="hit">    def test_02_indexing_with_dates(self):
</span><span class="hit">        self.assertEqual(self.timegrid[self.year97], 0)
</span><span class="hit">        self.assertEqual(self.timegrid[self.year98], 365)
</span><span class="hit">        self.assertEqual(self.timegrid[self.year97+self.oneday], 1)
</span><span class="hit">        self.assertEqual(self.timegrid[self.year97-self.oneday], -1)
</span><span class="hit">        self.assertEqual(self.timegrid[self.year98+self.oneday], 366)
</span><span class="hit">        self.assertEqual(self.timegrid[self.year98-self.oneday], 364)
</span><span class="noop">
</span><span class="hit">    def test_03_indexing_errors(self):
</span><span class="hit">        with self.assertRaises(TypeError):
</span><span class="hit">            self.timegrid[0.]
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.timegrid[self.year97 + &#39;1m&#39;]
</span><span class="noop">
</span><span class="hit">    def test_04_iteration(self):
</span><span class="hit">        self.assertEqual(list(self.timegrid)[1], self.year97+self.oneday)
</span><span class="noop">
</span><span class="hit">    def test_05_len(self):
</span><span class="hit">        self.assertEqual(len(self.timegrid), 365)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test15TimegridComparisons(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.year97 = timetools.Date(&#39;01.11.1996&#39;)
</span><span class="hit">        self.year98 = timetools.Date(&#39;01.11.1997&#39;)
</span><span class="hit">        self.oneday = timetools.Period(&#39;1d&#39;)
</span><span class="hit">        self.onehour = timetools.Period(&#39;1h&#39;)
</span><span class="hit">        self.timegrid = timetools.Timegrid(self.year97, self.year98,
</span><span class="noop">                                           self.oneday)
</span><span class="noop">
</span><span class="hit">    def test_01_eq(self):
</span><span class="hit">        timegridtest = self.timegrid.copy()
</span><span class="hit">        self.assertTrue(timegridtest == self.timegrid)
</span><span class="hit">        timegridtest.firstdate.year = 1995
</span><span class="hit">        self.assertFalse(timegridtest == self.timegrid)
</span><span class="hit">        timegridtest = self.timegrid.copy()
</span><span class="hit">        timegridtest.lastdate.year = 1998
</span><span class="hit">        self.assertFalse(timegridtest == self.timegrid)
</span><span class="hit">        timegridtest = self.timegrid.copy()
</span><span class="hit">        timegridtest.stepsize = self.onehour
</span><span class="hit">        self.assertFalse(timegridtest == self.timegrid)
</span><span class="noop">
</span><span class="hit">    def test_02_ne(self):
</span><span class="hit">        timegridtest = self.timegrid.copy()
</span><span class="hit">        self.assertFalse(timegridtest != self.timegrid)
</span><span class="hit">        timegridtest.firstdate.year = 1995
</span><span class="hit">        self.assertTrue(timegridtest != self.timegrid)
</span><span class="hit">        timegridtest = self.timegrid.copy()
</span><span class="hit">        timegridtest.lastdate.year = 1998
</span><span class="hit">        self.assertTrue(timegridtest != self.timegrid)
</span><span class="hit">        timegridtest = self.timegrid.copy()
</span><span class="hit">        timegridtest.stepsize = self.onehour
</span><span class="hit">        self.assertTrue(timegridtest != self.timegrid)
</span><span class="noop">
</span><span class="hit">    def test_03_date_in(self):
</span><span class="hit">        self.assertTrue(self.year97 in self.timegrid)
</span><span class="hit">        self.assertTrue(self.year98 in self.timegrid)
</span><span class="hit">        self.assertTrue(self.year97+&#39;1d&#39; in self.timegrid)
</span><span class="hit">        self.assertFalse(self.year97-&#39;1d&#39; in self.timegrid)
</span><span class="hit">        self.assertTrue(self.year98-&#39;1d&#39; in self.timegrid)
</span><span class="hit">        self.assertFalse(self.year98+&#39;1d&#39; in self.timegrid)
</span><span class="hit">        self.assertFalse(self.year97+&#39;12h&#39; in self.timegrid)
</span><span class="hit">        self.assertFalse(self.year97-&#39;12h&#39; in self.timegrid)
</span><span class="hit">        self.assertFalse(self.year98-&#39;12h&#39; in self.timegrid)
</span><span class="hit">        self.assertFalse(self.year98+&#39;12h&#39; in self.timegrid)
</span><span class="noop">
</span><span class="hit">    def test_04_timegrid_in(self):
</span><span class="hit">        timegridtest = self.timegrid.copy()
</span><span class="hit">        self.assertTrue(timegridtest in self.timegrid)
</span><span class="hit">        self.assertTrue(self.timegrid in timegridtest)
</span><span class="hit">        timegridtest.firstdate -= &#39;1d&#39;
</span><span class="hit">        self.assertFalse(timegridtest in self.timegrid)
</span><span class="hit">        self.assertTrue(self.timegrid in timegridtest)
</span><span class="hit">        timegridtest = self.timegrid.copy()
</span><span class="hit">        timegridtest.lastdate += &#39;1d&#39;
</span><span class="hit">        self.assertFalse(timegridtest in self.timegrid)
</span><span class="hit">        self.assertTrue(self.timegrid in timegridtest)
</span><span class="hit">        timegridtest = self.timegrid.copy()
</span><span class="hit">        timegridtest.firstdate -= &#39;1d&#39;
</span><span class="hit">        timegridtest.lastdate += &#39;1d&#39;
</span><span class="hit">        self.assertFalse(timegridtest in self.timegrid)
</span><span class="hit">        self.assertTrue(self.timegrid in timegridtest)
</span><span class="hit">        timegridtest = self.timegrid.copy()
</span><span class="hit">        timegridtest.firstdate += &#39;12h&#39;
</span><span class="hit">        timegridtest.lastdate -= &#39;12d&#39;
</span><span class="hit">        self.assertFalse(timegridtest in self.timegrid)
</span><span class="hit">        self.assertFalse(self.timegrid in timegridtest)
</span><span class="hit">        timegridtest = self.timegrid.copy()
</span><span class="hit">        timegridtest.stepsize /= 24
</span><span class="hit">        self.assertFalse(timegridtest in self.timegrid)
</span><span class="hit">        self.assertFalse(self.timegrid in timegridtest)</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="unittests_03_filetools.py">unittests_03_filetools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="noop">#from __future__ import division, print_function
</span><span class="noop">#import os
</span><span class="noop">#import unittest
</span><span class="noop">## ...from HydPy
</span><span class="noop">#from hydpy.core import filetools
</span><span class="noop">#from hydpy import pub
</span><span class="noop">#
</span><span class="noop">#PROJECTNAME = &#39;projectnamemock&#39;
</span><span class="noop">#
</span><span class="noop">#class NetworkFileMock(filetools.NetworkFile):
</span><span class="noop">#    def checkpath(self):
</span><span class="noop">#        pass
</span><span class="noop">#
</span><span class="noop">#class Test02NetwortFile(unittest.TestCase):
</span><span class="noop">#
</span><span class="noop">#    def setUp(self):
</span><span class="noop">#        pub.projectname = PROJECTNAME
</span><span class="noop">#        self.testdirectory = os.path.abspath(&#39;controlfiles&#39;)
</span><span class="noop">#
</span><span class="noop">#    def test_01_getdirectory(self):
</span><span class="noop">#        networkfile = NetworkFileMock()
</span><span class="noop">#        self.assertEqual(networkfile.directory, self.testdirectory)
</span><span class="noop">#
</span><span class="noop">#    def test_02_getfilename(self):
</span><span class="noop">#        networkfile = NetworkFileMock()
</span><span class="noop">#        self.assertEqual(networkfile.filename, PROJECTNAME+&#39;_network.py&#39;)
</span><span class="noop">#        networkfile._filename = &#39;testname&#39;
</span><span class="noop">#        self.assertEqual(networkfile.filename, &#39;testname.py&#39;)
</span><span class="noop">#
</span><span class="noop">#    def test_03_setwrongfilename(self):
</span><span class="noop">#        with self.assertRaises(IOError):
</span><span class="noop">#             filetools.NetworkFile(&#39;testname&#39;)
</span><span class="noop">#
</span><span class="noop">#    def test_04_setcorrectfilename(self):
</span><span class="noop">#        networkfile = NetworkFileMock(&#39;testname&#39;)
</span><span class="noop">#        self.assertEqual(networkfile.filename, &#39;testname.py&#39;)
</span><span class="noop">#        networkfile = NetworkFileMock(&#39;testname.py&#39;)
</span><span class="noop">#        self.assertEqual(networkfile.filename, &#39;testname.py&#39;)
</span><span class="noop">#        networkfile.filename = None
</span><span class="noop">#        self.assertEqual(networkfile.filename, PROJECTNAME+&#39;_network.py&#39;)
</span><span class="noop">#        networkfile = NetworkFileMock()
</span><span class="noop">#        networkfile.filename = &#39;testname&#39;
</span><span class="noop">#        self.assertEqual(networkfile.filename, &#39;testname.py&#39;)
</span><span class="noop">#
</span><span class="noop">#    def test_5_savefile(self):
</span><span class="noop">#        pass
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="unittests_04_devicetools.py">unittests_04_devicetools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import sys
</span><span class="hit">import unittest
</span><span class="noop"># ...from HydPy
</span><span class="hit">sys.path.insert(0, &#39;..\\..\\..\\HydPy&#39;)
</span><span class="hit">from hydpy.core.devicetools import *
</span><span class="hit">from hydpy.core.connectiontools import *
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test01NodeCreation(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        Node.clearregistry()
</span><span class="noop">
</span><span class="hit">    def test_01_fromstring(self):
</span><span class="hit">        test1a = Node(&#39;test1&#39;)
</span><span class="hit">        self.assertIsInstance(test1a, Node)
</span><span class="hit">        self.assertEqual(test1a.name, &#39;test1&#39;)
</span><span class="hit">        test1b = Node(&#39;test1&#39;)
</span><span class="hit">        self.assertIs(test1a, test1b)
</span><span class="hit">        test2 = Node(&#39;test2&#39;)
</span><span class="hit">        self.assertIsNot(test1a, test2)
</span><span class="hit">    def test_02_fromnode(self):
</span><span class="hit">        test1 = Node(&#39;test&#39;)
</span><span class="hit">        test2 = Node(test1)
</span><span class="hit">        self.assertIsInstance(test2, Node)
</span><span class="hit">        self.assertIs(test1, test2)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            Node([test1, test2])
</span><span class="hit">    def test_03_fromwronginput(self):
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            test = Node([&#39;test&#39;])
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            test = Node(5)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            test = Node({&#39;test&#39;: &#39;test&#39;})
</span><span class="hit">    def test_04_attributes(self):
</span><span class="hit">        test1 = Node(&#39;test1&#39;)
</span><span class="hit">        self.assertIsInstance(test1.entries, Connections)
</span><span class="hit">        self.assertIsInstance(test1.exits, Connections)
</span><span class="hit">        self.assertEqual(test1.variable, &#39;Q&#39;)
</span><span class="hit">        test2 = Node(&#39;test2&#39;, &#39;T&#39;)
</span><span class="hit">        self.assertIsInstance(test2.entries, Connections)
</span><span class="hit">        self.assertIsInstance(test2.exits, Connections)
</span><span class="hit">        self.assertEqual(test2.variable, &#39;T&#39;)
</span><span class="hit">    def test_03_wrongredefinition(self):
</span><span class="hit">        test = Node(&#39;test&#39;)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            Node(&#39;test&#39;, &#39;T&#39;)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test02ElementCreation(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        Element.clearregistry()
</span><span class="noop">
</span><span class="hit">    def test_01_fromstring(self):
</span><span class="hit">        test1a = Element(&#39;test1&#39;)
</span><span class="hit">        self.assertIsInstance(test1a, Element)
</span><span class="hit">        self.assertEqual(test1a.name, &#39;test1&#39;)
</span><span class="hit">        test1b = Element(&#39;test1&#39;)
</span><span class="hit">        self.assertIs(test1a, test1b)
</span><span class="hit">        test2 = Element(&#39;test2&#39;)
</span><span class="hit">        self.assertIsNot(test1a, test2)
</span><span class="hit">    def test_02_fromelement(self):
</span><span class="hit">        test1 = Element(&#39;test&#39;)
</span><span class="hit">        test2 = Element(test1)
</span><span class="hit">        self.assertIsInstance(test2, Element)
</span><span class="hit">        self.assertIs(test1, test2)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            Element([test1, test2])
</span><span class="hit">    def test_03_fromwronginput(self):
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            test = Element([&#39;test&#39;])
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            test = Element(5)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            test = Element({&#39;test&#39;: &#39;test&#39;})
</span><span class="hit">    def test_04_attributes(self):
</span><span class="hit">        test = Element(&#39;test&#39;)
</span><span class="hit">        self.assertIsInstance(test.inlets, Connections)
</span><span class="hit">        self.assertIsInstance(test.outlets, Connections)
</span><span class="hit">        self.assertIsInstance(test.receivers, Connections)
</span><span class="hit">        self.assertIsInstance(test.senders, Connections)
</span><span class="hit">        self.assertIsNone(test.model)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test03ElementInitialization(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.n1Q = Node(&#39;n1Q&#39;, &#39;Q&#39;)
</span><span class="hit">        self.n2Q = Node(&#39;n2Q&#39;, &#39;Q&#39;)
</span><span class="hit">        self.n3W = Node(&#39;n3W&#39;, &#39;W&#39;)
</span><span class="hit">        self.n4T = Node(&#39;n4T&#39;, &#39;T&#39;)
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        Element.clearregistry()
</span><span class="noop">
</span><span class="hit">    def test_01_inlet(self):
</span><span class="hit">        e = Element(&#39;e&#39;, inlets=self.n1Q)
</span><span class="hit">        self.assertIsInstance(e, Element)
</span><span class="hit">        self.assertIs(e.inlets.n1Q, self.n1Q)
</span><span class="hit">        self.assertIsInstance(self.n1Q.exits.e, Element)
</span><span class="hit">        self.assertIs(self.n1Q.exits.e, e)
</span><span class="hit">        self.assertIs(e.inlets.n1Q, self.n1Q)
</span><span class="hit">        e = Element(&#39;e&#39;, inlets=self.n1Q)
</span><span class="hit">        self.assertIs(e.inlets.n1Q, self.n1Q)
</span><span class="hit">        e = Element(&#39;e&#39;, inlets=self.n4T)
</span><span class="hit">        self.assertIs(e.inlets.n1Q, self.n1Q)
</span><span class="hit">        self.assertIs(e.inlets.n4T, self.n4T)
</span><span class="hit">        e = Element(&#39;e&#39;, inlets=self.n3W)
</span><span class="hit">        self.assertIs(e.inlets.n3W, self.n3W)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            e = Element(&#39;e&#39;, outlets=self.n2Q)
</span><span class="hit">            e = Element(&#39;e&#39;, inlets=self.n2Q)
</span><span class="noop">
</span><span class="hit">    def test_02_outlet(self):
</span><span class="hit">        e = Element(&#39;e&#39;, outlets=self.n1Q)
</span><span class="hit">        self.assertIsInstance(e, Element)
</span><span class="hit">        self.assertIs(e.outlets.n1Q, self.n1Q)
</span><span class="hit">        self.assertIsInstance(self.n1Q.entries.e, Element)
</span><span class="hit">        self.assertIs(self.n1Q.entries.e, e)
</span><span class="hit">        e = Element(&#39;e&#39;, outlets=self.n1Q)
</span><span class="hit">        self.assertIs(e.outlets.n1Q, self.n1Q)
</span><span class="hit">        e = Element(&#39;e&#39;, outlets=self.n4T)
</span><span class="hit">        self.assertIs(e.outlets.n1Q, self.n1Q)
</span><span class="hit">        self.assertIs(e.outlets.n4T, self.n4T)
</span><span class="hit">        e = Element(&#39;e&#39;, outlets=self.n3W)
</span><span class="hit">        self.assertIs(e.outlets.n3W, self.n3W)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            e = Element(&#39;e&#39;, inlets=self.n2Q)
</span><span class="hit">            e = Element(&#39;e&#39;, outlets=self.n2Q)
</span><span class="noop">
</span><span class="hit">    def test_03_receiver(self):
</span><span class="hit">        e = Element(&#39;e&#39;, receivers=self.n1Q)
</span><span class="hit">        self.assertIsInstance(e, Element)
</span><span class="hit">        self.assertIs(e.receivers.n1Q, self.n1Q)
</span><span class="hit">        self.assertIsInstance(self.n1Q.exits.e, Element)
</span><span class="hit">        self.assertIs(self.n1Q.exits.e, e)
</span><span class="hit">        e = Element(&#39;e&#39;, receivers=self.n1Q)
</span><span class="hit">        self.assertIs(e.receivers.n1Q, self.n1Q)
</span><span class="hit">        e = Element(&#39;e&#39;, receivers=self.n4T)
</span><span class="hit">        self.assertIs(e.receivers.n1Q, self.n1Q)
</span><span class="hit">        self.assertIs(e.receivers.n4T, self.n4T)
</span><span class="hit">        e = Element(&#39;e&#39;, receivers=self.n3W)
</span><span class="hit">        self.assertIs(e.receivers.n3W, self.n3W)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            e = Element(&#39;e&#39;, senders=self.n2Q)
</span><span class="hit">            e = Element(&#39;e&#39;, receivers=self.n2Q)
</span><span class="noop">
</span><span class="hit">    def test_04_sender(self):
</span><span class="hit">        e = Element(&#39;e&#39;, senders=self.n1Q)
</span><span class="hit">        self.assertIsInstance(e, Element)
</span><span class="hit">        self.assertIs(e.senders.n1Q, self.n1Q)
</span><span class="hit">        self.assertIsInstance(self.n1Q.entries.e, Element)
</span><span class="hit">        self.assertIs(self.n1Q.entries.e, e)
</span><span class="hit">        e = Element(&#39;e&#39;, senders=self.n1Q)
</span><span class="hit">        self.assertIs(e.senders.n1Q, self.n1Q)
</span><span class="hit">        e = Element(&#39;e&#39;, senders=self.n4T)
</span><span class="hit">        self.assertIs(e.senders.n1Q, self.n1Q)
</span><span class="hit">        self.assertIs(e.senders.n4T, self.n4T)
</span><span class="hit">        e = Element(&#39;e&#39;, senders=self.n3W)
</span><span class="hit">        self.assertIs(e.senders.n3W, self.n3W)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            e = Element(&#39;e&#39;, receivers=self.n2Q)
</span><span class="hit">            e = Element(&#39;e&#39;, senders=self.n2Q)
</span><span class="noop">
</span><span class="hit">    def test_05_inletandoutlet(self):
</span><span class="hit">        e1 = Element(&#39;e1&#39;, inlets=self.n1Q, outlets=self.n2Q)
</span><span class="hit">        self.assertIs(e1.inlets.n1Q, self.n1Q)
</span><span class="hit">        self.assertIs(e1.outlets.n2Q, self.n2Q)
</span><span class="hit">        e2 = Element(&#39;e2&#39;, inlets=self.n1Q)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            Element(&#39;e2&#39;, outlets=self.n1Q)
</span><span class="hit">        e3 = Element(&#39;e3&#39;, outlets=self.n1Q)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            Element(&#39;e3&#39;, inlets=self.n1Q)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            Element(&#39;e4&#39;, inlets=self.n1Q, outlets=self.n1Q)
</span><span class="noop">
</span><span class="hit">    def test_06_receiverandsender(self):
</span><span class="hit">        e1 = Element(&#39;e1&#39;, receivers=self.n1Q, senders=self.n2Q)
</span><span class="hit">        self.assertIs(e1.receivers.n1Q, self.n1Q)
</span><span class="hit">        self.assertIs(e1.senders.n2Q, self.n2Q)
</span><span class="hit">        e2 = Element(&#39;e2&#39;, receivers=self.n1Q)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            Element(&#39;e2&#39;, senders=self.n1Q)
</span><span class="hit">        e3 = Element(&#39;e3&#39;, senders=self.n1Q)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            Element(&#39;e3&#39;, receivers=self.n1Q)
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            Element(&#39;e4&#39;, receivers=self.n1Q, senders=self.n1Q)
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">#class Test04NodesCreation(unittest.TestCase):
</span><span class="noop">#
</span><span class="noop">#    def setUp(self):
</span><span class="noop">#        asdf
</span><span class="noop">
</span><span class="hit">class Test05ElementsCreation(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.element1 = Element(&#39;element1&#39;)
</span><span class="hit">        self.element2 = Element(&#39;element2&#39;)
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        Element.clearregistry()
</span><span class="noop">
</span><span class="hit">    def test_00_fromnone(self):
</span><span class="hit">        test = Elements(None)
</span><span class="hit">        self.assertIsInstance(test, Elements)
</span><span class="noop">
</span><span class="hit">    def test_01_fromelements(self):
</span><span class="hit">        test = Elements(self.element1)
</span><span class="hit">        self.assertIsInstance(test, Elements)
</span><span class="hit">        self.assertIsInstance(test.element1, Element)
</span><span class="hit">        self.assertIs(test.element1, self.element1)
</span><span class="hit">        test = Elements(self.element1, self.element2)
</span><span class="hit">        self.assertIsInstance(test, Elements)
</span><span class="hit">        self.assertIsInstance(test.element1, Element)
</span><span class="hit">        self.assertIs(test.element1, self.element1)
</span><span class="hit">        self.assertIsInstance(test.element2, Element)
</span><span class="hit">        self.assertIs(test.element2, self.element2)
</span><span class="noop">
</span><span class="hit">    def test_02_fromstrings(self):
</span><span class="hit">        test = Elements(&#39;element1&#39;)
</span><span class="hit">        self.assertIsInstance(test, Elements)
</span><span class="hit">        self.assertIsInstance(test.element1, Element)
</span><span class="hit">        self.assertIs(test.element1, self.element1)
</span><span class="hit">        test = Elements(&#39;element1&#39;, &#39;element2&#39;)
</span><span class="hit">        self.assertIsInstance(test, Elements)
</span><span class="hit">        self.assertIsInstance(test.element1, Element)
</span><span class="hit">        self.assertIs(test.element1, self.element1)
</span><span class="hit">        self.assertIsInstance(test.element2, Element)
</span><span class="hit">        self.assertIs(test.element2, self.element2)
</span><span class="noop">
</span><span class="hit">    def test_03_fromelements(self):
</span><span class="hit">        test1 = Elements(&#39;element1&#39;)
</span><span class="hit">        test2 = Elements(test1)
</span><span class="hit">        self.assertIsInstance(test2, Elements)
</span><span class="noop">
</span><span class="hit">    def test_04_fromemptycontainer(self):
</span><span class="hit">        test = Elements([])
</span><span class="hit">        self.assertIsInstance(test, Elements)
</span><span class="noop">
</span><span class="hit">    def test_05_fromcontaineredelements1(self):
</span><span class="hit">        test = Elements([self.element1])
</span><span class="hit">        self.assertIsInstance(test, Elements)
</span><span class="hit">        self.assertIsInstance(test.element1, Element)
</span><span class="hit">        self.assertIs(test.element1, self.element1)
</span><span class="hit">        test = Elements([self.element1, self.element2])
</span><span class="hit">        self.assertIsInstance(test, Elements)
</span><span class="hit">        self.assertIsInstance(test.element1, Element)
</span><span class="hit">        self.assertIsInstance(test.element2, Element)
</span><span class="hit">        self.assertIs(test.element1, self.element1)
</span><span class="hit">        self.assertIs(test.element2, self.element2)
</span><span class="noop">
</span><span class="hit">    def test_06_fromcontaineredelements1(self):
</span><span class="hit">        test = Elements(Elements([self.element1]))
</span><span class="hit">        self.assertIsInstance(test, Elements)
</span><span class="hit">        self.assertIsInstance(test.element1, Element)
</span><span class="hit">        self.assertIs(test.element1, self.element1)
</span><span class="hit">        test = Elements(Elements([self.element1, self.element2]))
</span><span class="hit">        self.assertIsInstance(test, Elements)
</span><span class="hit">        self.assertIsInstance(test.element1, Element)
</span><span class="hit">        self.assertIsInstance(test.element2, Element)
</span><span class="hit">        self.assertIs(test.element1, self.element1)
</span><span class="hit">        self.assertIs(test.element2, self.element2)
</span><span class="noop">
</span><span class="hit">    def test_07_fromcontaineredstrings(self):
</span><span class="hit">        test = Elements([&#39;element1&#39;])
</span><span class="hit">        self.assertIsInstance(test, Elements)
</span><span class="hit">        self.assertIsInstance(test.element1, Element)
</span><span class="hit">        self.assertIs(test.element1, self.element1)
</span><span class="hit">        test = Elements([&#39;element1&#39;, &#39;element2&#39;])
</span><span class="hit">        self.assertIsInstance(test, Elements)
</span><span class="hit">        self.assertIsInstance(test.element1, Element)
</span><span class="hit">        self.assertIsInstance(test.element2, Element)
</span><span class="hit">        self.assertIs(test.element1, self.element1)
</span><span class="hit">        self.assertIs(test.element2, self.element2)
</span><span class="noop">
</span><span class="hit">    def test_07_fromwrongtype(self):
</span><span class="hit">        with self.assertRaises(TypeError):
</span><span class="hit">            Elements(1.)
</span><span class="noop">
</span><span class="hit">class Test06ElementsArithmetic(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.element1 = Element(&#39;element1&#39;)
</span><span class="hit">        self.element2 = Element(&#39;element2&#39;)
</span><span class="hit">        self.element3 = Element(&#39;element3&#39;)
</span><span class="hit">        self.element4 = Element(&#39;element3&#39;)
</span><span class="hit">        self.elements12 = Elements(self.element1, self.element2)
</span><span class="hit">        self.elements34 = Elements(self.element3, self.element4)
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        Element.clearregistry()
</span><span class="noop">
</span><span class="hit">    def test_01_iadd_element(self):
</span><span class="hit">        self.elements12 += self.element3
</span><span class="hit">        self.assertIsInstance(self.elements12, Elements)
</span><span class="hit">        self.assertIs(self.elements12.element1, self.element1)
</span><span class="hit">        self.assertIs(self.elements12.element3, self.element3)
</span><span class="hit">    def test_02_iadd_elements(self):
</span><span class="hit">        self.elements12 += self.elements34
</span><span class="hit">        self.assertIsInstance(self.elements12, Elements)
</span><span class="hit">        self.assertIs(self.elements12.element1, self.element1)
</span><span class="hit">        self.assertIs(self.elements12.element3, self.element3)
</span><span class="hit">    def test_03a_iadd_emptylist(self):
</span><span class="hit">        elements12 = self.elements12.copy()
</span><span class="hit">        self.elements12 += []
</span><span class="hit">        self.assertIsInstance(self.elements12, Elements)
</span><span class="hit">        self.assertEqual(self.elements12, elements12)
</span><span class="hit">    def test_04a_iadd_elementlist(self):
</span><span class="hit">        self.elements12 += [self.element3]
</span><span class="hit">        self.assertIsInstance(self.elements12, Elements)
</span><span class="hit">        self.assertIs(self.elements12.element1, self.element1)
</span><span class="hit">        self.assertIs(self.elements12.element3, self.element3)
</span><span class="hit">    def test_04b_iadd_elementlist(self):
</span><span class="hit">        self.elements12 += [self.element3, self.element4]
</span><span class="hit">        self.assertIsInstance(self.elements12, Elements)
</span><span class="hit">        self.assertIs(self.elements12.element1, self.element1)
</span><span class="hit">        self.assertIs(self.elements12.element3, self.element3)
</span><span class="hit">    def test_05a_iadd_stringlist(self):
</span><span class="hit">        self.elements12 += [&#39;element3&#39;]
</span><span class="hit">        self.assertIsInstance(self.elements12, Elements)
</span><span class="hit">        self.assertIs(self.elements12.element1, self.element1)
</span><span class="hit">        self.assertIs(self.elements12.element3, self.element3)
</span><span class="hit">    def test_05b_iadd_stringlist(self):
</span><span class="hit">        self.elements12 += [&#39;element3&#39;, &#39;element4&#39;]
</span><span class="hit">        self.assertIsInstance(self.elements12, Elements)
</span><span class="hit">        self.assertIs(self.elements12.element1, self.element1)
</span><span class="hit">        self.assertIs(self.elements12.element3, self.element3)
</span><span class="noop">
</span><span class="hit">    def test_06_isub_element(self):
</span><span class="hit">        self.elements12 -= self.element2
</span><span class="hit">        self.assertIsInstance(self.elements12, Elements)
</span><span class="hit">        self.assertIs(self.elements12.element1, self.element1)
</span><span class="hit">        with self.assertRaises(AttributeError):
</span><span class="hit">            self.elements12.element2
</span><span class="noop">
</span><span class="hit">    def test_07_add_element(self):
</span><span class="hit">        elements12 = self.elements12.copy()
</span><span class="hit">        elements123 = self.elements12 + self.element3
</span><span class="hit">        self.assertEqual(self.elements12, elements12)
</span><span class="hit">        self.assertIsInstance(elements123, Elements)
</span><span class="hit">        self.assertIs(elements123.element1, self.element1)
</span><span class="hit">        self.assertIs(elements123.element3, self.element3)
</span><span class="noop">
</span><span class="hit">    def test_08_sub_element(self):
</span><span class="hit">        elements12 = self.elements12.copy()
</span><span class="hit">        elements1 = self.elements12 - self.element2
</span><span class="hit">        self.assertEqual(self.elements12, elements12)
</span><span class="hit">        self.assertIsInstance(elements1, Elements)
</span><span class="hit">        self.assertIs(elements1.element1, self.element1)
</span><span class="hit">        with self.assertRaises(AttributeError):
</span><span class="hit">            self.elements1.element2
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test07ElementsComparisons(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        Element.clearregistry()
</span><span class="noop">
</span><span class="hit">    def test_01_bool(self):
</span><span class="hit">        self.assertFalse(Elements())
</span><span class="hit">        self.assertTrue(Elements(&#39;a&#39;))
</span><span class="hit">        self.assertTrue(Elements(&#39;a&#39;, &#39;b&#39;))</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="unittests_05_connectiontools.py">unittests_05_connectiontools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import unittest
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core.devicetools import *
</span><span class="hit">from hydpy.core.connectiontools import *
</span><span class="noop">
</span><span class="hit">class Test01Connections(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.cons = Connections(None)
</span><span class="hit">        setattr(self.cons, &#39;test1&#39;, 1)
</span><span class="hit">        setattr(self.cons, &#39;test2&#39;, 2)
</span><span class="noop">
</span><span class="hit">    def test_01_properties(self):
</span><span class="hit">        self.assertListEqual(sorted(self.cons.names), [&#39;test1&#39;, &#39;test2&#39;])
</span><span class="hit">        self.assertListEqual(sorted(self.cons.slaves), [1, 2])
</span><span class="hit">    def test_02_contains(self):
</span><span class="hit">        self.assertTrue(&#39;test1&#39; in self.cons)
</span><span class="hit">        self.assertTrue(&#39;test2&#39; in self.cons)
</span><span class="hit">        self.assertTrue(1 in self.cons)
</span><span class="hit">        self.assertTrue(2 in self.cons)
</span><span class="hit">    def test_03_iterable(self):
</span><span class="hit">        names, cons = [], []
</span><span class="hit">        for (name, con) in self.cons:
</span><span class="hit">            names.append(name)
</span><span class="hit">            cons.append(con)
</span><span class="hit">        self.assertListEqual(sorted(names), [&#39;test1&#39;, &#39;test2&#39;])
</span><span class="hit">        self.assertListEqual(sorted(cons), [1, 2])
</span><span class="noop">
</span><span class="hit">class Test01Self2Node(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        Element.clearregistry()
</span><span class="noop">
</span><span class="hit">    def test_01_iadd(self):
</span><span class="hit">        test = Connections(None)
</span><span class="hit">        n1 = Node(&#39;n1&#39;, &#39;Q&#39;)
</span><span class="hit">        test += n1
</span><span class="hit">        self.assertIsInstance(test, Connections)
</span><span class="hit">        self.assertIsInstance(test.n1, Node)
</span><span class="hit">        self.assertIs(test.n1, n1)
</span><span class="hit">        test += n1
</span><span class="hit">        self.assertIsInstance(test, Connections)
</span><span class="hit">        self.assertIsInstance(test.n1, Node)
</span><span class="hit">        self.assertIs(test.n1, n1)
</span><span class="hit">        n2 = Node(&#39;n2&#39;, &#39;T&#39;)
</span><span class="hit">        test += n2
</span><span class="hit">        self.assertIs(test.n1, n1)
</span><span class="hit">        self.assertIs(test.n2, n2)
</span><span class="noop">
</span><span class="hit">    def test_02_variables(self):
</span><span class="hit">        test = Connections(None)
</span><span class="hit">        self.assertListEqual(test.variables, [])
</span><span class="hit">        n1 = Node(&#39;n1&#39;, &#39;Q&#39;)
</span><span class="hit">        test += n1
</span><span class="hit">        self.assertListEqual(test.variables, [&#39;Q&#39;])
</span><span class="hit">        n2 = Node(&#39;n2&#39;, &#39;T&#39;)
</span><span class="hit">        test += n2
</span><span class="hit">        self.assertListEqual(sorted(test.variables), [&#39;Q&#39;, &#39;T&#39;])
</span><span class="hit">        with self.assertRaises(AttributeError):
</span><span class="hit">            test.X</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="unittests_06_selectiontools.py">unittests_06_selectiontools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import unittest
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core.devicetools import *
</span><span class="hit">from hydpy.core.selectiontools import *
</span><span class="noop">
</span><span class="hit">class Test01SelectionInitialization(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        Node.clearregistry()
</span><span class="hit">        Element.clearregistry()
</span><span class="noop">
</span><span class="hit">    def test_01_empty(self):
</span><span class="hit">        test = Selection(&#39;test&#39;)
</span><span class="hit">        self.assertIsInstance(test, Selection)
</span><span class="hit">        self.assertIsInstance(test.nodes, Nodes)
</span><span class="hit">        self.assertIsInstance(test.elements, Elements)
</span><span class="hit">        self.assertFalse(bool(test))
</span><span class="hit">    def test_02_nonempty(self):
</span><span class="hit">        test = Selection(&#39;test&#39;, nodes=&#39;a&#39;, elements=(&#39;b&#39;, &#39;c&#39;))
</span><span class="hit">        self.assertIsInstance(test, Selection)
</span><span class="hit">        self.assertIsInstance(test.nodes, Nodes)
</span><span class="hit">        self.assertIsInstance(test.elements, Elements)
</span><span class="hit">        self.assertEqual(test.nodes.a.name, &#39;a&#39;)
</span><span class="hit">        self.assertEqual(test.elements.b.name, &#39;b&#39;)
</span><span class="hit">        self.assertEqual(test.elements.c.name, &#39;c&#39;)
</span><span class="hit">        self.assertTrue(bool(test))
</span><span class="hit">    def test_03_copy(self):
</span><span class="hit">        test1 = Selection(&#39;test1&#39;, nodes=&#39;a&#39;, elements=(&#39;b&#39;, &#39;c&#39;))
</span><span class="hit">        test2 = test1.copy(&#39;test2&#39;)
</span><span class="hit">        self.assertIsInstance(test2, Selection)
</span><span class="hit">        self.assertEqual(test2.name, &#39;test2&#39;)
</span><span class="hit">        self.assertIsNot(test1, test2)
</span><span class="hit">        self.assertEqual(test2.nodes, test1.nodes)
</span><span class="hit">        self.assertEqual(test2.elements, test1.elements)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test02SelectionSelect(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="noop">        # e1 + e2 -&gt; n_Q1 -&gt; e3 -&gt; n_Q2 -&gt; e4 + (e7 -&gt; n_Q4 -&gt; e6)-&gt; n_Q3
</span><span class="noop">        # e1 + e2 -&gt; n_T1 -&gt; e3 -&gt; n_T2 -&gt; e5 -&gt; n_T3
</span><span class="hit">        self.n_Q1 = Node(&#39;n_Q1&#39;, &#39;Q&#39;)
</span><span class="hit">        self.n_T1 = Node(&#39;n_T1&#39;, &#39;T&#39;)
</span><span class="hit">        self.e1 = Element(&#39;e1&#39;, outlets=&#39;n_Q1&#39;)
</span><span class="hit">        self.e1 = Element(&#39;e1&#39;, outlets=&#39;n_T1&#39;)
</span><span class="hit">        self.e2 = Element(&#39;e2&#39;, outlets=&#39;n_Q1&#39;)
</span><span class="hit">        self.e2 = Element(&#39;e2&#39;, outlets=&#39;n_T1&#39;)
</span><span class="hit">        self.n_Q2 = Node(&#39;n_Q2&#39;, &#39;Q&#39;)
</span><span class="hit">        self.n_T2 = Node(&#39;n_T2&#39;, &#39;T&#39;)
</span><span class="hit">        self.e3 = Element(&#39;e3&#39;, inlets=&#39;n_Q1&#39;, outlets=&#39;n_Q2&#39;)
</span><span class="hit">        self.e3 = Element(&#39;e3&#39;, inlets=&#39;n_T1&#39;, outlets=&#39;n_T2&#39;)
</span><span class="hit">        self.n_Q3 = Node(&#39;n_Q3&#39;, &#39;Q&#39;)
</span><span class="hit">        self.e4 = Element(&#39;e4&#39;, inlets=&#39;n_Q2&#39;, outlets=&#39;n_Q3&#39;)
</span><span class="hit">        self.n_T3 = Node(&#39;n_T3&#39;, &#39;T&#39;)
</span><span class="hit">        self.e5 = Element(&#39;e5&#39;, inlets=&#39;n_T2&#39;, outlets=&#39;n_T3&#39;)
</span><span class="hit">        self.n_Q4 = Node(&#39;n_Q4&#39;, &#39;Q&#39;)
</span><span class="hit">        self.e6 = Element(&#39;e6&#39;, inlets=&#39;n_Q4&#39;, outlets=&#39;n_Q3&#39;)
</span><span class="hit">        self.e7 = Element(&#39;e7&#39;, outlets=&#39;n_Q4&#39;)
</span><span class="noop">
</span><span class="hit">        self.complete = Selection(&#39;complete&#39;,
</span><span class="noop">                                  nodes=Node.registerednodes(),
</span><span class="noop">                                  elements=Element.registeredelements())
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        Node.clearregistry()
</span><span class="hit">        Element.clearregistry()
</span><span class="noop">
</span><span class="hit">    def test_01_nextelement(self):
</span><span class="hit">        nodes, elements = self.complete._nextelement(self.e1,
</span><span class="noop">                                                  Nodes(), Elements())
</span><span class="hit">        self.assertEqual(nodes, Nodes())
</span><span class="hit">        self.assertEqual(elements, Elements(self.e1))
</span><span class="hit">    def test_02_nextnode(self):
</span><span class="hit">        nodes, elements = self.complete._nextnode(self.n_Q1,
</span><span class="noop">                                                  Nodes(), Elements())
</span><span class="hit">        self.assertEqual(nodes, Nodes(self.n_Q1))
</span><span class="hit">        self.assertEqual(elements, Elements(self.e1, self.e2))
</span><span class="hit">    def test_03_select_upstream(self):
</span><span class="hit">        test = self.complete.copy(&#39;test&#39;).select_upstream(self.n_Q3)
</span><span class="hit">        reference = self.complete.copy(&#39;reference&#39;)
</span><span class="hit">        del(reference.elements.e5)
</span><span class="hit">        del(reference.nodes.n_T2)
</span><span class="hit">        del(reference.nodes.n_T3)
</span><span class="hit">        self.assertEqual(test.nodes, reference.nodes)
</span><span class="hit">        self.assertEqual(test.elements, reference.elements)
</span><span class="hit">    def test_04_deselect_upstream(self):
</span><span class="hit">        test = self.complete.copy(&#39;test&#39;).deselect_upstream(self.n_Q3)
</span><span class="hit">        reference = Selection(&#39;reference&#39;, [&#39;n_T2&#39;, &#39;n_T3&#39;], &#39;e5&#39;)
</span><span class="hit">        self.assertEqual(test.nodes, reference.nodes)
</span><span class="hit">        self.assertEqual(test.elements, reference.elements)
</span><span class="noop">
</span><span class="noop">#    def test_05_selectmodelclasses(self):
</span><span class="noop">#        with self.assertRaises(RuntimeError):
</span><span class="noop">#            self.complete.copy(&#39;test&#39;).getby_modelclasses(&#39;HBV96_zone&#39;)
</span><span class="noop">
</span><span class="hit">    def test_06_select_nodenames(self):
</span><span class="hit">        test = self.complete.copy(&#39;test&#39;).select_nodenames(&#39;n_Q1&#39;, &#39;n_T&#39;, &#39;NO&#39;)
</span><span class="hit">        reference = self.complete.copy(&#39;test&#39;)
</span><span class="hit">        reference.nodes = Nodes(&#39;n_Q1&#39;, &#39;n_T1&#39;, &#39;n_T2&#39;, &#39;n_T3&#39;)
</span><span class="hit">        self.assertEqual(test.nodes, reference.nodes)
</span><span class="hit">        self.assertEqual(test.elements, reference.elements)
</span><span class="hit">    def test_07_deselect_nodenames(self):
</span><span class="hit">        test = self.complete.copy(&#39;test&#39;).deselect_nodenames(&#39;n_Q1&#39;, &#39;n_T&#39;,
</span><span class="noop">                                                             &#39;NO&#39;)
</span><span class="hit">        reference = self.complete.copy(&#39;test&#39;)
</span><span class="hit">        del(reference.nodes.n_Q1)
</span><span class="hit">        del(reference.nodes.n_T1)
</span><span class="hit">        del(reference.nodes.n_T2)
</span><span class="hit">        del(reference.nodes.n_T3)
</span><span class="hit">        self.assertEqual(test.nodes, reference.nodes)
</span><span class="hit">        self.assertEqual(test.elements, reference.elements)
</span><span class="hit">    def test_08_select_elementnames(self):
</span><span class="hit">        test = self.complete.copy(&#39;test&#39;).select_elementnames(&#39;e&#39;)
</span><span class="hit">        self.assertEqual(test.nodes, self.complete.nodes)
</span><span class="hit">        self.assertEqual(test.elements, self.complete.elements)
</span><span class="hit">        test = self.complete.copy(&#39;test&#39;).select_elementnames(&#39;2&#39;)
</span><span class="hit">        reference = self.complete.copy(&#39;test&#39;)
</span><span class="hit">        reference.elements = Elements(&#39;e2&#39;)
</span><span class="hit">    def test_09_deselect_elementnames(self):
</span><span class="hit">        test = self.complete.copy(&#39;test&#39;).deselect_elementnames(&#39;e&#39;)
</span><span class="hit">        self.assertEqual(test.nodes, self.complete.nodes)
</span><span class="hit">        self.assertEqual(test.elements, Elements())
</span><span class="hit">        test = self.complete.copy(&#39;test&#39;).deselect_elementnames(&#39;2&#39;)
</span><span class="hit">        reference = self.complete.copy(&#39;test&#39;)
</span><span class="hit">        del(reference.elements.e2)
</span><span class="hit">        self.assertEqual(test.nodes, reference.nodes)
</span><span class="hit">        self.assertEqual(test.elements, reference.elements)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test03SelectionMagic(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        Node.clearregistry()
</span><span class="hit">        Element.clearregistry()
</span><span class="noop">
</span><span class="hit">    def test_01_len(self):
</span><span class="hit">        test1 = Selection(&#39;test1&#39;, [&#39;n1&#39;, &#39;n2&#39;], [])
</span><span class="hit">        self.assertEqual(len(test1), 2)
</span><span class="hit">        test2 = Selection(&#39;test2&#39;, [], [&#39;e1&#39;])
</span><span class="hit">        self.assertEqual(len(test2), 1)
</span><span class="noop">
</span><span class="hit">    def test_02_iadd(self):
</span><span class="hit">        test = Selection(&#39;sel&#39;,
</span><span class="noop">                         [&#39;n1&#39;, &#39;n2&#39;, &#39;n3&#39;],
</span><span class="noop">                         [&#39;e1&#39;, &#39;e2&#39;, &#39;e3&#39;])
</span><span class="hit">        test += Selection(&#39;add&#39;, [&#39;n3&#39;, &#39;n4&#39;], [])
</span><span class="hit">        reference = Selection(&#39;sel&#39;,
</span><span class="noop">                              [&#39;n1&#39;, &#39;n2&#39;, &#39;n3&#39;, &#39;n4&#39;],
</span><span class="noop">                              [&#39;e1&#39;, &#39;e2&#39;, &#39;e3&#39;])
</span><span class="hit">        self.assertEqual(test.nodes, reference.nodes)
</span><span class="hit">        self.assertEqual(test.elements, reference.elements)
</span><span class="hit">        test += Selection(&#39;add&#39;, [], [&#39;e4&#39;, &#39;e5&#39;])
</span><span class="hit">        reference = Selection(&#39;sel&#39;,
</span><span class="noop">                              [&#39;n1&#39;, &#39;n2&#39;, &#39;n3&#39;, &#39;n4&#39;],
</span><span class="noop">                              [&#39;e1&#39;, &#39;e2&#39;, &#39;e3&#39;, &#39;e4&#39;, &#39;e5&#39;])
</span><span class="hit">        self.assertEqual(test.nodes, reference.nodes)
</span><span class="hit">        self.assertEqual(test.elements, reference.elements)
</span><span class="hit">    def test_03_isub(self):
</span><span class="hit">        test = Selection(&#39;sel&#39;,
</span><span class="noop">                         [&#39;n1&#39;, &#39;n2&#39;, &#39;n3&#39;],
</span><span class="noop">                         [&#39;e1&#39;, &#39;e2&#39;, &#39;e3&#39;])
</span><span class="hit">        test -= Selection(&#39;sub&#39;, [&#39;n3&#39;, &#39;n4&#39;], [])
</span><span class="hit">        reference = Selection(&#39;sel&#39;,
</span><span class="noop">                              [&#39;n1&#39;, &#39;n2&#39;],
</span><span class="noop">                              [&#39;e1&#39;, &#39;e2&#39;, &#39;e3&#39;])
</span><span class="hit">        test -= Selection(&#39;sub&#39;, [], [&#39;e1&#39;, &#39;e2&#39;, &#39;e3&#39;])
</span><span class="hit">        reference = Selection(&#39;sel&#39;,
</span><span class="noop">                              [&#39;n1&#39;, &#39;n2&#39;],
</span><span class="noop">                              [])
</span><span class="hit">        self.assertEqual(test.nodes, reference.nodes)
</span><span class="hit">        self.assertEqual(test.elements, reference.elements)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="unittests_07_parametertools.py">unittests_07_parametertools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;
</span><span class="noop">Created on Thu Dec 01 10:53:44 2016
</span><span class="noop">
</span><span class="noop">@author: tyralla
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop">
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="unittests_08_indextools.py">unittests_08_indextools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import unittest
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy.core import indextools
</span><span class="hit">from hydpy.core import timetools
</span><span class="noop">
</span><span class="hit">class Test01MonthOfYear(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.indexer = indextools.Indexer()
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        pub.timegrids = None
</span><span class="noop">
</span><span class="hit">    def test_01_manual_mode(self):
</span><span class="hit">        with self.assertRaises(BaseException):
</span><span class="hit">            self.indexer.monthofyear = &#39;a&#39;
</span><span class="hit">        with self.assertRaises(BaseException):
</span><span class="hit">            self.indexer.monthofyear = [&#39;a&#39;, &#39;b&#39;]
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.indexer.monthofyear = [[1, 2], [3, 4]]
</span><span class="hit">        self.indexer.monthofyear = [1,2]
</span><span class="hit">        self.assertIsInstance(self.indexer.monthofyear, numpy.ndarray)
</span><span class="hit">        self.assertTupleEqual(tuple(self.indexer.monthofyear), (1, 2))
</span><span class="hit">        del(self.indexer.monthofyear)
</span><span class="hit">        self.assertIsNone(self.indexer._monthofyear)
</span><span class="hit">        pub.timegrids = timetools.Timegrids(timetools.Timegrid(&#39;01.01.2004&#39;,
</span><span class="noop">                                                               &#39;1.01.2005&#39;,
</span><span class="noop">                                                               &#39;1d&#39;))
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.indexer.monthofyear = [1,2]
</span><span class="noop">
</span><span class="hit">    def test_02_automatic_mode(self):
</span><span class="hit">        with self.assertRaises(RuntimeError):
</span><span class="hit">            self.indexer.monthofyear
</span><span class="hit">        pub.timegrids = timetools.Timegrids(timetools.Timegrid(&#39;01.01.2004&#39;,
</span><span class="noop">                                                               &#39;1.01.2005&#39;,
</span><span class="noop">                                                               &#39;1d&#39;))
</span><span class="hit">        self.assertIsInstance(self.indexer.monthofyear, numpy.ndarray)
</span><span class="hit">        self.assertEqual(len(self.indexer.monthofyear), 366)
</span><span class="hit">        self.assertTupleEqual(tuple(self.indexer.monthofyear),
</span><span class="noop">                              tuple(31*[0]+29*[1]+31*[2]+30*[3]+
</span><span class="noop">                                    31*[4]+30*[5]+31*[6]+31*[7]+
</span><span class="noop">                                    30*[8]+31*[9]+30*[10]+31*[11]))
</span><span class="hit">        self.assertIs(self.indexer.monthofyear, self.indexer.monthofyear)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test02DayOfYear(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.indexer = indextools.Indexer()
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        pub.timegrids = None
</span><span class="noop">
</span><span class="hit">    def test_01_manual_mode(self):
</span><span class="hit">        with self.assertRaises(BaseException):
</span><span class="hit">            self.indexer.dayofyear = &#39;a&#39;
</span><span class="hit">        with self.assertRaises(BaseException):
</span><span class="hit">            self.indexer.dayofyear = [&#39;a&#39;, &#39;b&#39;]
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.indexer.dayofyear = [[1, 2], [3, 4]]
</span><span class="hit">        self.indexer.dayofyear = [1,2]
</span><span class="hit">        self.assertIsInstance(self.indexer.dayofyear, numpy.ndarray)
</span><span class="hit">        self.assertTupleEqual(tuple(self.indexer.dayofyear), (1, 2))
</span><span class="hit">        del self.indexer.dayofyear
</span><span class="hit">        self.assertIsNone(self.indexer._dayofyear)
</span><span class="hit">        pub.timegrids = timetools.Timegrids(timetools.Timegrid(&#39;01.01.2004&#39;,
</span><span class="noop">                                                               &#39;1.01.2005&#39;,
</span><span class="noop">                                                               &#39;1d&#39;))
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.indexer.dayofyear = [1,2]
</span><span class="noop">
</span><span class="hit">    def test_02_automatic_mode(self):
</span><span class="hit">        with self.assertRaises(RuntimeError):
</span><span class="hit">            self.indexer.dayofyear
</span><span class="hit">        pub.timegrids = timetools.Timegrids(timetools.Timegrid(&#39;01.01.2004&#39;,
</span><span class="noop">                                                               &#39;1.01.2005&#39;,
</span><span class="noop">                                                               &#39;1d&#39;))
</span><span class="hit">        self.assertIsInstance(self.indexer.dayofyear, numpy.ndarray)
</span><span class="hit">        self.assertEqual(len(self.indexer.dayofyear), 366)
</span><span class="hit">        self.assertTupleEqual(tuple(self.indexer.dayofyear),
</span><span class="noop">                              tuple(range(366)))
</span><span class="hit">        pub.timegrids = timetools.Timegrids(timetools.Timegrid(&#39;01.01.2005&#39;,
</span><span class="noop">                                                               &#39;1.01.2006&#39;,
</span><span class="noop">                                                               &#39;1d&#39;))
</span><span class="hit">        del self.indexer.dayofyear
</span><span class="hit">        self.assertIsInstance(self.indexer.dayofyear, numpy.ndarray)
</span><span class="hit">        self.assertEqual(len(self.indexer.dayofyear), 365)
</span><span class="hit">        self.assertTupleEqual(
</span><span class="noop">           tuple(self.indexer.dayofyear),
</span><span class="noop">           tuple(list(range(31+28))+list(range(31+28+1, 366)))
</span><span class="noop">           )
</span><span class="hit">        self.assertIs(self.indexer.dayofyear, self.indexer.dayofyear)
</span><span class="noop">
</span><span class="hit">class Test03TimeOfYear(unittest.TestCase):
</span><span class="noop">
</span><span class="hit">    def setUp(self):
</span><span class="hit">        self.indexer = indextools.Indexer()
</span><span class="noop">
</span><span class="hit">    def tearDown(self):
</span><span class="hit">        pub.timegrids = None
</span><span class="noop">
</span><span class="hit">    def test_01_manual_mode(self):
</span><span class="hit">        with self.assertRaises(BaseException):
</span><span class="hit">            self.indexer.timeofyear = &#39;a&#39;
</span><span class="hit">        with self.assertRaises(BaseException):
</span><span class="hit">            self.indexer.timeofyear = [&#39;a&#39;, &#39;b&#39;]
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.indexer.timeofyear = [[1, 2], [3, 4]]
</span><span class="hit">        self.indexer.timeofyear = [1, 2]
</span><span class="hit">        self.assertIsInstance(self.indexer.timeofyear, numpy.ndarray)
</span><span class="hit">        self.assertTupleEqual(tuple(self.indexer.timeofyear), (1, 2))
</span><span class="hit">        del self.indexer.timeofyear
</span><span class="hit">        self.assertIsNone(self.indexer._timeofyear)
</span><span class="hit">        pub.timegrids = timetools.Timegrids(timetools.Timegrid(&#39;01.01.2004&#39;,
</span><span class="noop">                                                               &#39;1.01.2005&#39;,
</span><span class="noop">                                                               &#39;1d&#39;))
</span><span class="hit">        with self.assertRaises(ValueError):
</span><span class="hit">            self.indexer.timeofyear = [1, 2]
</span><span class="noop">
</span><span class="hit">    def test_02_automatic_mode(self):
</span><span class="hit">        with self.assertRaises(RuntimeError):
</span><span class="hit">            self.indexer.timeofyear
</span><span class="hit">        pub.timegrids = timetools.Timegrids(timetools.Timegrid(&#39;01.01.2004&#39;,
</span><span class="noop">                                                               &#39;1.01.2005&#39;,
</span><span class="noop">                                                               &#39;1d&#39;))
</span><span class="hit">        self.assertIsInstance(self.indexer.timeofyear, numpy.ndarray)
</span><span class="hit">        self.assertEqual(len(self.indexer.timeofyear), 366)
</span><span class="hit">        self.assertTupleEqual(tuple(self.indexer.timeofyear),
</span><span class="noop">                              tuple(range(366)))
</span><span class="hit">        pub.timegrids = timetools.Timegrids(timetools.Timegrid(&#39;01.01.2005&#39;,
</span><span class="noop">                                                               &#39;1.01.2006&#39;,
</span><span class="noop">                                                               &#39;1d&#39;))
</span><span class="hit">        del self.indexer.timeofyear
</span><span class="hit">        self.assertIsInstance(self.indexer.timeofyear, numpy.ndarray)
</span><span class="hit">        self.assertEqual(len(self.indexer.timeofyear), 365)
</span><span class="hit">        self.assertTupleEqual(
</span><span class="noop">           tuple(self.indexer.timeofyear),
</span><span class="noop">           tuple(list(range(31+28))+list(range(31+28+1, 366)))
</span><span class="noop">           )
</span><span class="hit">        self.assertIs(self.indexer.timeofyear, self.indexer.timeofyear)</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/__init__.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/__init__.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">&#34;&#34;&#34;
</span><span class="noop">HydPy
</span><span class="noop">
</span><span class="noop">An interactive framework for the developement and a application of
</span><span class="noop">hydrological models.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">from hydpy.core.hydpytools import HydPy
</span><span class="hit">from hydpy.core.timetools import Date
</span><span class="hit">from hydpy.core.timetools import Period
</span><span class="hit">from hydpy.core.timetools import Timegrid
</span><span class="hit">from hydpy.core.timetools import Timegrids
</span><span class="hit">from hydpy.core.filetools import MainManager
</span><span class="hit">from hydpy.core.filetools import NetworkManager
</span><span class="hit">from hydpy.core.filetools import ControlManager
</span><span class="hit">from hydpy.core.filetools import SequenceManager
</span><span class="hit">from hydpy.core.filetools import ConditionManager
</span><span class="hit">from hydpy.core.devicetools import Node
</span><span class="hit">from hydpy.core.devicetools import Nodes
</span><span class="hit">from hydpy.core.devicetools import Element
</span><span class="hit">from hydpy.core.devicetools import Elements
</span><span class="hit">from hydpy.core.selectiontools import Selection
</span><span class="hit">from hydpy.core.selectiontools import Selections
</span><span class="hit">from hydpy import pub
</span><span class="noop">
</span><span class="hit">import warnings
</span><span class="hit">import sys
</span><span class="hit">warnings.filterwarnings(&#39;ignore&#39;, r&#39;All-NaN (slice|axis) encountered&#39;)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def customwarn(message, category, filename, lineno, file=None, line=None):
</span><span class="miss">    sys.stdout.write(warnings.formatwarning(
</span><span class="noop">                                    message, category, filename, lineno))
</span><span class="hit">warnings.showwarning = customwarn
</span><span class="noop">
</span><span class="hit">__all__ = [&#39;HydPy&#39;, &#39;pub&#39;,
</span><span class="noop">           &#39;Date&#39;, &#39;Period&#39;, &#39;Timegrid&#39;, &#39;Timegrids&#39;,
</span><span class="noop">           &#39;MainManager&#39;, &#39;NetworkManager&#39;, &#39;ControlManager&#39;,
</span><span class="noop">           &#39;SequenceManager&#39;, &#39;ConditionManager&#39;,
</span><span class="noop">           &#39;Node&#39;, &#39;Nodes&#39;, &#39;Element&#39;, &#39;Elements&#39;, &#39;Selection&#39;, &#39;Selections&#39;]
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/pub.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/pub.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">
</span><span class="noop"># import from...
</span><span class="noop"># ...the standard library
</span><span class="hit">import sys as __sys
</span><span class="noop"># from HydPy
</span><span class="hit">from hydpy.core import objecttools
</span><span class="hit">from hydpy.core import indextools
</span><span class="noop">
</span><span class="hit">projectname = None
</span><span class="noop">
</span><span class="hit">options = objecttools.Options()
</span><span class="hit">indexer = indextools.Indexer()
</span><span class="hit">networkmanager = None
</span><span class="hit">controlmanager = None
</span><span class="hit">conditionmanager = None
</span><span class="hit">sequencemanager = None
</span><span class="hit">timegrids = None
</span><span class="noop">
</span><span class="hit">pyversion = int(__sys.version[0])
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/__init__.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/__init__.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre></pre>
      </td>
      <td class="source">
        <pre></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/connectiontools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/connectiontools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from Hydpy
</span><span class="hit">from hydpy.core import objecttools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Connections(object):
</span><span class="noop">    &#34;&#34;&#34;Connection between :class:`~hydpy.core.devicetools.Node` and
</span><span class="noop">    :class:`~hydpy.core.devicetools.Element` instances.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self, master, *slaves):
</span><span class="hit">        self.master = master
</span><span class="hit">        for slave in slaves:
</span><span class="miss">            self += slave
</span><span class="noop">
</span><span class="hit">    def __iadd__(self, slave):
</span><span class="hit">        setattr(self, slave.name, slave)
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def names(self):
</span><span class="hit">        return [name for (name, slave) in self]
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def slaves(self):
</span><span class="hit">        return [slave for (name, slave) in self]
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def variables(self):
</span><span class="hit">        variable = getattr(self.master, &#39;variable&#39;, None)
</span><span class="hit">        if variable:
</span><span class="miss">            return [variable]
</span><span class="noop">        else:
</span><span class="hit">            return sorted(set([slave.variable for (name, slave) in self]))
</span><span class="noop">
</span><span class="hit">    def __contains__(self, value):
</span><span class="hit">        return value in (self.names + self.slaves)
</span><span class="noop">
</span><span class="hit">    def __setitem__(self, name, value):
</span><span class="miss">        self.__dict__[name] = value
</span><span class="noop">
</span><span class="hit">    def __getitem__(self, name):
</span><span class="hit">        return self.__dict__[name]
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="hit">        for (name, slave) in vars(self).items():
</span><span class="hit">            if name != &#39;master&#39;:
</span><span class="hit">                yield (name, slave)
</span><span class="noop">
</span><span class="hit">    def __len__(self):
</span><span class="hit">        return len(self.names)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/devicetools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/devicetools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import copy
</span><span class="hit">import struct
</span><span class="noop"># ...from site-packages
</span><span class="hit">from matplotlib import pyplot
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy.core import connectiontools
</span><span class="hit">from hydpy.core import objecttools
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="hit">from hydpy.cythons import pointer
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Device(object):
</span><span class="noop">
</span><span class="hit">    _registry = {}
</span><span class="hit">    _selection = {}
</span><span class="noop">
</span><span class="hit">    def _getname(self):
</span><span class="noop">        &#34;&#34;&#34;Name of the actual device (node or element).&#34;&#34;&#34;
</span><span class="hit">        return self._name
</span><span class="hit">    name = property(_getname)
</span><span class="noop">
</span><span class="hit">    def _checkname(self, name):
</span><span class="noop">        &#34;&#34;&#34;Raises an :class:`~exceptions.ValueError` if the given name is not
</span><span class="noop">        a valid Python identifier.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        exc = ValueError(&#39;For initializing `%s` objects, `value` is a &#39;
</span><span class="noop">                         &#39;necessary function argument.  Principally, any &#39;
</span><span class="noop">                         &#39;object is allowed that supports the Python build-in &#39;
</span><span class="noop">                         &#39;function `str`.  But note that `str(value)` must &#39;
</span><span class="noop">                         &#39;return a valid Python identifier (that does &#39;
</span><span class="noop">                         &#39;not start with a number, that does not contain `-`, &#39;
</span><span class="noop">                         &#39;that is not a Python keyword like `for`...).  The &#39;
</span><span class="noop">                         &#39;given object returned the string `%s`, which is not &#39;
</span><span class="noop">                         &#39;a valid Python identifier.&#39;
</span><span class="noop">                         % (objecttools.classname(self), name))
</span><span class="hit">        try:
</span><span class="hit">            exec(&#39;%s = None&#39; % name)
</span><span class="hit">        except SyntaxError:
</span><span class="hit">            raise exc
</span><span class="hit">        if name in dir(__builtins__):
</span><span class="miss">            raise exc
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def clearregistry(cls):
</span><span class="hit">        cls._selection.clear()
</span><span class="hit">        cls._registry.clear()
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def registerednames(cls):
</span><span class="noop">        &#34;&#34;&#34;Get all names of :class:`Device` objects initialized so far.&#34;&#34;&#34;
</span><span class="hit">        return cls._registry.keys()
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="miss">        for (key, value) in vars(self).items():
</span><span class="miss">            if isinstance(value, connectiontools.Connections):
</span><span class="miss">                yield (key, value)
</span><span class="noop">
</span><span class="hit">    def __str__(self):
</span><span class="hit">        return self.name
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Node(Device):
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">    readobs = False
</span><span class="noop">    readext = False
</span><span class="noop">    passsim = True
</span><span class="noop">    passobs = False
</span><span class="noop">    passext = False
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    _registry = {}
</span><span class="hit">    _selection = {}
</span><span class="hit">    _predefinedvariable = &#39;Q&#39;
</span><span class="hit">    ROUTING_MODES = (&#39;newsim&#39;, &#39;obs&#39;, &#39;oldsim&#39;)
</span><span class="noop">
</span><span class="hit">    def __new__(cls, value, variable=None):
</span><span class="noop">        &#34;&#34;&#34;Returns an already existing :class:`Node` instance or, if such
</span><span class="noop">        an instance does not exist yet, a new newly created one.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        name = str(value)
</span><span class="hit">        if name not in cls._registry:
</span><span class="hit">            self = object.__new__(Node)
</span><span class="hit">            self._checkname(name)
</span><span class="hit">            self._name = name
</span><span class="hit">            if variable is None:
</span><span class="hit">                self._variable = self._predefinedvariable
</span><span class="noop">            else:
</span><span class="hit">                self._variable = variable
</span><span class="hit">            self.entries = connectiontools.Connections(self)
</span><span class="hit">            self.exits = connectiontools.Connections(self)
</span><span class="hit">            self.sequences = sequencetools.NodeSequences(self)
</span><span class="hit">            self.routingmode = &#39;newsim&#39;
</span><span class="hit">            self._blackhole = None
</span><span class="hit">            cls._registry[name] = self
</span><span class="hit">        cls._selection[name] = cls._registry[name]
</span><span class="hit">        return cls._registry[name]
</span><span class="noop">
</span><span class="hit">    def __init__(self, name, variable=None, route=None):
</span><span class="hit">        if (variable is not None) and (variable != self.variable):
</span><span class="hit">            raise ValueError(&#39;The variable to be represented by a `Node &#39;
</span><span class="noop">                             &#39;instance cannot be changed.  The variable of &#39;
</span><span class="noop">                             &#39;node `%s` is `%s` instead of `%s` or `None`.  &#39;
</span><span class="noop">                             &#39;Keep in mind, that `name` is the unique &#39;
</span><span class="noop">                             &#39;identifier of node objects.&#39;
</span><span class="noop">                             % (self.name, self.variable, variable))
</span><span class="noop">
</span><span class="hit">    def _getvariable(self):
</span><span class="noop">        &#34;&#34;&#34;The variable handled by the respective node instance.&#34;&#34;&#34;
</span><span class="hit">        return self._variable
</span><span class="hit">    variable = property(_getvariable)
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def predefinevariable(cls, name):
</span><span class="miss">        cls._predefinedvariable = str(name)
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def registerednodes(cls):
</span><span class="noop">        &#34;&#34;&#34;Get all :class:`Node` objects initialized so far.&#34;&#34;&#34;
</span><span class="hit">        return Nodes(cls._registry.values())
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def gathernewnodes(cls):
</span><span class="noop">        &#34;&#34;&#34;Gather all `new` :class:`Node` objects. :class:`Node` objects
</span><span class="noop">        are deemed to be new if their constructor has been called since the
</span><span class="noop">        last usage of this method.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        nodes = Nodes(cls._selection.values())
</span><span class="miss">        cls._selection.clear()
</span><span class="miss">        return nodes
</span><span class="noop">
</span><span class="hit">    def _getroutingmode(self):
</span><span class="hit">        return self._routingmode
</span><span class="noop">
</span><span class="hit">    def _setroutingmode(self, value):
</span><span class="hit">        if value in self.ROUTING_MODES:
</span><span class="hit">            self._routingmode = value
</span><span class="hit">            if value == &#39;newsim&#39;:
</span><span class="hit">                self.sequences.sim.use_ext = False
</span><span class="hit">            elif value == &#39;obs&#39;:
</span><span class="miss">                self.sequences.sim.use_ext = False
</span><span class="miss">                self.sequences.obs.use_ext = True
</span><span class="hit">            elif value == &#39;oldsim&#39;:
</span><span class="hit">                self.sequences.sim.use_ext = True
</span><span class="hit">                self._blackhole = pointer.Double(0.)
</span><span class="noop">        else:
</span><span class="miss">            raise ValueError(&#39;When trying to set the routing mode of node %s, &#39;
</span><span class="noop">                             &#39;the value `%s` was given, but only the &#39;
</span><span class="noop">                             &#39;following values are allowed: %s.&#39;
</span><span class="noop">                             % (self.name, value,
</span><span class="noop">                                 &#39;, &#39;.join(self.ROUTING_MODES)))
</span><span class="noop">
</span><span class="hit">    routingmode = property(_getroutingmode, _setroutingmode)
</span><span class="noop">
</span><span class="hit">    def getdouble_via_exits(self):
</span><span class="hit">        if self.routingmode != &#39;obs&#39;:
</span><span class="hit">            return self.sequences.fastaccess.sim
</span><span class="noop">        else:
</span><span class="miss">            return self.sequences.fastaccess.obs
</span><span class="noop">
</span><span class="hit">    def getdouble_via_entries(self):
</span><span class="hit">        if self.routingmode != &#39;oldsim&#39;:
</span><span class="hit">            return self.sequences.fastaccess.sim
</span><span class="noop">        else:
</span><span class="miss">            return self._blackhole
</span><span class="noop">
</span><span class="hit">    def reset(self, idx=None):
</span><span class="hit">        self.sequences.fastaccess.sim[0] = 0.
</span><span class="noop">
</span><span class="hit">    def _loaddata_sim(self, idx):
</span><span class="hit">        fastaccess = self.sequences.fastaccess
</span><span class="hit">        if fastaccess._sim_ramflag:
</span><span class="hit">            fastaccess.sim[0] = fastaccess._sim_array[idx]
</span><span class="miss">        elif fastaccess._sim_diskflag:
</span><span class="miss">            raw = fastaccess._sim_file.read(8)
</span><span class="miss">            fastaccess.sim[0] = struct.unpack(&#39;d&#39;, raw)
</span><span class="noop">
</span><span class="hit">    def _savedata_sim(self, idx):
</span><span class="hit">        fastaccess = self.sequences.fastaccess
</span><span class="hit">        if fastaccess._sim_ramflag:
</span><span class="hit">            fastaccess._sim_array[idx] = fastaccess.sim[0]
</span><span class="miss">        elif fastaccess._sim_diskflag:
</span><span class="miss">            raw = struct.pack(&#39;d&#39;, fastaccess.sim[0])
</span><span class="miss">            fastaccess._sim_file.write(raw)
</span><span class="noop">
</span><span class="hit">    def _loaddata_obs(self, idx):
</span><span class="hit">        fastaccess = self.sequences.fastaccess
</span><span class="hit">        if fastaccess._obs_ramflag:
</span><span class="miss">            fastaccess.obs[0] = fastaccess._obs_array[idx]
</span><span class="hit">        elif fastaccess._obs_diskflag:
</span><span class="miss">            raw = fastaccess._obs_file.read(8)
</span><span class="miss">            fastaccess.obs[0] = struct.unpack(&#39;d&#39;, raw)
</span><span class="noop">
</span><span class="hit">    def prepare_allseries(self, ramflag=True):
</span><span class="miss">        self.prepare_simseries(ramflag)
</span><span class="miss">        self.prepare_obsseries(ramflag)
</span><span class="noop">
</span><span class="hit">    def prepare_simseries(self, ramflag=True):
</span><span class="miss">        self._prepare_nodeseries(&#39;sim&#39;, ramflag)
</span><span class="noop">
</span><span class="hit">    def prepare_obsseries(self, ramflag=True):
</span><span class="miss">        self._prepare_nodeseries(&#39;obs&#39;, ramflag)
</span><span class="noop">
</span><span class="hit">    def _prepare_nodeseries(self, seqname, ramflag):
</span><span class="miss">        seq = getattr(self.sequences, seqname)
</span><span class="miss">        if ramflag:
</span><span class="miss">            seq.activate_ram()
</span><span class="noop">        else:
</span><span class="miss">            seq.activate_disk()
</span><span class="noop">
</span><span class="hit">    def comparisonplot(self, **kwargs):
</span><span class="miss">        for (name, seq) in self.sequences:
</span><span class="miss">            if pyplot.isinteractive():
</span><span class="miss">                name = &#39; &#39;.join((self.name, name))
</span><span class="miss">            pyplot.plot(seq.series, label=name, **kwargs)
</span><span class="miss">        pyplot.legend()
</span><span class="miss">        variable = self.variable
</span><span class="miss">        if variable == &#39;Q&#39;:
</span><span class="miss">            variable = u&#39;Q [m³/s]&#39;
</span><span class="miss">        pyplot.ylabel(variable)
</span><span class="miss">        if not pyplot.isinteractive():
</span><span class="miss">            pyplot.show()
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        return self.assignrepr(&#39;&#39;)
</span><span class="noop">
</span><span class="hit">    def assignrepr(self, prefix):
</span><span class="hit">        return (&#39;%sNode(&#34;%s&#34;, variable=&#34;%s&#34;)&#39;
</span><span class="noop">                % (prefix, self.name, self.variable))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Element(Device):
</span><span class="noop">
</span><span class="hit">    _registry = {}
</span><span class="hit">    _selection = {}
</span><span class="noop">
</span><span class="hit">    def __new__(cls, value, inlets=None, outlets=None,
</span><span class="noop">                receivers=None, senders=None):
</span><span class="noop">        &#34;&#34;&#34;Returns an already existing :class:`Element` instance or, if such
</span><span class="noop">        an instance does not exist yet, a new newly created one.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        name = str(value)
</span><span class="hit">        if name not in cls._registry:
</span><span class="hit">            self = object.__new__(Element)
</span><span class="hit">            self._checkname(name)
</span><span class="hit">            self._name = name
</span><span class="hit">            self.inlets = connectiontools.Connections(self)
</span><span class="hit">            self.outlets = connectiontools.Connections(self)
</span><span class="hit">            self.receivers = connectiontools.Connections(self)
</span><span class="hit">            self.senders = connectiontools. Connections(self)
</span><span class="hit">            self.model = None
</span><span class="hit">            cls._registry[name] = self
</span><span class="hit">        cls._selection[name] = cls._registry[name]
</span><span class="hit">        return cls._registry[name]
</span><span class="noop">
</span><span class="hit">    def __init__(self, name, inlets=None, outlets=None,
</span><span class="noop">                 receivers=None, senders=None):
</span><span class="noop">        &#34;&#34;&#34;Adds the given :class:`~connectiontools.Connections` instances to
</span><span class="noop">        the (old or new) :class:`Element` instance.&#34;&#34;&#34;
</span><span class="hit">        if inlets is not None:
</span><span class="hit">            for (name, inlet) in Nodes(inlets):
</span><span class="hit">                if inlet in self.outlets:
</span><span class="hit">                    raise ValueError(&#39;For element `%s`, the given inlet node &#39;
</span><span class="noop">                                     &#39;`%s` is already defined as an outlet &#39;
</span><span class="noop">                                     &#39;node, which is not allowed.&#39;
</span><span class="noop">                                     % (self, inlet))
</span><span class="hit">                self.inlets += inlet
</span><span class="hit">                inlet.exits += self
</span><span class="hit">        if outlets is not None:
</span><span class="hit">            for (name, outlet) in Nodes(outlets):
</span><span class="hit">                if outlet in self.inlets:
</span><span class="hit">                    raise ValueError(&#39;For element `%s`, the given outlet node &#39;
</span><span class="noop">                                     &#39;`%s` is already defined as an inlet &#39;
</span><span class="noop">                                     &#39;node, which is not allowed.&#39;
</span><span class="noop">                                     % (self, outlet))
</span><span class="hit">                self.outlets += outlet
</span><span class="hit">                outlet.entries += self
</span><span class="hit">        if receivers is not None:
</span><span class="hit">            for (name, receiver) in Nodes(receivers):
</span><span class="hit">                if receiver in self.senders:
</span><span class="hit">                    raise ValueError(&#39;For element `%s`, the given receiver &#39;
</span><span class="noop">                                     &#39;node `%s` is already defined as an &#39;
</span><span class="noop">                                     &#39;sender node, which is not allowed.&#39;
</span><span class="noop">                                     % (self, receiver))
</span><span class="hit">                self.receivers += receiver
</span><span class="hit">                receiver.exits += self
</span><span class="hit">        if senders is not None:
</span><span class="hit">            for (name, sender) in Nodes(senders):
</span><span class="hit">                if sender in self.receivers:
</span><span class="hit">                    raise ValueError(&#39;For element `%s`, the given sender node &#39;
</span><span class="noop">                                     &#39;`%s` is already defined as an receiver, &#39;
</span><span class="noop">                                     &#39;node which is not allowed.&#39;
</span><span class="noop">                                     % (self, sender))
</span><span class="hit">                self.senders += sender
</span><span class="hit">                sender.entries += self
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def registeredelements(cls):
</span><span class="noop">        &#34;&#34;&#34;Get all :class:`Element` objects initialized so far.&#34;&#34;&#34;
</span><span class="hit">        return Elements(cls._registry.values())
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def gathernewelements(cls):
</span><span class="noop">        &#34;&#34;&#34;Gather all `new` :class:`Element` objects. :class:`Element` objects
</span><span class="noop">        are deemed to be new if their constructor has been called since the
</span><span class="noop">        last usage of this method.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        elements = Elements(cls._selection.values())
</span><span class="miss">        cls._selection.clear()
</span><span class="miss">        return elements
</span><span class="noop">
</span><span class="hit">    def _getvariables(self):
</span><span class="miss">        variables = set()
</span><span class="miss">        for (name, connections) in self:
</span><span class="miss">            variables.update(connections.variables)
</span><span class="miss">        return variables
</span><span class="hit">    variables = property(_getvariables)
</span><span class="noop">
</span><span class="hit">    def initmodel(self):
</span><span class="miss">        namespace = pub.controlmanager.loadfile(self.name)
</span><span class="miss">        self.model = namespace[&#39;model&#39;]
</span><span class="miss">        self.model.element = self
</span><span class="noop">
</span><span class="hit">    def connect(self, model=None):
</span><span class="hit">        if model is not None:
</span><span class="hit">            self.model = model
</span><span class="hit">            model.element = self
</span><span class="hit">        try:
</span><span class="hit">            self.model.connect()
</span><span class="miss">        except BaseException:
</span><span class="miss">            objecttools.augmentexcmessage(
</span><span class="noop">                &#39;While trying to build the connections of the model handled &#39;
</span><span class="noop">                &#39;by element `%s`&#39; % self.name)
</span><span class="noop">
</span><span class="hit">    def prepare_allseries(self, ramflag=True):
</span><span class="miss">        self.prepare_inputseries(ramflag)
</span><span class="miss">        self.prepare_fluxseries(ramflag)
</span><span class="miss">        self.prepare_stateseries(ramflag)
</span><span class="noop">
</span><span class="hit">    def prepare_inputseries(self, ramflag=True):
</span><span class="miss">        self._prepare_series(&#39;inputs&#39;, ramflag)
</span><span class="noop">
</span><span class="hit">    def prepare_fluxseries(self, ramflag=True):
</span><span class="hit">        self._prepare_series(&#39;fluxes&#39;, ramflag)
</span><span class="noop">
</span><span class="hit">    def prepare_stateseries(self, ramflag=True):
</span><span class="hit">        self._prepare_series(&#39;states&#39;, ramflag)
</span><span class="noop">
</span><span class="hit">    def _prepare_series(self, name_subseqs, ramflag):
</span><span class="hit">        sequences = self.model.sequences
</span><span class="hit">        subseqs = getattr(sequences, name_subseqs, None)
</span><span class="hit">        if subseqs:
</span><span class="hit">            if ramflag:
</span><span class="hit">                subseqs.activate_ram()
</span><span class="noop">            else:
</span><span class="miss">                subseqs.activate_disk()
</span><span class="noop">
</span><span class="hit">    def _plot(self, subseqs, selnames, kwargs):
</span><span class="miss">        for name in selnames:
</span><span class="miss">            seq = getattr(subseqs, name)
</span><span class="miss">            if seq.NDIM == 0:
</span><span class="miss">                label = kwargs.pop(&#39;label&#39;, &#39; &#39;.join((self.name, name)))
</span><span class="miss">                pyplot.plot(seq.series, label=label, **kwargs)
</span><span class="miss">                pyplot.legend()
</span><span class="noop">            else:
</span><span class="miss">                color = kwargs.pop(&#39;color&#39;, kwargs.pop(&#39;c&#39;, &#39;red&#39;))
</span><span class="miss">                pyplot.plot(seq.series, color=color, **kwargs)
</span><span class="miss">        if not pyplot.isinteractive():
</span><span class="miss">            pyplot.show()
</span><span class="noop">
</span><span class="hit">    def inputplot(self, *args, **kwargs):
</span><span class="miss">        self._plot(self.model.sequences.inputs, args, kwargs)
</span><span class="noop">
</span><span class="hit">    def fluxplot(self, *args, **kwargs):
</span><span class="miss">        self._plot(self.model.sequences.fluxes, args, kwargs)
</span><span class="noop">
</span><span class="hit">    def stateplot(self, *args, **kwargs):
</span><span class="miss">        self._plot(self.model.sequences.states, args, kwargs)
</span><span class="noop">
</span><span class="hit">    def assignrepr(self, prefix):
</span><span class="noop">        &#34;&#34;&#34;Return a :func:`repr` string with an prefixed assignement.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * prefix(:class:`str`): Usually something like &#39;x = &#39;.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        blanks = &#39; &#39; * (len(prefix) + 8)
</span><span class="hit">        lines = []
</span><span class="hit">        lines.append(&#39;%sElement(&#34;%s&#34;,&#39; % (prefix, self.name))
</span><span class="hit">        for conname in (&#39;inlets&#39;, &#39;outlets&#39;, &#39;receivers&#39;, &#39;senders&#39;):
</span><span class="hit">            connections = getattr(self, conname, None)
</span><span class="hit">            if connections:
</span><span class="miss">                subprefix = &#39;%s%s=&#39; % (blanks, conname)
</span><span class="miss">                if len(connections) == 1:
</span><span class="miss">                    line = connections.slaves[0].assignrepr(subprefix)
</span><span class="noop">                else:
</span><span class="miss">                    line = Nodes(connections.slaves).assignrepr(subprefix)
</span><span class="miss">                lines.append(line + &#39;,&#39;)
</span><span class="hit">        lines[-1] = lines[-1][:-1]+&#39;)&#39;
</span><span class="hit">        return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        return self.assignrepr(&#39;&#39;)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Devices(object):
</span><span class="noop">
</span><span class="hit">    _contentclass = None
</span><span class="noop">
</span><span class="hit">    def __init__(self, *values):
</span><span class="hit">        try:
</span><span class="hit">            self._extractvalues(values)
</span><span class="hit">        except BaseException:
</span><span class="hit">            objecttools.augmentexcmessage(
</span><span class="noop">                &#39;While trying to initialize a `%s` object&#39;
</span><span class="noop">                % objecttools.classname(self))
</span><span class="noop">
</span><span class="hit">    def _extractvalues(self, values):
</span><span class="hit">        if values is None:
</span><span class="hit">            return
</span><span class="hit">        elif isinstance(values, (self._contentclass, str)):
</span><span class="hit">            device = self._contentclass(values)
</span><span class="hit">            self[device.name] = device
</span><span class="noop">        else:
</span><span class="hit">            for value in values:
</span><span class="hit">                self._extractvalues(value)
</span><span class="noop">
</span><span class="hit">    def _getnames(self):
</span><span class="hit">        return vars(self).keys()
</span><span class="hit">    names = property(_getnames)
</span><span class="noop">
</span><span class="hit">    def _getdevices(self):
</span><span class="hit">        return vars(self).values()
</span><span class="hit">    devices = property(_getdevices)
</span><span class="noop">
</span><span class="hit">    def copy(self):
</span><span class="noop">        &#34;&#34;&#34;Return a shallow copy of the actual :class:`Elements` instance.&#34;&#34;&#34;
</span><span class="hit">        return copy.copy(self)
</span><span class="noop">
</span><span class="hit">    def __setitem__(self, key, value):
</span><span class="hit">        self.__dict__[key] = value
</span><span class="noop">
</span><span class="hit">    def __getitem__(self, key):
</span><span class="hit">        return self.__dict__[key]
</span><span class="noop">
</span><span class="hit">    def __delitem__(self, key):
</span><span class="hit">        del(self.__dict__[key])
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="hit">        for name in sorted(vars(self).keys()):
</span><span class="hit">            yield (name, self[name])
</span><span class="noop">
</span><span class="hit">    def __contains__(self, device):
</span><span class="hit">        device = self._contentclass(device)
</span><span class="hit">        return device.name in self.__dict__
</span><span class="noop">
</span><span class="hit">    def __len__(self):
</span><span class="hit">        return len(self.names)
</span><span class="noop">
</span><span class="hit">    def __add__(self, values):
</span><span class="hit">        new = self.copy()
</span><span class="hit">        for (name, device) in self.__class__(values):
</span><span class="hit">            new[name] = device
</span><span class="hit">        return new
</span><span class="noop">
</span><span class="hit">    def __iadd__(self, values):
</span><span class="hit">        for (name, device) in self.__class__(values):
</span><span class="hit">            self[name] = device
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def __sub__(self, values):
</span><span class="hit">        new = self.copy()
</span><span class="hit">        for (name, device) in self.__class__(values):
</span><span class="hit">            if name in self:
</span><span class="hit">                del(new[name])
</span><span class="hit">        return new
</span><span class="noop">
</span><span class="hit">    def __isub__(self, values):
</span><span class="hit">        for (name, device) in self.__class__(values):
</span><span class="hit">            if name in self:
</span><span class="hit">                del(self[name])
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def __lt__(self, other):
</span><span class="miss">        return set(self.devices) &lt; set(other.devices)
</span><span class="noop">
</span><span class="hit">    def __le__(self, other):
</span><span class="miss">        return set(self.devices) &lt;= set(other.devices)
</span><span class="noop">
</span><span class="hit">    def __eq__(self, other):
</span><span class="hit">        return set(self.devices) == set(other.devices)
</span><span class="noop">
</span><span class="hit">    def __ne__(self, other):
</span><span class="miss">        return set(self.devices) != set(other.devices)
</span><span class="noop">
</span><span class="hit">    def __ge__(self, other):
</span><span class="miss">        return set(self.devices) &gt;= set(other.devices)
</span><span class="noop">
</span><span class="hit">    def __gt__(self, other):
</span><span class="miss">        return set(self.devices) &gt; set(other.devices)
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="miss">        lines = []
</span><span class="miss">        for (name, device) in sorted(zip(self.names, self.devices)):
</span><span class="miss">            lines.append(repr(device))
</span><span class="miss">        return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="hit">    def assignrepr(self, prefix):
</span><span class="miss">        lines = []
</span><span class="miss">        prefix += &#39;%s(&#39; % objecttools.classname(self)
</span><span class="miss">        blanks = &#39; &#39;*len(prefix)
</span><span class="miss">        names = sorted(self.names)
</span><span class="miss">        for (idx, name) in enumerate(names):
</span><span class="miss">            device = self[name]
</span><span class="miss">            if idx == 0:
</span><span class="miss">                lines.append(device.assignrepr(prefix))
</span><span class="noop">            else:
</span><span class="miss">                lines.append(device.assignrepr(blanks))
</span><span class="miss">            lines[-1] += &#39;,&#39;
</span><span class="miss">        lines[-1] = lines[-1][:-1]+&#39;)&#39;
</span><span class="miss">        return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Nodes(Devices):
</span><span class="noop">
</span><span class="hit">    _contentclass = Node
</span><span class="noop">
</span><span class="hit">    def prepare_allseries(self, ramflag=True):
</span><span class="miss">        self.prepare_simseries(ramflag)
</span><span class="miss">        self.prepare_obsseries(ramflag)
</span><span class="noop">
</span><span class="hit">    def prepare_simseries(self, ramflag=True):
</span><span class="miss">        for (name, node) in self:
</span><span class="miss">            node.prepare_simseries(ramflag)
</span><span class="noop">
</span><span class="hit">    def prepare_obsseries(self, ramflag=True):
</span><span class="miss">        for (name, node) in self:
</span><span class="miss">            node.prepare_obsseries(ramflag)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Elements(Devices):
</span><span class="noop">
</span><span class="hit">    _contentclass = Element
</span><span class="noop">
</span><span class="hit">    def prepare_allseries(self, ramflag=True):
</span><span class="miss">        for (name, element) in self:
</span><span class="miss">            element.prepare_allseries(ramflag)
</span><span class="noop">
</span><span class="hit">    def prepare_inputseries(self, ramflag=True):
</span><span class="miss">        for (name, element) in self:
</span><span class="miss">            element.prepare_inputseries(ramflag)
</span><span class="noop">
</span><span class="hit">    def prepare_fluxseries(self, ramflag=True):
</span><span class="miss">        for (name, element) in self:
</span><span class="miss">            element.prepare_fluxseries(ramflag)
</span><span class="noop">
</span><span class="hit">    def prepare_stateseries(self, ramflag=True):
</span><span class="miss">        for (name, element) in self:
</span><span class="miss">            element.prepare_stateseries(ramflag)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/filetools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/filetools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
677 &nbsp;
678 &nbsp;
679 &nbsp;
680 &nbsp;
681 &nbsp;
682 &nbsp;
683 &nbsp;
684 &nbsp;
685 &nbsp;
686 &nbsp;
687 &nbsp;
688 &nbsp;
689 &nbsp;
690 &nbsp;
691 &nbsp;
692 &nbsp;
693 &nbsp;
694 &nbsp;
695 &nbsp;
696 &nbsp;
697 &nbsp;
698 &nbsp;
699 &nbsp;
700 &nbsp;
701 &nbsp;
702 &nbsp;
703 &nbsp;
704 &nbsp;
705 &nbsp;
706 &nbsp;
707 &nbsp;
708 &nbsp;
709 &nbsp;
710 &nbsp;
711 &nbsp;
712 &nbsp;
713 &nbsp;
714 &nbsp;
715 &nbsp;
716 &nbsp;
717 &nbsp;
718 &nbsp;
719 &nbsp;
720 &nbsp;
721 &nbsp;
722 &nbsp;
723 &nbsp;
724 &nbsp;
725 &nbsp;
726 &nbsp;
727 &nbsp;
728 &nbsp;
729 &nbsp;
730 &nbsp;
731 &nbsp;
732 &nbsp;
733 &nbsp;
734 &nbsp;
735 &nbsp;
736 &nbsp;
737 &nbsp;
738 &nbsp;
739 &nbsp;
740 &nbsp;
741 &nbsp;
742 &nbsp;
743 &nbsp;
744 &nbsp;
745 &nbsp;
746 &nbsp;
747 &nbsp;
748 &nbsp;
749 &nbsp;
750 &nbsp;
751 &nbsp;
752 &nbsp;
753 &nbsp;
754 &nbsp;
755 &nbsp;
756 &nbsp;
757 &nbsp;
758 &nbsp;
759 &nbsp;
760 &nbsp;
761 &nbsp;
762 &nbsp;
763 &nbsp;
764 &nbsp;
765 &nbsp;
766 &nbsp;
767 &nbsp;
768 &nbsp;
769 &nbsp;
770 &nbsp;
771 &nbsp;
772 &nbsp;
773 &nbsp;
774 &nbsp;
775 &nbsp;
776 &nbsp;
777 &nbsp;
778 &nbsp;
779 &nbsp;
780 &nbsp;
781 &nbsp;
782 &nbsp;
783 &nbsp;
784 &nbsp;
785 &nbsp;
786 &nbsp;
787 &nbsp;
788 &nbsp;
789 &nbsp;
790 &nbsp;
791 &nbsp;
792 &nbsp;
793 &nbsp;
794 &nbsp;
795 &nbsp;
796 &nbsp;
797 &nbsp;
798 &nbsp;
799 &nbsp;
800 &nbsp;
801 &nbsp;
802 &nbsp;
803 &nbsp;
804 &nbsp;
805 &nbsp;
806 &nbsp;
807 &nbsp;
808 &nbsp;
809 &nbsp;
810 &nbsp;
811 &nbsp;
812 &nbsp;
813 &nbsp;
814 &nbsp;
815 &nbsp;
816 &nbsp;
817 &nbsp;
818 &nbsp;
819 &nbsp;
820 &nbsp;
821 &nbsp;
822 &nbsp;
823 &nbsp;
824 &nbsp;
825 &nbsp;
826 &nbsp;
827 &nbsp;
828 &nbsp;
829 &nbsp;
830 &nbsp;
831 &nbsp;
832 &nbsp;
833 &nbsp;
834 &nbsp;
835 &nbsp;
836 &nbsp;
837 &nbsp;
838 &nbsp;
839 &nbsp;
840 &nbsp;
841 &nbsp;
842 &nbsp;
843 &nbsp;
844 &nbsp;
845 &nbsp;
846 &nbsp;
847 &nbsp;
848 &nbsp;
849 &nbsp;
850 &nbsp;
851 &nbsp;
852 &nbsp;
853 &nbsp;
854 &nbsp;
855 &nbsp;
856 &nbsp;
857 &nbsp;
858 &nbsp;
859 &nbsp;
860 &nbsp;
861 &nbsp;
862 &nbsp;
863 &nbsp;
864 &nbsp;
865 &nbsp;
866 &nbsp;
867 &nbsp;
868 &nbsp;
869 &nbsp;
870 &nbsp;
871 &nbsp;
872 &nbsp;
873 &nbsp;
874 &nbsp;
875 &nbsp;
876 &nbsp;
877 &nbsp;
878 &nbsp;
879 &nbsp;
880 &nbsp;
881 &nbsp;
882 &nbsp;
883 &nbsp;
884 &nbsp;
885 &nbsp;
886 &nbsp;
887 &nbsp;
888 &nbsp;
889 &nbsp;
890 &nbsp;
891 &nbsp;
892 &nbsp;
893 &nbsp;
894 &nbsp;
895 &nbsp;
896 &nbsp;
897 &nbsp;
898 &nbsp;
899 &nbsp;
900 &nbsp;
901 &nbsp;
902 &nbsp;
903 &nbsp;
904 &nbsp;
905 &nbsp;
906 &nbsp;
907 &nbsp;
908 &nbsp;
909 &nbsp;
910 &nbsp;
911 &nbsp;
912 &nbsp;
913 &nbsp;
914 &nbsp;
915 &nbsp;
916 &nbsp;
917 &nbsp;
918 &nbsp;
919 &nbsp;
920 &nbsp;
921 &nbsp;
922 &nbsp;
923 &nbsp;
924 &nbsp;
925 &nbsp;
926 &nbsp;
927 &nbsp;
928 &nbsp;
929 &nbsp;
930 &nbsp;
931 &nbsp;
932 &nbsp;
933 &nbsp;
934 &nbsp;
935 &nbsp;
936 &nbsp;
937 &nbsp;
938 &nbsp;
939 &nbsp;
940 &nbsp;
941 &nbsp;
942 &nbsp;
943 &nbsp;
944 &nbsp;
945 &nbsp;
946 &nbsp;
947 &nbsp;
948 &nbsp;
949 &nbsp;
950 &nbsp;
951 &nbsp;
952 &nbsp;
953 &nbsp;
954 &nbsp;
955 &nbsp;
956 &nbsp;
957 &nbsp;
958 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import os
</span><span class="hit">import sys
</span><span class="hit">import warnings
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy.core import objecttools
</span><span class="hit">from hydpy.core import timetools
</span><span class="hit">from hydpy.core import devicetools
</span><span class="hit">from hydpy.core import selectiontools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MainManager(object):
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="miss">        self.info = {}
</span><span class="miss">        self.networkfile = None
</span><span class="miss">        self.controlfiles = None
</span><span class="miss">        self.sequencefiles = None
</span><span class="miss">        self.initialvaluefiles = None
</span><span class="miss">        self.parameterfiles = None
</span><span class="miss">        try:
</span><span class="miss">            self.checkpath()
</span><span class="miss">        except IOError:
</span><span class="miss">            pass
</span><span class="noop">        else:
</span><span class="miss">            self.loadinfo()
</span><span class="miss">            self.applyinfo()
</span><span class="miss">            self.clearinfo()
</span><span class="noop">
</span><span class="hit">    def _getpath(self):
</span><span class="miss">        return os.path.abspath(pub.projectname+&#39;.py&#39;)
</span><span class="hit">    path = property(_getpath)
</span><span class="noop">
</span><span class="hit">    def checkpath(self):
</span><span class="miss">        if not os.path.exists(self.path):
</span><span class="miss">            raise IOError(&#39;The required project main file `%s` does not exist.&#39;
</span><span class="noop">                          % self.path)
</span><span class="noop">
</span><span class="hit">    def loadinfo(self):
</span><span class="noop">        &#34;&#34;&#34;Load general information from the project&#39;s main file.&#34;&#34;&#34;
</span><span class="miss">        try:
</span><span class="miss">            with open(self.path) as file_:
</span><span class="miss">                code = compile(file_.read(), self.path, &#39;exec&#39;)
</span><span class="miss">                exec(code, {}, self.info)
</span><span class="miss">        except Exception:
</span><span class="miss">            prefix = (&#39;While trying to load the general project settings &#39;
</span><span class="noop">                      &#39;from `%s`&#39; % self.path)
</span><span class="miss">            objecttools.augmentexcmessage(prefix)
</span><span class="noop">
</span><span class="hit">    def clearinfo(self):
</span><span class="miss">        self.info = {}
</span><span class="noop">
</span><span class="hit">    def applyinfo(self):
</span><span class="miss">        self.timegrids2pub()
</span><span class="miss">        self.getmanagers()
</span><span class="noop">
</span><span class="hit">    def timegrids2pub(self):
</span><span class="miss">        selection = [value for value in self.info.values()
</span><span class="noop">                     if isinstance(value, timetools.Timegrids)]
</span><span class="miss">        if len(selection) != 1:
</span><span class="miss">            print(self.info)
</span><span class="miss">            raise ImportError(&#39;The main project file `%s` must define exactly &#39;
</span><span class="noop">                              &#39;1 `Timegrids` object; %d objects are defined &#39;
</span><span class="noop">                              &#39;instead.&#39; % (self.path, len(selection)))
</span><span class="noop">        else:
</span><span class="miss">            pub.timegrids = selection[0]
</span><span class="noop">
</span><span class="hit">    def getmanagers(self):
</span><span class="miss">        for FileClass in (NetworkManager, ControlManager,
</span><span class="noop">                          SequenceManager, ConditionManager):
</span><span class="miss">            selection = [value for value in self.info.values()
</span><span class="noop">                         if isinstance(value, FileClass)]
</span><span class="miss">            if len(selection) &gt; 1:
</span><span class="miss">                raise ImportError(&#39;The main project file `%s` must not define &#39;
</span><span class="noop">                                  &#39;more then one `%s` objects but %d objects &#39;
</span><span class="noop">                                  &#39;are defined.&#39;
</span><span class="noop">                                  % (self.path, FileClass.__name__,
</span><span class="noop">                                     len(selection)))
</span><span class="miss">            elif len(selection) == 1:
</span><span class="miss">                setattr(self, FileClass.__name__.lower(), selection[0])
</span><span class="noop">            else:
</span><span class="miss">                setattr(self, FileClass.__name__.lower(), FileClass())
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class NetworkManager(object):
</span><span class="noop">    &#34;&#34;&#34;Manager for network files.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="miss">        self._BASEDIRECTORY = &#39;network&#39;
</span><span class="miss">        self.directory = pub.projectname
</span><span class="noop">
</span><span class="hit">    def _getbasepath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path pointing to all network directories.&#34;&#34;&#34;
</span><span class="miss">        return os.path.abspath(self._BASEDIRECTORY)
</span><span class="noop">
</span><span class="hit">    basepath = property(_getbasepath)
</span><span class="noop">
</span><span class="hit">    def _getdirectory(self):
</span><span class="noop">        &#34;&#34;&#34;Directory containing the network files.&#34;&#34;&#34;
</span><span class="miss">        return self._subdirectory
</span><span class="noop">
</span><span class="hit">    def _setdirectory(self, subdirectory):
</span><span class="miss">        directory = os.path.join(self.basepath, subdirectory)
</span><span class="miss">        if not os.path.exists(directory):
</span><span class="miss">            raise IOError(&#39;A directory `%s` within the network base path &#39;
</span><span class="noop">                          &#39;`%s` does not exist.&#39;
</span><span class="noop">                          % (subdirectory, self.basepath))
</span><span class="miss">        self._subdirectory = str(subdirectory)
</span><span class="noop">
</span><span class="hit">    directory = property(_getdirectory, _setdirectory)
</span><span class="noop">
</span><span class="hit">    def _getdirpath(self):
</span><span class="noop">        &#34;&#34;&#34;Complete path of the directory containing the network files.&#34;&#34;&#34;
</span><span class="miss">        return os.path.join(self.basepath, self.directory)
</span><span class="noop">
</span><span class="hit">    dirpath = property(_getdirpath)
</span><span class="noop">
</span><span class="hit">    def _getfilenames(self):
</span><span class="noop">        &#34;&#34;&#34;Names of the network files.&#34;&#34;&#34;
</span><span class="miss">        return [fn for fn in os.listdir(self.dirpath)
</span><span class="noop">                if (fn.endswith(&#39;.py&#39;) and not fn.startswith(&#39;_&#39;))]
</span><span class="noop">
</span><span class="hit">    filenames = property(_getfilenames)
</span><span class="noop">
</span><span class="hit">    def _getfilepaths(self):
</span><span class="noop">        &#34;&#34;&#34;Complete paths of the defined networks files.&#34;&#34;&#34;
</span><span class="miss">        root = os.path.join(self.basepath, self.directory)
</span><span class="miss">        return [os.path.join(root, fn) for fn in self.filenames]
</span><span class="noop">
</span><span class="hit">    filepaths = property(_getfilepaths)
</span><span class="noop">
</span><span class="hit">    def load(self):
</span><span class="noop">        &#34;&#34;&#34;Load nodes and elements from all network files and return them in
</span><span class="noop">        a :class:`~hydpy.selectiontools.Selections` instance.  Each single
</span><span class="noop">        network file defines a seperate
</span><span class="noop">        :class:`~hydpy.selectiontools.Selection` instance.  Additionally, all
</span><span class="noop">        elements and nodes are bundled in a selection named `complete`.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        selections = selectiontools.Selections()
</span><span class="miss">        for (filename, path) in zip(self.filenames, self.filepaths):
</span><span class="noop">            # Ensure both `Node` and `Element`start with a `fresh` memory.
</span><span class="miss">            devicetools.Node.gathernewnodes()
</span><span class="miss">            devicetools.Element.gathernewelements()
</span><span class="miss">            info = {}
</span><span class="miss">            try:
</span><span class="miss">                with open(path) as file_:
</span><span class="miss">                    code = compile(file_.read(), path, &#39;exec&#39;)
</span><span class="miss">                    exec(code, {}, info)
</span><span class="miss">            except Exception:
</span><span class="miss">                prefix = &#39;While trying to load the network file `%s`&#39; % path
</span><span class="miss">                objecttools.augmentexcmessage(prefix)
</span><span class="miss">            try:
</span><span class="miss">                selections += selectiontools.Selection(
</span><span class="noop">                                           filename.split(&#39;.&#39;)[0],
</span><span class="noop">                                           info[&#39;Node&#39;].gathernewnodes(),
</span><span class="noop">                                           info[&#39;Element&#39;].gathernewelements())
</span><span class="noop">
</span><span class="miss">            except KeyError as exc:
</span><span class="miss">                KeyError(&#39;The class `%s` cannot be loaded from the network &#39;
</span><span class="noop">                         &#39;file `%s`.  Please refer to the HydPy documentation &#39;
</span><span class="noop">                         &#39;on how to prepare network files properly.&#39;
</span><span class="noop">                         % (exc.args[0], filename))
</span><span class="miss">        selections += selectiontools.Selection(
</span><span class="noop">                                          &#39;complete&#39;,
</span><span class="noop">                                          info[&#39;Node&#39;].registerednodes(),
</span><span class="noop">                                          info[&#39;Element&#39;].registeredelements())
</span><span class="miss">        return selections
</span><span class="noop">
</span><span class="hit">    def save(self, selections, overwrite=False):
</span><span class="noop">        &#34;&#34;&#34;Save the nodes and elements from each
</span><span class="noop">        :class:`~hydpy.selectiontools.Selection` object contained within the
</span><span class="noop">        given :class:`~hydpy.selectiontools.Selections` instance to a seperate
</span><span class="noop">        network file of the same name.  Set `overwrite` to `True`, if you
</span><span class="noop">        want to overwrite already existing network files.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        selections = selectiontools.Selections(selections)
</span><span class="miss">        for (name, selection) in selections:
</span><span class="miss">            if name == &#39;complete&#39;:
</span><span class="miss">                continue
</span><span class="miss">            path = os.path.join(self.dirpath, name+&#39;.py&#39;)
</span><span class="miss">            if os.path.exists(path) and not overwrite:
</span><span class="miss">                warnings.warn(&#39;The path `%s` does already exist, selection &#39;
</span><span class="noop">                              &#39;`%s` cannot be saved.  Please select another &#39;
</span><span class="noop">                              &#39;network directory or set the `overwrite` flag &#39;
</span><span class="noop">                              &#39;to `True`&#39; % (path, name))
</span><span class="noop">            else:
</span><span class="miss">                with open(path, &#39;w&#39;) as file_:
</span><span class="miss">                    file_.write(&#39;from hydpy import *\n\n&#39;)
</span><span class="miss">                    file_.write(repr(selection.elements))
</span><span class="noop">
</span><span class="hit">    def delete(self, *selections):
</span><span class="noop">        &#34;&#34;&#34;Delete network files.  One or more filenames and/or
</span><span class="noop">        :class:`~hydpy.selectiontools.Selection` instances can serve as
</span><span class="noop">        function arguments.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        for selection in selections:
</span><span class="miss">            name = str(selection)
</span><span class="miss">            if not name.endswith(&#39;.py&#39;):
</span><span class="miss">                name += &#39;.py&#39;
</span><span class="miss">            path = os.path.join(self.dirpath, name)
</span><span class="miss">            try:
</span><span class="miss">                os.remove(path)
</span><span class="miss">            except EnvironmentError:
</span><span class="miss">                exception, message = sys.exc_info()[:2]
</span><span class="miss">                exception = str(exception)[:-2].split(&#39;.&#39;)[-1]
</span><span class="miss">                warnings.warn(&#39;: &#39;.join((exception, str(message))))
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ControlManager(object):
</span><span class="noop">    &#34;&#34;&#34;Manager for control parameter files.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop">    # The following file path to content mapping is used to circumvent reading
</span><span class="noop">    # the same secondary control parameter file from disk multiple times.
</span><span class="hit">    _registry = {}
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="miss">        self._BASEDIRECTORY = &#39;control&#39;
</span><span class="miss">        self._projectdirectory = pub.projectname
</span><span class="miss">        self._controldirectory = None
</span><span class="noop">
</span><span class="hit">    def _getbasepath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path pointing to all control directories.&#34;&#34;&#34;
</span><span class="miss">        return os.path.abspath(self._BASEDIRECTORY)
</span><span class="noop">
</span><span class="hit">    basepath = property(_getbasepath)
</span><span class="noop">
</span><span class="hit">    def _getprojectdirectory(self):
</span><span class="noop">        &#34;&#34;&#34;Folder containing the control directories of the current project.&#34;&#34;&#34;
</span><span class="miss">        return self._projectdirectory
</span><span class="noop">
</span><span class="hit">    def _setprojectdirectory(self, directory):
</span><span class="miss">        directory = str(directory)
</span><span class="miss">        directory = os.path.join(self.basepath, directory)
</span><span class="miss">        if not os.path.exists(directory):
</span><span class="miss">            raise IOError(&#39;Path `%s` does not contain a control directory &#39;
</span><span class="noop">                          &#39;named `%s`.&#39; % (self.basepath, directory))
</span><span class="miss">        self._projectdirectory = directory
</span><span class="noop">
</span><span class="hit">    projectdirectory = property(_getprojectdirectory, _setprojectdirectory)
</span><span class="noop">
</span><span class="hit">    def _getprojectpath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path of the project directory.&#34;&#34;&#34;
</span><span class="miss">        return os.path.join(self.basepath, self.projectdirectory)
</span><span class="noop">
</span><span class="hit">    projectpath = property(_getprojectpath)
</span><span class="noop">
</span><span class="hit">    def _getcontroldirectories(self):
</span><span class="noop">        &#34;&#34;&#34;Folders containing the control files of different parameter sets.&#34;&#34;&#34;
</span><span class="miss">        directories = FolderShow()
</span><span class="miss">        for directory in os.listdir(self.projectpath):
</span><span class="miss">            if not directory.startswith(&#39;_&#39;):
</span><span class="miss">                path = os.path.join(self.projectpath, directory)
</span><span class="miss">                if os.path.isdir(path):
</span><span class="miss">                    directories.add(directory)
</span><span class="miss">        return directories
</span><span class="noop">
</span><span class="hit">    controldirectories = property(_getcontroldirectories)
</span><span class="noop">
</span><span class="hit">    def _getcontrolpaths(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute paths of the control directories.&#34;&#34;&#34;
</span><span class="miss">        paths = FolderShow()
</span><span class="miss">        for (directory, dummy) in self.controldirectories:
</span><span class="miss">            paths.add(directory, os.path.join(self.projectpath, directory))
</span><span class="miss">        return paths
</span><span class="noop">
</span><span class="hit">    controlpaths = property(_getcontrolpaths)
</span><span class="noop">
</span><span class="hit">    def _getcontroldirectory(self):
</span><span class="noop">        &#34;&#34;&#34;The selected (or the only selectable) control directory&#34;&#34;&#34;
</span><span class="miss">        directories = self.controldirectories
</span><span class="miss">        if self._controldirectory is not None:
</span><span class="miss">            try:
</span><span class="miss">                return getattr(directories, self._controldirectory)
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise IOError(&#39;The project path `%s` does not contain the&#39;
</span><span class="noop">                              &#39;specified control directory `%s`.&#39;
</span><span class="noop">                              % (self.projectpath, self._controldirectory))
</span><span class="miss">        elif len(directories) == 1:
</span><span class="miss">            return directories[0]
</span><span class="miss">        elif len(directories) == 0:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain any &#39;
</span><span class="noop">                          &#39;control directories.&#39; % self.projectpath)
</span><span class="miss">        try:
</span><span class="miss">            return directories.default
</span><span class="miss">        except AttributeError:
</span><span class="miss">            raise IOError(&#39;The project path `%s` contains multiple control&#39;
</span><span class="noop">                          &#39;directories, but none is named `default`.  &#39;
</span><span class="noop">                          &#39;Please specify the control directory to be &#39;
</span><span class="noop">                          &#39;worked with manually.&#39; % self.projectpath)
</span><span class="noop">
</span><span class="hit">    def _setcontroldirectory(self, directory):
</span><span class="miss">        directory = str(directory)
</span><span class="miss">        path = os.path.join(self.projectpath, directory)
</span><span class="miss">        if os.path.exists(path):
</span><span class="miss">            self._controldirectory = directory
</span><span class="noop">        else:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain a &#39;
</span><span class="noop">                          &#39;control directory named `%s`.&#39;
</span><span class="noop">                          % (self.projectpath, directory))
</span><span class="noop">
</span><span class="hit">    def _delcontroldirectory(self):
</span><span class="miss">        self._controldirectory = None
</span><span class="noop">
</span><span class="hit">    controldirectory = property(_getcontroldirectory, _setcontroldirectory,
</span><span class="noop">                                _delcontroldirectory)
</span><span class="noop">
</span><span class="hit">    def _getcontrolpath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute paths of the selected control directory.&#34;&#34;&#34;
</span><span class="miss">        return os.path.join(self.projectpath, self.controldirectory)
</span><span class="noop">
</span><span class="hit">    controlpath = property(_getcontrolpath)
</span><span class="noop">
</span><span class="hit">    def loadfile(self, filename):
</span><span class="noop">        &#34;&#34;&#34;Return the namespace of the given file (and eventually of its
</span><span class="noop">        subfile) as a :class:`dict`.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * filename (:class:`str`): Any object returning a valid filename
</span><span class="noop">              with or without extension.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        workingpath = os.path.abspath(os.curdir)
</span><span class="miss">        try:
</span><span class="miss">            os.chdir(self.controlpath)
</span><span class="miss">        except OSError:
</span><span class="miss">            raise IOError(&#39;The specified control path `%s` does not exist.&#39;
</span><span class="noop">                          % self.controlpath)
</span><span class="noop">        else:
</span><span class="miss">            info = {}
</span><span class="miss">            self.read2dict(filename, info)
</span><span class="miss">            return info
</span><span class="noop">        finally:
</span><span class="miss">            self._registry.clear()
</span><span class="miss">            os.chdir(workingpath)
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def read2dict(cls, path, info):
</span><span class="noop">        &#34;&#34;&#34;Reads the control parameters of the given path (and its subpaths
</span><span class="noop">        where appropriate) and stores it in the given :class:`dict` `info`.
</span><span class="noop">
</span><span class="noop">        Arguments:
</span><span class="noop">            * path (:class:`str`): Any object returning a valid path
</span><span class="noop">              with or without extension.
</span><span class="noop">            * info (:class:`dict`): Target dictionary.
</span><span class="noop">
</span><span class="noop">        Note that the :class:`dict` `info` can be used to feed information
</span><span class="noop">        into the execution of control files.  Use this function only if you
</span><span class="noop">        are completely sure on how the control parameter import of HydPy
</span><span class="noop">        works.  Otherwise, you should most probably prefer to use
</span><span class="noop">        :func:`loadfile` or :func:`loadfiles`.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        path = str(path)
</span><span class="miss">        if not path.endswith(&#39;.py&#39;):
</span><span class="miss">            path += &#39;.py&#39;
</span><span class="miss">        try:
</span><span class="miss">            if path not in cls._registry:
</span><span class="miss">                with open(path) as file_:
</span><span class="miss">                    cls._registry[path] = file_.read()
</span><span class="miss">            exec(cls._registry[path], {}, info)
</span><span class="miss">        except BaseException:
</span><span class="miss">            prefix = &#39;While trying to load the control file `%s`&#39; % path
</span><span class="miss">            objecttools.augmentexcmessage(prefix)
</span><span class="miss">        if &#39;model&#39; not in info:
</span><span class="miss">            raise IOError(&#39;Model parameters cannot be loaded from control &#39;
</span><span class="noop">                          &#39;file `%s`.  Please refer to the HydPy &#39;
</span><span class="noop">                          &#39;documentation on how to prepare control files &#39;
</span><span class="noop">                          &#39;properly.&#39; % path)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FolderShow(object):
</span><span class="noop">
</span><span class="hit">    def __init__(self, *args, **kwargs):
</span><span class="miss">        for arg in args:
</span><span class="miss">            self.add(arg)
</span><span class="miss">        for (key, value) in kwargs.items():
</span><span class="miss">            self.add(key, value)
</span><span class="noop">
</span><span class="hit">    def add(self, directory, path=None):
</span><span class="miss">        if path is None:
</span><span class="miss">            path = directory
</span><span class="miss">        try:
</span><span class="miss">            exec(&#39;self.%s = r&#34;%s&#34;&#39; % (directory, path))
</span><span class="miss">        except BaseException:
</span><span class="miss">            raise IOError(&#39;The directory name `%s` cannot be handled as a &#39;
</span><span class="noop">                          &#39;variable name.  Please avoid arithmetic operators &#39;
</span><span class="noop">                          &#39;like `-`, prefixed numbers...&#39; % directory)
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="miss">        return vars(self).items()
</span><span class="noop">
</span><span class="hit">    def __getitem__(self, key):
</span><span class="miss">        return sorted(vars(self).values())[key]
</span><span class="noop">
</span><span class="hit">    def __len__(self):
</span><span class="miss">        return len(vars(self))
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="miss">        if not len(self):
</span><span class="miss">            return &#39;Folders()&#39;
</span><span class="noop">        else:
</span><span class="miss">            args, kwargs = [], []
</span><span class="miss">            for (idx, (key, value)) in enumerate(self):
</span><span class="miss">                if key == value:
</span><span class="miss">                    args.append(key)
</span><span class="noop">                else:
</span><span class="miss">                    kwargs.append(&#39;%s=%s&#39; % (key, value))
</span><span class="miss">            lines = [&#39;           %s,&#39; % arg for arg in (args + kwargs)]
</span><span class="miss">            lines[0] = &#39;FolderShow(&#39; + lines[0][11:]
</span><span class="miss">            lines[-1] = lines[-1][:-1] + &#39;)&#39;
</span><span class="miss">            return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class SequenceManager(object):
</span><span class="noop">    &#34;&#34;&#34;Manager for sequence files.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    _supportedmodes = (&#39;npy&#39;, &#39;asc&#39;)
</span><span class="noop">
</span><span class="hit">    def __init__(self, projectdirectory=None, inputdirectory=None,
</span><span class="noop">                 outputdirectory=None, nodedirectory=None, tempdirectory=None,
</span><span class="noop">                 inputfiletype=None, outputfiletype=None, nodefiletype=None):
</span><span class="hit">        self._BASEDIRECTORY = &#39;sequences&#39;
</span><span class="hit">        if projectdirectory:
</span><span class="miss">            self.projectdirectory = projectdirectory
</span><span class="noop">        else:
</span><span class="hit">            self._projectdirectory = pub.projectname
</span><span class="hit">        if inputdirectory:
</span><span class="miss">            self.inputdirectory = inputdirectory
</span><span class="noop">        else:
</span><span class="hit">            self._inputdirectory = None
</span><span class="hit">        if outputdirectory:
</span><span class="miss">            self.outputdirectory = outputdirectory
</span><span class="noop">        else:
</span><span class="hit">            self._outputdirectory = None
</span><span class="hit">        if nodedirectory:
</span><span class="miss">            self.nodedirectory = nodedirectory
</span><span class="noop">        else:
</span><span class="hit">            self._nodedirectory = None
</span><span class="hit">        if tempdirectory:
</span><span class="miss">            self.tempdirectory = tempdirectory
</span><span class="noop">        else:
</span><span class="hit">            self._tempdirectory = None
</span><span class="hit">        if inputfiletype:
</span><span class="miss">            self.inputfiletype = inputfiletype
</span><span class="noop">        else:
</span><span class="hit">            self._inputfiletype = &#39;npy&#39;
</span><span class="hit">        if outputfiletype:
</span><span class="miss">            self.outputfiletype = outputfiletype
</span><span class="noop">        else:
</span><span class="hit">            self._outputfiletype = &#39;npy&#39;
</span><span class="hit">        if outputfiletype:
</span><span class="miss">            self.outputfiletype = outputfiletype
</span><span class="noop">        else:
</span><span class="hit">            self._outputfiletype = &#39;npy&#39;
</span><span class="hit">        if nodefiletype:
</span><span class="miss">            self.nodefiletype = nodefiletype
</span><span class="noop">        else:
</span><span class="hit">            self._nodefiletype = &#39;npy&#39;
</span><span class="hit">        self._inputoverwrite = False
</span><span class="hit">        self._outputoverwrite = False
</span><span class="hit">        self._simoverwrite = False
</span><span class="hit">        self._obsoverwrite = False
</span><span class="noop">
</span><span class="hit">    def _getbasepath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path pointing to all sequence directories.&#34;&#34;&#34;
</span><span class="miss">        return os.path.abspath(self._BASEDIRECTORY)
</span><span class="hit">    basepath = property(_getbasepath)
</span><span class="noop">
</span><span class="hit">    def _getprojectdirectory(self):
</span><span class="noop">        &#34;&#34;&#34;Folder containing the file directories of the current project.&#34;&#34;&#34;
</span><span class="miss">        return self._projectdirectory
</span><span class="noop">
</span><span class="hit">    def _setprojectdirectory(self, directory):
</span><span class="miss">        directory = str(directory)
</span><span class="miss">        directory = os.path.join(self.basepath, directory)
</span><span class="miss">        if not os.path.exists(directory):
</span><span class="miss">            raise IOError(&#39;Path `%s` does not contain a directory named `%s`.&#39;
</span><span class="noop">                          % (self.basepath, directory))
</span><span class="miss">        self._projectdirectory = directory
</span><span class="noop">
</span><span class="hit">    projectdirectory = property(_getprojectdirectory, _setprojectdirectory)
</span><span class="noop">
</span><span class="hit">    def _getprojectpath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path of the project directory.&#34;&#34;&#34;
</span><span class="miss">        return os.path.join(self.basepath, self.projectdirectory)
</span><span class="noop">
</span><span class="hit">    projectpath = property(_getprojectpath)
</span><span class="noop">
</span><span class="hit">    def _getsequencedirectories(self):
</span><span class="noop">        &#34;&#34;&#34;Folders containing the different input/output/temp sequences.&#34;&#34;&#34;
</span><span class="miss">        directories = FolderShow()
</span><span class="miss">        for directory in os.listdir(self.projectpath):
</span><span class="miss">            if not directory.startswith(&#39;_&#39;):
</span><span class="miss">                path = os.path.join(self.projectpath, directory)
</span><span class="miss">                if os.path.isdir(path):
</span><span class="miss">                    directories.add(directory)
</span><span class="miss">        return directories
</span><span class="noop">
</span><span class="hit">    sequencedirectories = property(_getsequencedirectories)
</span><span class="noop">
</span><span class="hit">    def _getsequencepaths(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute paths of the sequence directories.&#34;&#34;&#34;
</span><span class="miss">        paths = FolderShow()
</span><span class="miss">        for (key, value) in self.sequencedirectories:
</span><span class="miss">            paths.add(key, os.path.join(self.projectpath, key))
</span><span class="miss">        return paths
</span><span class="noop">
</span><span class="hit">    sequencepaths = property(_getsequencepaths)
</span><span class="noop">
</span><span class="hit">    def _getinputdirectory(self):
</span><span class="noop">        &#34;&#34;&#34;The selected (or the only selectable) input sequence directory.&#34;&#34;&#34;
</span><span class="miss">        directories = self.sequencedirectories
</span><span class="miss">        if self._inputdirectory is not None:
</span><span class="miss">            try:
</span><span class="miss">                return getattr(directories, self._inputdirectory)
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise IOError(&#39;The project path `%s` does not contain the&#39;
</span><span class="noop">                              &#39;specified input sequence directory `%s`.&#39;
</span><span class="noop">                              % (self.projectpath, self._inputdirectory))
</span><span class="miss">        elif len(directories) == 1:
</span><span class="miss">            return directories[0]
</span><span class="miss">        elif len(directories) == 0:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain any &#39;
</span><span class="noop">                          &#39;sequence directories.&#39; % self.projectpath)
</span><span class="noop">        else:
</span><span class="miss">            try:
</span><span class="miss">                return directories.input
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise IOError(&#39;The project path `%s` contains multiple &#39;
</span><span class="noop">                              &#39;sequence directories, but none is named &#39;
</span><span class="noop">                              &#39;`input`.  Please specify the input sequence &#39;
</span><span class="noop">                              &#39;directory to be worked with manually.&#39;
</span><span class="noop">                              % self.projectpath)
</span><span class="noop">
</span><span class="hit">    def _setinputdirectory(self, directory):
</span><span class="miss">        directory = str(directory)
</span><span class="miss">        path = os.path.join(self.projectpath, directory)
</span><span class="miss">        if os.path.exists(path):
</span><span class="miss">            self._inputdirectory = directory
</span><span class="noop">        else:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain sequence &#39;
</span><span class="noop">                          &#39;directory named `%s`.&#39;
</span><span class="noop">                          % (self.projectpath, directory))
</span><span class="noop">
</span><span class="hit">    def _delinputdirectory(self):
</span><span class="miss">        self._inputdirectory = None
</span><span class="noop">
</span><span class="hit">    inputdirectory = property(_getinputdirectory, _setinputdirectory,
</span><span class="noop">                              _delinputdirectory)
</span><span class="noop">
</span><span class="hit">    def _getoutputdirectory(self):
</span><span class="noop">        &#34;&#34;&#34;The selected (or the only selectable) output sequence directory.&#34;&#34;&#34;
</span><span class="miss">        directories = self.sequencedirectories
</span><span class="miss">        if self._outputdirectory is not None:
</span><span class="miss">            try:
</span><span class="miss">                return getattr(directories, self._outputdirectory)
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise IOError(&#39;The project path `%s` does not contain the&#39;
</span><span class="noop">                              &#39;specified output sequence directory `%s`.&#39;
</span><span class="noop">                              % (self.projectpath, self._outputdirectory))
</span><span class="miss">        elif len(directories) == 1:
</span><span class="miss">            return directories[0]
</span><span class="miss">        elif len(directories) == 0:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain any &#39;
</span><span class="noop">                          &#39;sequence directories.&#39; % self.projectpath)
</span><span class="noop">        else:
</span><span class="miss">            try:
</span><span class="miss">                return directories.output
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise IOError(&#39;The project path `%s` contains multiple &#39;
</span><span class="noop">                              &#39;sequence directories, but none is named &#39;
</span><span class="noop">                              &#39;`output`.  Please specify the sequence &#39;
</span><span class="noop">                              &#39;directory to be worked with manually.&#39;
</span><span class="noop">                              % self.projectpath)
</span><span class="noop">
</span><span class="hit">    def _setoutputdirectory(self, directory):
</span><span class="miss">        directory = str(directory)
</span><span class="miss">        path = os.path.join(self.projectpath, directory)
</span><span class="miss">        if os.path.exists(path):
</span><span class="miss">            self._outputdirectory = directory
</span><span class="noop">        else:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain sequence &#39;
</span><span class="noop">                          &#39;directory named `%s`.&#39;
</span><span class="noop">                          % (self.projectpath, directory))
</span><span class="noop">
</span><span class="hit">    def _deloutputdirectory(self):
</span><span class="miss">        self._outputdirectory = None
</span><span class="noop">
</span><span class="hit">    outputdirectory = property(_getoutputdirectory, _setoutputdirectory,
</span><span class="noop">                               _deloutputdirectory)
</span><span class="noop">
</span><span class="hit">    def _getnodedirectory(self):
</span><span class="noop">        &#34;&#34;&#34;The selected (or the only selectable) node sequence directory.&#34;&#34;&#34;
</span><span class="miss">        directories = self.sequencedirectories
</span><span class="miss">        if self._nodedirectory is not None:
</span><span class="miss">            try:
</span><span class="miss">                return getattr(directories, self._nodedirectory)
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise IOError(&#39;The project path `%s` does not contain the&#39;
</span><span class="noop">                              &#39;specified node sequence directory `%s`.&#39;
</span><span class="noop">                              % (self.projectpath, self._nodedirectory))
</span><span class="miss">        elif len(directories) == 1:
</span><span class="miss">            return directories[0]
</span><span class="miss">        elif len(directories) == 0:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain any &#39;
</span><span class="noop">                          &#39;sequence directories.&#39; % self.projectpath)
</span><span class="noop">        else:
</span><span class="miss">            try:
</span><span class="miss">                return directories.node
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise IOError(&#39;The project path `%s` contains multiple &#39;
</span><span class="noop">                              &#39;sequence directories, but none is named &#39;
</span><span class="noop">                              &#39;`node`.  Please specify the node sequence &#39;
</span><span class="noop">                              &#39;directory to be worked with manually.&#39;
</span><span class="noop">                              % self.projectpath)
</span><span class="noop">
</span><span class="hit">    def _setnodedirectory(self, directory):
</span><span class="miss">        directory = str(directory)
</span><span class="miss">        path = os.path.join(self.projectpath, directory)
</span><span class="miss">        if os.path.exists(path):
</span><span class="miss">            self._nodedirectory = directory
</span><span class="noop">        else:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain sequence &#39;
</span><span class="noop">                          &#39;directory named `%s`.&#39;
</span><span class="noop">                          % (self.projectpath, directory))
</span><span class="noop">
</span><span class="hit">    def _delnodedirectory(self):
</span><span class="miss">        self._nodedirectory = None
</span><span class="noop">
</span><span class="hit">    nodedirectory = property(_getnodedirectory, _setnodedirectory,
</span><span class="noop">                             _delnodedirectory)
</span><span class="noop">
</span><span class="hit">    def _gettempdirectory(self):
</span><span class="noop">        &#34;&#34;&#34;The selected (or the only selectable) temporary sequence directory.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        directories = self.sequencedirectories
</span><span class="miss">        if self._tempdirectory is not None:
</span><span class="miss">            try:
</span><span class="miss">                return getattr(directories, self._tempdirectory)
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise IOError(&#39;The project path `%s` does not contain the&#39;
</span><span class="noop">                              &#39;specified temporary sequence directory `%s`.&#39;
</span><span class="noop">                              % (self.projectpath, self._tempdirectory))
</span><span class="miss">        elif len(directories) == 1:
</span><span class="miss">            return directories[0]
</span><span class="miss">        elif len(directories) == 0:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain any &#39;
</span><span class="noop">                          &#39;sequence directories.&#39; % self.projectpath)
</span><span class="noop">        else:
</span><span class="miss">            try:
</span><span class="miss">                return directories.temp
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise IOError(&#39;The project path `%s` contains multiple &#39;
</span><span class="noop">                              &#39;sequence directories, but none is named &#39;
</span><span class="noop">                              &#39;`temp`.  Please specify the temporary sequence &#39;
</span><span class="noop">                              &#39;directory to be worked with manually.&#39;
</span><span class="noop">                              % self.projectpath)
</span><span class="noop">
</span><span class="hit">    def _settempdirectory(self, directory):
</span><span class="miss">        directory = str(directory)
</span><span class="miss">        path = os.path.join(self.projectpath, directory)
</span><span class="miss">        if os.path.exists(path):
</span><span class="miss">            self._tempdirectory = directory
</span><span class="noop">        else:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain sequence &#39;
</span><span class="noop">                          &#39;directory named `%s`.&#39;
</span><span class="noop">                          % (self.projectpath, directory))
</span><span class="noop">
</span><span class="hit">    def _deltempdirectory(self):
</span><span class="miss">        self._tempdirectory = None
</span><span class="noop">
</span><span class="hit">    tempdirectory = property(_gettempdirectory, _settempdirectory,
</span><span class="noop">                             _deltempdirectory)
</span><span class="noop">
</span><span class="hit">    def _getinputpath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute paths of the selected input sequence directory.&#34;&#34;&#34;
</span><span class="miss">        return os.path.join(self.projectpath, self.inputdirectory)
</span><span class="hit">    inputpath = property(_getinputpath)
</span><span class="noop">
</span><span class="hit">    def _getoutputpath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute paths of the selected output sequence directory.&#34;&#34;&#34;
</span><span class="miss">        return os.path.join(self.projectpath, self.outputdirectory)
</span><span class="hit">    outputpath = property(_getoutputpath)
</span><span class="noop">
</span><span class="hit">    def _getnodepath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute paths of the selected node sequence directory.&#34;&#34;&#34;
</span><span class="miss">        return os.path.join(self.projectpath, self.nodedirectory)
</span><span class="hit">    nodepath = property(_getnodepath)
</span><span class="noop">
</span><span class="hit">    def _gettemppath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute paths of the selected temporary sequence directory.&#34;&#34;&#34;
</span><span class="miss">        return os.path.join(self.projectpath, self.tempdirectory)
</span><span class="noop">
</span><span class="hit">    temppath = property(_gettemppath)
</span><span class="noop">
</span><span class="hit">    def _getinputfiletype(self):
</span><span class="noop">        &#34;&#34;&#34;File type of the external input files.&#34;&#34;&#34;
</span><span class="miss">        return self._inputfiletype
</span><span class="noop">
</span><span class="hit">    def _setinputfiletype(self, inputfiletype):
</span><span class="miss">        inputfiletype = str(inputfiletype)
</span><span class="miss">        if inputfiletype in self._supportedmodes:
</span><span class="miss">            self._inputfiletype = inputfiletype
</span><span class="noop">        else:
</span><span class="miss">            raise NotImplementedError(&#39;The given input file type `%s` is not &#39;
</span><span class="noop">                                      &#39;implemented yet.  Please choose one &#39;
</span><span class="noop">                                      &#39;of the following file types: %s.&#39;
</span><span class="noop">                                      % (inputfiletype, self._supportedmodes))
</span><span class="noop">
</span><span class="hit">    inputfiletype = property(_getinputfiletype, _setinputfiletype)
</span><span class="noop">
</span><span class="hit">    def _getoutputfiletype(self):
</span><span class="noop">        &#34;&#34;&#34;File type of the external output files.&#34;&#34;&#34;
</span><span class="miss">        return self._outputfiletype
</span><span class="noop">
</span><span class="hit">    def _setoutputfiletype(self, outputfiletype):
</span><span class="hit">        outputfiletype = str(outputfiletype)
</span><span class="hit">        if outputfiletype in self._supportedmodes:
</span><span class="miss">            self._outputfiletype = outputfiletype
</span><span class="noop">        else:
</span><span class="hit">            raise NotImplementedError(&#39;The given output file type `%s` is not &#39;
</span><span class="noop">                                      &#39;implemented yet.  Please choose one &#39;
</span><span class="noop">                                      &#39;of the following file types: %s.&#39;
</span><span class="noop">                                      % (outputfiletype, self._supportedmodes))
</span><span class="noop">
</span><span class="hit">    outputfiletype = property(_getoutputfiletype, _setoutputfiletype)
</span><span class="noop">
</span><span class="hit">    def _getnodefiletype(self):
</span><span class="noop">        &#34;&#34;&#34;File type of the external node files.&#34;&#34;&#34;
</span><span class="miss">        return self._nodefiletype
</span><span class="noop">
</span><span class="hit">    def _setnodefiletype(self, nodefiletype):
</span><span class="miss">        nodefiletype = str(nodefiletype)
</span><span class="miss">        if nodefiletype in self._supportedmodes:
</span><span class="miss">            self._nodefiletype = nodefiletype
</span><span class="noop">        else:
</span><span class="miss">            raise NotImplementedError(&#39;The given node file type `%s` is not &#39;
</span><span class="noop">                                      &#39;implemented yet.  Please choose one &#39;
</span><span class="noop">                                      &#39;of the following file types: %s.&#39;
</span><span class="noop">                                      % (nodefiletype, self._supportedmodes))
</span><span class="noop">
</span><span class="hit">    nodefiletype = property(_getnodefiletype, _setnodefiletype)
</span><span class="noop">
</span><span class="hit">    def _getinputoverwrite(self):
</span><span class="miss">        return self._inputoverwrite
</span><span class="noop">
</span><span class="hit">    def _setinputoverwrite(self, value):
</span><span class="miss">        self._inputoverwrite = bool(value)
</span><span class="noop">
</span><span class="hit">    inputoverwrite = property(_getinputoverwrite, _setinputoverwrite)
</span><span class="noop">
</span><span class="hit">    def _getoutputoverwrite(self):
</span><span class="miss">        return self._outputoverwrite
</span><span class="noop">
</span><span class="hit">    def _setoutputoverwrite(self, value):
</span><span class="miss">        self._outputoverwrite = bool(value)
</span><span class="noop">
</span><span class="hit">    outputoverwrite = property(_getoutputoverwrite, _setoutputoverwrite)
</span><span class="noop">
</span><span class="hit">    def _getsimoverwrite(self):
</span><span class="miss">        return self._simoverwrite
</span><span class="noop">
</span><span class="hit">    def _setsimoverwrite(self, value):
</span><span class="miss">        self._simoverwrite = bool(value)
</span><span class="noop">
</span><span class="hit">    simoverwrite = property(_getsimoverwrite, _setsimoverwrite)
</span><span class="noop">
</span><span class="hit">    def _getobsoverwrite(self):
</span><span class="miss">        return self._obsoverwrite
</span><span class="noop">
</span><span class="hit">    def _setobsoverwrite(self, value):
</span><span class="miss">        self._obsoverwrite = bool(value)
</span><span class="noop">
</span><span class="hit">    obsoverwrite = property(_getobsoverwrite, _setobsoverwrite)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ConditionManager(object):
</span><span class="noop">    &#34;&#34;&#34;Manager for condition files.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="miss">        self._BASEDIRECTORY = &#39;conditions&#39;
</span><span class="miss">        self._projectdirectory = pub.projectname
</span><span class="miss">        self._loaddirectory = None
</span><span class="miss">        self._savedirectory = None
</span><span class="noop">
</span><span class="hit">    def _getbasepath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path pointing to all condition directories.&#34;&#34;&#34;
</span><span class="miss">        return os.path.abspath(self._BASEDIRECTORY)
</span><span class="noop">
</span><span class="hit">    basepath = property(_getbasepath)
</span><span class="noop">
</span><span class="hit">    def _getprojectdirectory(self):
</span><span class="noop">        &#34;&#34;&#34;Folder containing the condition directories of the current
</span><span class="noop">        project.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        return self._projectdirectory
</span><span class="noop">
</span><span class="hit">    def _setprojectdirectory(self, directory):
</span><span class="miss">        directory = str(directory)
</span><span class="miss">        directory = os.path.join(self.basepath, directory)
</span><span class="miss">        if not os.path.exists(directory):
</span><span class="miss">            raise IOError(&#39;Path `%s` does not contain a condition directory &#39;
</span><span class="noop">                          &#39;named `%s`.&#39; % (self.basepath, directory))
</span><span class="miss">        self._projectdirectory = directory
</span><span class="noop">
</span><span class="hit">    projectdirectory = property(_getprojectdirectory, _setprojectdirectory)
</span><span class="noop">
</span><span class="hit">    def _getprojectpath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path of the project directory.&#34;&#34;&#34;
</span><span class="miss">        return os.path.join(self.basepath, self.projectdirectory)
</span><span class="noop">
</span><span class="hit">    projectpath = property(_getprojectpath)
</span><span class="noop">
</span><span class="hit">    def _getconditiondirectories(self):
</span><span class="noop">        &#34;&#34;&#34;Folders containing the condition files of e.g. different time
</span><span class="noop">        points.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        directories = FolderShow()
</span><span class="miss">        for directory in os.listdir(self.projectpath):
</span><span class="miss">            if not directory.startswith(&#39;_&#39;):
</span><span class="miss">                path = os.path.join(self.projectpath, directory)
</span><span class="miss">                if os.path.isdir(path):
</span><span class="miss">                    directories.add(directory)
</span><span class="miss">        return directories
</span><span class="noop">
</span><span class="hit">    conditiondirectories = property(_getconditiondirectories)
</span><span class="noop">
</span><span class="hit">    def _getloaddirectory(self):
</span><span class="noop">        &#34;&#34;&#34;The selected (or only selectable) initial conditions directory&#34;&#34;&#34;
</span><span class="miss">        directories = self.conditiondirectories
</span><span class="miss">        if self._loaddirectory is not None:
</span><span class="miss">            try:
</span><span class="miss">                return getattr(directories, self._loaddirectory)
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise IOError(&#39;The project path `%s` does not contain the&#39;
</span><span class="noop">                              &#39;specified conditions directory `%s`.&#39;
</span><span class="noop">                              % (self.projectpath, self._loaddirectory))
</span><span class="miss">        elif len(directories) == 0:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain any &#39;
</span><span class="noop">                          &#39;conditions directories.&#39; % self.projectpath)
</span><span class="miss">        try:
</span><span class="miss">            string = &#39;init_&#39; + pub.timegrids.sim.firstdate.string(&#39;os&#39;)
</span><span class="miss">        except AttributeError:
</span><span class="miss">            raise IOError(&#39;The project path `%s` contains multiple condition&#39;
</span><span class="noop">                          &#39;directories, and no first simulation date is &#39;
</span><span class="noop">                          &#39;available to determine the relevant one.  &#39;
</span><span class="noop">                          &#39;Please specify the condition directory to be &#39;
</span><span class="noop">                          &#39;worked with manually.&#39; % self.projectpath)
</span><span class="miss">        try:
</span><span class="miss">            return getattr(directories, string)
</span><span class="miss">        except AttributeError:
</span><span class="miss">            raise IOError(&#39;The project path `%s` contains multiple condition&#39;
</span><span class="noop">                          &#39;directories, but none is in accordance with the  &#39;
</span><span class="noop">                          &#39;first simulation date (%s).  Please specify&#39;
</span><span class="noop">                          &#39;the condition directory to be worked with manually.&#39;
</span><span class="noop">                          % (self.projectpath, string))
</span><span class="noop">
</span><span class="hit">    def _setloaddirectory(self, directory):
</span><span class="miss">        directory = str(directory)
</span><span class="miss">        path = os.path.join(self.projectpath, directory)
</span><span class="miss">        if os.path.exists(path):
</span><span class="miss">            self._loaddirectory = directory
</span><span class="noop">        else:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain a &#39;
</span><span class="noop">                          &#39;condition directory named `%s`.&#39;
</span><span class="noop">                          % (self.projectpath, directory))
</span><span class="noop">
</span><span class="hit">    def _delloaddirectory(self):
</span><span class="miss">        self._loaddirectory = None
</span><span class="noop">
</span><span class="hit">    loaddirectory = property(_getloaddirectory, _setloaddirectory,
</span><span class="noop">                             _delloaddirectory)
</span><span class="noop">
</span><span class="hit">    def _getsavedirectory(self):
</span><span class="noop">        &#34;&#34;&#34;The selected (or only selectable) final conditions directory&#34;&#34;&#34;
</span><span class="miss">        directories = self.conditiondirectories
</span><span class="miss">        if self._savedirectory is not None:
</span><span class="miss">            try:
</span><span class="miss">                return getattr(directories, self._savedirectory)
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise IOError(&#39;The project path `%s` does not contain the&#39;
</span><span class="noop">                              &#39;specified conditions directory `%s`.&#39;
</span><span class="noop">                              % (self.projectpath, self._savedirectory))
</span><span class="miss">        elif len(directories) == 0:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain any &#39;
</span><span class="noop">                          &#39;conditions directories.&#39; % self.projectpath)
</span><span class="miss">        try:
</span><span class="miss">            string = &#39;init_&#39; + pub.timegrids.sim.lastdate.string(&#39;os&#39;)
</span><span class="miss">        except AttributeError:
</span><span class="miss">            raise IOError(&#39;The project path `%s` contains multiple condition&#39;
</span><span class="noop">                          &#39;directories, and no last simulation date is &#39;
</span><span class="noop">                          &#39;available to determine the relevant one.  &#39;
</span><span class="noop">                          &#39;Please specify the condition directory to be &#39;
</span><span class="noop">                          &#39;worked with manually.&#39; % self.projectpath)
</span><span class="miss">        try:
</span><span class="miss">            return getattr(directories, string)
</span><span class="miss">        except AttributeError:
</span><span class="miss">            raise IOError(&#39;The project path `%s` contains multiple condition&#39;
</span><span class="noop">                          &#39;directories, but none is in accordance with the  &#39;
</span><span class="noop">                          &#39;last simulation date (%s).  Please specify&#39;
</span><span class="noop">                          &#39;the condition directory to be worked with manually.&#39;
</span><span class="noop">                          % (self.projectpath, string))
</span><span class="noop">
</span><span class="hit">    def _setsavedirectory(self, directory):
</span><span class="miss">        directory = str(directory)
</span><span class="miss">        path = os.path.join(self.projectpath, directory)
</span><span class="miss">        if os.path.exists(path):
</span><span class="miss">            self._savedirectory = directory
</span><span class="noop">        else:
</span><span class="miss">            raise IOError(&#39;The project path `%s` does not contain a &#39;
</span><span class="noop">                          &#39;condition directory named `%s`.&#39;
</span><span class="noop">                          % (self.projectpath, directory))
</span><span class="noop">
</span><span class="hit">    def _delsavedirectory(self):
</span><span class="miss">        self._loaddirectory = None
</span><span class="noop">
</span><span class="hit">    savedirectory = property(_getsavedirectory, _setsavedirectory,
</span><span class="noop">                             _delsavedirectory)
</span><span class="noop">
</span><span class="hit">    def _getloadpath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute paths of the relevant initial condition directory.&#34;&#34;&#34;
</span><span class="miss">        return os.path.join(self.projectpath, self.loaddirectory)
</span><span class="noop">
</span><span class="hit">    loadpath = property(_getloadpath)
</span><span class="noop">
</span><span class="hit">    def _getsavepath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute paths of the relevant final condition directory.&#34;&#34;&#34;
</span><span class="miss">        return os.path.join(self.projectpath, self.savedirectory)
</span><span class="noop">
</span><span class="hit">    savepath = property(_getsavepath)
</span><span class="noop">
</span><span class="hit">    def loadfile(self, filename, dirname=None):
</span><span class="miss">        if not filename.endswith(&#39;.py&#39;):
</span><span class="miss">            filename += &#39;.py&#39;
</span><span class="miss">        if dirname is None:
</span><span class="miss">            dirname = os.path.join(pub.conditionmanager.loadpath)
</span><span class="miss">        filepath = os.path.join(dirname, filename)
</span><span class="miss">        try:
</span><span class="miss">            with open(filepath) as file_:
</span><span class="miss">                return file_.read()
</span><span class="miss">        except BaseException:
</span><span class="miss">            prefix = &#39;While trying to read the conditions file `%s`&#39; % filepath
</span><span class="miss">            objecttools.augmentexcmessage(prefix)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/hydpytools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/hydpytools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import os
</span><span class="hit">import time
</span><span class="hit">import warnings
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy.core import objecttools
</span><span class="hit">from hydpy.core import filetools
</span><span class="hit">from hydpy.core import devicetools
</span><span class="hit">from hydpy.core import selectiontools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class HydPy(object):
</span><span class="noop">    &#34;&#34;&#34;HydPy for single processing.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop">    # A counter for the number of HydPy instances.
</span><span class="hit">    nmb_instances = 0
</span><span class="noop">
</span><span class="hit">    def __init__(self, projectname=None):
</span><span class="noop">
</span><span class="hit">        if pub.options.printprogress:
</span><span class="miss">            print(&#39;HydPy initialization started at&#39;, time.strftime(&#39;%X&#39;))
</span><span class="noop">
</span><span class="noop">        # Increment and check number of HydPy instances.
</span><span class="hit">        HydPy.nmb_instances += 1
</span><span class="hit">        if HydPy.nmb_instances &gt; 1:
</span><span class="miss">            warnings.warn(&#39;Currently %d instances of HydPy are initialized &#39;
</span><span class="noop">                          &#39;within the same process.  It is strongly &#39;
</span><span class="noop">                          &#39;recommended to initialize only one instance at a &#39;
</span><span class="noop">                          &#39;time.  Consider deleting all instances and &#39;
</span><span class="noop">                          &#39;initializing a new one, unless you are fully aware &#39;
</span><span class="noop">                          &#39;in what manner HydPy is relying on some global &#39;
</span><span class="noop">                          &#39;information stored in modules.&#39;
</span><span class="noop">                          % HydPy.nmb_instances)
</span><span class="noop">
</span><span class="noop">        # Store public information in a seperate module.
</span><span class="hit">        pub.projectname = projectname
</span><span class="hit">        if projectname is None:
</span><span class="hit">            pub.filemanager = None
</span><span class="hit">            pub.networkmanager = None
</span><span class="hit">            pub.controlmanager = None
</span><span class="hit">            pub.sequencemanager = None
</span><span class="hit">            pub.conditionmanager = None
</span><span class="noop">        else:
</span><span class="miss">            pub.filemanager = filetools.MainManager()
</span><span class="miss">            pub.networkmanager = filetools.NetworkManager()
</span><span class="miss">            pub.controlmanager = filetools.ControlManager()
</span><span class="miss">            pub.sequencemanager = filetools.SequenceManager()
</span><span class="miss">            pub.conditionmanager = filetools.ConditionManager()
</span><span class="noop">
</span><span class="hit">        if pub.options.printprogress:
</span><span class="miss">            print(&#39;HydPy initialization ended at&#39;, time.strftime(&#39;%X&#39;))
</span><span class="noop">
</span><span class="hit">    def preparenetwork(self):
</span><span class="miss">        pub.selections = selectiontools.Selections()
</span><span class="miss">        pub.selections += pub.networkmanager.load()
</span><span class="miss">        self.updatedevices(pub.selections.complete)
</span><span class="noop">
</span><span class="hit">    def initmodels(self):
</span><span class="miss">        warn = pub.options.warnsimulationstep
</span><span class="miss">        pub.options.warnsimulationstep = False
</span><span class="miss">        try:
</span><span class="miss">            for (name, element) in self.elements:
</span><span class="miss">                try:
</span><span class="miss">                    element.initmodel()
</span><span class="miss">                except IOError as exc:
</span><span class="miss">                    temp = &#39;While trying to load the control file&#39;
</span><span class="miss">                    if ((temp in str(exc)) and
</span><span class="noop">                            pub.options.warnmissingcontrolfile):
</span><span class="miss">                        warnings.warn(&#39;No model could be initialized for &#39;
</span><span class="noop">                                      &#39;element `%s`&#39; % name)
</span><span class="miss">                        self.model = None
</span><span class="noop">                    else:
</span><span class="miss">                        objecttools.augmentexcmessage(
</span><span class="noop">                            &#39;While trying to initialize the model of &#39;
</span><span class="noop">                            &#39;element `%s`&#39; % name)
</span><span class="noop">                else:
</span><span class="miss">                    element.model.parameters.update()
</span><span class="miss">                    element.model.connect()
</span><span class="noop">        finally:
</span><span class="miss">            pub.options.warnsimulationstep = warn
</span><span class="noop">
</span><span class="hit">    def savecontrols(self, controldirectory=None, projectdirectory=None,
</span><span class="noop">                     parameterstep=None, simulationstep=None):
</span><span class="miss">        _controldirectory = pub.controlmanager._controldirectory
</span><span class="miss">        _projectdirectory = pub.controlmanager._projectdirectory
</span><span class="miss">        try:
</span><span class="miss">            if controldirectory:
</span><span class="miss">                pub.controlmanager.controldirectory = controldirectory
</span><span class="miss">            if projectdirectory:
</span><span class="miss">                pub.controlmanager.projectdirectory = projectdirectory
</span><span class="miss">            for (name, element) in self.elements:
</span><span class="miss">                element.model.parameters.savecontrols(parameterstep,
</span><span class="noop">                                                      simulationstep)
</span><span class="noop">        finally:
</span><span class="miss">            pub.controlmanager._controldirectory = _controldirectory
</span><span class="miss">            pub.controlmanager._projectdirectory = _projectdirectory
</span><span class="noop">
</span><span class="hit">    def loadconditions(self, conditiondirectory=None, controldirectory=None,
</span><span class="noop">                       projectdirectory=None, ):
</span><span class="miss">        self._ioconditions(conditiondirectory,  controldirectory,
</span><span class="noop">                           projectdirectory, True)
</span><span class="noop">
</span><span class="hit">    def saveconditions(self, conditiondirectory=None, controldirectory=None,
</span><span class="noop">                       projectdirectory=None):
</span><span class="miss">        self._ioconditions(conditiondirectory,  controldirectory,
</span><span class="noop">                           projectdirectory, False)
</span><span class="noop">
</span><span class="hit">    def _ioconditions(self, conditiondirectory, controldirectory,
</span><span class="noop">                      projectdirectory, loadflag):
</span><span class="miss">        if loadflag:
</span><span class="miss">            _conditiondirectory = pub.conditionmanager._loaddirectory
</span><span class="noop">        else:
</span><span class="miss">            _conditiondirectory = pub.conditionmanager._savedirectory
</span><span class="miss">        _controldirectory = pub.controlmanager._controldirectory
</span><span class="miss">        _projectdirectory = pub.conditionmanager._projectdirectory
</span><span class="miss">        try:
</span><span class="miss">            if projectdirectory:
</span><span class="miss">                pub.conditionmanager.projectdirectory = projectdirectory
</span><span class="miss">            if conditiondirectory:
</span><span class="miss">                if loadflag:
</span><span class="miss">                    pub.conditionmanager.loaddirectory = conditiondirectory
</span><span class="noop">                else:
</span><span class="miss">                    pub.conditionmanager.savedirectory = conditiondirectory
</span><span class="miss">            if controldirectory:
</span><span class="miss">                pub.controlmanager.controldirectory = controldirectory
</span><span class="miss">            for (name, element) in self.elements:
</span><span class="miss">                if loadflag:
</span><span class="miss">                    element.model.sequences.loadconditions()
</span><span class="noop">                else:
</span><span class="miss">                    element.model.sequences.saveconditions()
</span><span class="noop">        finally:
</span><span class="miss">            if loadflag:
</span><span class="miss">                pub.conditionmanager._loaddirectory = _conditiondirectory
</span><span class="noop">            else:
</span><span class="miss">                pub.conditionmanager._savedirectory = _conditiondirectory
</span><span class="miss">            pub.controlmanager._controldirectory = _controldirectory
</span><span class="miss">            pub.conditionmanager._projectdirectory = _projectdirectory
</span><span class="noop">
</span><span class="hit">    def trimconditions(self):
</span><span class="miss">        for (name, element) in self.elements:
</span><span class="miss">            element.model.sequences.trimconditions()
</span><span class="noop">
</span><span class="hit">    def resetconditions(self):
</span><span class="miss">        for (name, element) in self.elements:
</span><span class="miss">            element.model.sequences.reset()
</span><span class="noop">
</span><span class="hit">    def connect(self):
</span><span class="miss">        for (name, element) in self.elements:
</span><span class="miss">            element.connect()
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def network_properties(self):
</span><span class="miss">        print(&#39;Number of nodes: %d&#39; % len(self.nodes))
</span><span class="miss">        print(&#39;Number of elements: %d&#39; % len(self.elements))
</span><span class="miss">        print(&#39;Number of end nodes: %d&#39; % len(self.endnodes))
</span><span class="miss">        print(&#39;Number of distinct networks: %d&#39; % len(self.distinct_networks))
</span><span class="miss">        print(&#39;Applied node variables: %s&#39; % &#39;, &#39;.join(self.variables))
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def distinct_networks(self):
</span><span class="miss">        sels1 = selectiontools.Selections()
</span><span class="miss">        sels2 = selectiontools.Selections()
</span><span class="miss">        complete = selectiontools.Selection(&#39;complete&#39;,
</span><span class="noop">                                            self.nodes, self.elements)
</span><span class="miss">        for (name, node) in self.endnodes:
</span><span class="miss">            sel = complete.copy(name).select_upstream(node)
</span><span class="miss">            sels1 += sel
</span><span class="miss">            sels2 += sel.copy(name)
</span><span class="miss">        for (name1, sel1) in sels1:
</span><span class="miss">            for (name2, sel2) in sels2:
</span><span class="miss">                if name1 != name2:
</span><span class="miss">                    sel1 -= sel2
</span><span class="miss">        for name in list(sels1.names):
</span><span class="miss">            if not sels1[name].elements:
</span><span class="miss">                del sels1[name]
</span><span class="miss">        return sels1
</span><span class="noop">
</span><span class="hit">    def _updatedeviceorder(self):
</span><span class="hit">        self.deviceorder = []
</span><span class="hit">        for (name, node) in self.endnodes:
</span><span class="hit">            self._nextnode(node)
</span><span class="hit">        self.deviceorder = self.deviceorder[::-1]
</span><span class="noop">
</span><span class="hit">    def _nextnode(self, node):
</span><span class="hit">        for (name, element) in node.exits:
</span><span class="hit">            if ((element in self.elements) and
</span><span class="noop">                    (element not in self.deviceorder)):
</span><span class="miss">                if node not in element.receivers:
</span><span class="miss">                    self._nextelement(element)
</span><span class="hit">        if (node in self.nodes) and (node not in self.deviceorder):
</span><span class="hit">            self.deviceorder.append(node)
</span><span class="hit">            for (name, element) in node.entries:
</span><span class="hit">                self._nextelement(element)
</span><span class="noop">
</span><span class="hit">    def _nextelement(self, element):
</span><span class="hit">        for (name, node) in element.outlets:
</span><span class="hit">            if ((node in self.nodes) and
</span><span class="noop">                    (node not in self.deviceorder)):
</span><span class="miss">                self._nextnode(node)
</span><span class="hit">        if (element in self.elements) and (element not in self.deviceorder):
</span><span class="hit">            self.deviceorder.append(element)
</span><span class="hit">            for (name, node) in element.inlets:
</span><span class="hit">                self._nextnode(node)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def endnodes(self):
</span><span class="hit">        endnodes = devicetools.Nodes()
</span><span class="hit">        for (name, node) in self.nodes:
</span><span class="hit">            for (name, element) in node.exits:
</span><span class="hit">                if ((element in self.elements) and
</span><span class="noop">                        (node not in element.receivers)):
</span><span class="hit">                    break
</span><span class="noop">            else:
</span><span class="hit">                endnodes += node
</span><span class="hit">        return endnodes
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def variables(self):
</span><span class="miss">        variables = set([])
</span><span class="miss">        for (name, node) in self.nodes:
</span><span class="miss">            variables.add(node.variable)
</span><span class="miss">        return sorted(variables)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def simindices(self):
</span><span class="hit">        return (pub.timegrids.init[pub.timegrids.sim.firstdate],
</span><span class="noop">                pub.timegrids.init[pub.timegrids.sim.lastdate])
</span><span class="noop">
</span><span class="hit">    def openfiles(self, idx=0):
</span><span class="hit">        for (name, element) in self.elements:
</span><span class="hit">            element.model.sequences.openfiles(idx)
</span><span class="hit">        for (name, node) in self.nodes:
</span><span class="hit">            node.sequences.openfiles(idx)
</span><span class="noop">
</span><span class="hit">    def closefiles(self):
</span><span class="hit">        for (name, element) in self.elements:
</span><span class="hit">            element.model.sequences.closefiles()
</span><span class="hit">        for (name, node) in self.nodes:
</span><span class="hit">            node.sequences.closefiles()
</span><span class="noop">
</span><span class="hit">    def updatedevices(self, selection=None):
</span><span class="hit">        if selection is not None:
</span><span class="hit">            self.nodes = selection.nodes
</span><span class="hit">            self.elements = selection.elements
</span><span class="hit">        self._updatedeviceorder()
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def funcorder(self):
</span><span class="hit">        funcs = []
</span><span class="hit">        for (name, node) in self.nodes:
</span><span class="hit">            if node.routingmode == &#39;oldsim&#39;:
</span><span class="hit">                funcs.append(node._loaddata_sim)
</span><span class="hit">            elif node.sequences.obs.use_ext:
</span><span class="hit">                funcs.append(node._loaddata_obs)
</span><span class="hit">        for (name, element) in self.elements:
</span><span class="hit">            if element.receivers:
</span><span class="miss">                funcs.append(element.model.updatereceivers)
</span><span class="hit">        for (name, node) in self.nodes:
</span><span class="hit">            if node.routingmode != &#39;oldsim&#39;:
</span><span class="hit">                funcs.append(node.reset)
</span><span class="hit">        for device in self.deviceorder:
</span><span class="hit">            if isinstance(device, devicetools.Element):
</span><span class="hit">                funcs.append(device.model.doit)
</span><span class="hit">        for (name, element) in self.elements:
</span><span class="hit">            if element.senders:
</span><span class="miss">                funcs.append(element.model.updatesenders)
</span><span class="hit">        for (name, node) in self.nodes:
</span><span class="hit">            if node.routingmode != &#39;oldsim&#39;:
</span><span class="hit">                funcs.append(node._savedata_sim)
</span><span class="hit">        return funcs
</span><span class="noop">
</span><span class="hit">    def doit(self):
</span><span class="hit">        idx_start, idx_end = self.simindices
</span><span class="hit">        self.openfiles(idx_start)
</span><span class="hit">        funcorder = self.funcorder
</span><span class="hit">        if pub.options.printprogress:
</span><span class="miss">            maxcounter = int(float(idx_end-idx_start)/20.)
</span><span class="miss">            print(&#39;|&#39;+18*&#39;-&#39;+&#39;|&#39;)
</span><span class="noop">        else:
</span><span class="hit">            maxcounter = idx_end
</span><span class="hit">        counter = 0
</span><span class="hit">        for idx in range(idx_start, idx_end):
</span><span class="hit">            counter += 1
</span><span class="hit">            if counter &gt; maxcounter:
</span><span class="miss">                print(&#39;*&#39;, end=&#39;&#39;)
</span><span class="miss">                counter = 0
</span><span class="hit">            for func in funcorder:
</span><span class="hit">                func(idx)
</span><span class="hit">        if pub.options.printprogress:
</span><span class="miss">            print(&#39;*&#39;)
</span><span class="hit">        self.closefiles()
</span><span class="noop">
</span><span class="hit">    def prepare_modelseries(self, ramflag=True):
</span><span class="miss">        self.elements.prepare_allseries(ramflag)
</span><span class="noop">
</span><span class="hit">    def prepare_inputseries(self, ramflag=True):
</span><span class="miss">        self.elements.prepare_inputseries(ramflag)
</span><span class="noop">
</span><span class="hit">    def prepare_fluxseries(self, ramflag=True):
</span><span class="miss">        self.elements.prepare_fluxseries(ramflag)
</span><span class="noop">
</span><span class="hit">    def prepare_stateseries(self, ramflag=True):
</span><span class="miss">        self.elements.prepare_stateseries(ramflag)
</span><span class="noop">
</span><span class="hit">    def prepare_nodeseries(self, ramflag=True):
</span><span class="miss">        self.nodes.prepare_allseries(ramflag)
</span><span class="noop">
</span><span class="hit">    def prepare_simseries(self, ramflag=True):
</span><span class="miss">        self.elements.prepare_simseries(ramflag)
</span><span class="noop">
</span><span class="hit">    def prepare_obsseries(self, ramflag=True):
</span><span class="miss">        self.elements.prepare_obsseries(ramflag)
</span><span class="noop">
</span><span class="hit">    def save_modelseries(self):
</span><span class="miss">        self.save_inputseries()
</span><span class="miss">        self.save_fluxseries()
</span><span class="miss">        self.save_stateseries()
</span><span class="noop">
</span><span class="hit">    def save_inputseries(self):
</span><span class="miss">        self._save_modelseries(&#39;inputs&#39;, pub.sequencemanager.inputoverwrite)
</span><span class="noop">
</span><span class="hit">    def save_fluxseries(self):
</span><span class="miss">        self._save_modelseries(&#39;fluxes&#39;, pub.sequencemanager.outputoverwrite)
</span><span class="noop">
</span><span class="hit">    def save_stateseries(self):
</span><span class="miss">        self._save_modelseries(&#39;states&#39;, pub.sequencemanager.outputoverwrite)
</span><span class="noop">
</span><span class="hit">    def _save_modelseries(self, name_subseqs, overwrite):
</span><span class="miss">        for (name1, element) in self.elements:
</span><span class="miss">            sequences = element.model.sequences
</span><span class="miss">            subseqs = getattr(sequences, name_subseqs, ())
</span><span class="miss">            for (name2, seq) in subseqs:
</span><span class="miss">                if seq.memoryflag:
</span><span class="miss">                    if overwrite or not os.path.exists(seq.filepath_ext):
</span><span class="miss">                        seq.save_ext()
</span><span class="noop">                    else:
</span><span class="miss">                        warnings.warn(&#39;Due to the argument `overwrite` beeing &#39;
</span><span class="noop">                                      &#39;`False` it is not allowed to overwrite &#39;
</span><span class="noop">                                      &#39;the already existing file `%s`.&#39;
</span><span class="noop">                                      % seq.filepath_ext)
</span><span class="noop">
</span><span class="hit">    def save_nodeseries(self):
</span><span class="miss">        self.save_simseries()
</span><span class="miss">        self.save_obsseries()
</span><span class="noop">
</span><span class="hit">    def save_simseries(self, ramflag=True):
</span><span class="miss">        self._save_nodeseries(&#39;sim&#39;, pub.sequencemanager.simoverwrite)
</span><span class="noop">
</span><span class="hit">    def save_obsseries(self, ramflag=True):
</span><span class="miss">        self._save_nodeseries(&#39;obs&#39;, pub.sequencemanager.obsoverwrite)
</span><span class="noop">
</span><span class="hit">    def _save_nodeseries(self, seqname, overwrite):
</span><span class="miss">        for (name, node) in self.nodes:
</span><span class="miss">            seq = getattr(node.sequences, seqname)
</span><span class="miss">            if seq.memoryflag:
</span><span class="miss">                if overwrite or not os.path.exists(seq.filepath_ext):
</span><span class="miss">                    seq.save_ext()
</span><span class="noop">                else:
</span><span class="miss">                    warnings.warn(&#39;Due to the argument `overwrite` beeing &#39;
</span><span class="noop">                                  &#39;`False` it is not allowed to overwrite &#39;
</span><span class="noop">                                  &#39;the already existing file `%s`.&#39;
</span><span class="noop">                                  % seq.filepath_ext)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/indextools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/indextools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core import objecttools
</span><span class="hit">from hydpy.core import timetools
</span><span class="noop"># from hydpy.pub import ... (actual import commands moved to
</span><span class="noop"># different functions below to avoid circular dependencies)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Indexer(object):
</span><span class="noop">    &#34;&#34;&#34;Handles arrays containing indexes.
</span><span class="noop">
</span><span class="noop">    One can specify the index arrays manually, but usually they are determined
</span><span class="noop">    automatically based on the :class:`~hydpy.core.timetools.Timegrids` object
</span><span class="noop">    made available through module :mod:`~hydpy.pub`.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    def __init__(self):
</span><span class="hit">        self._monthofyear = None
</span><span class="hit">        self._monthofyear_hash = hash(None)
</span><span class="hit">        self._dayofyear = None
</span><span class="hit">        self._dayofyear_hash = hash(None)
</span><span class="hit">        self._timeofyear = None
</span><span class="hit">        self._timeofyear_hash = hash(None)
</span><span class="noop">
</span><span class="hit">    def _getmonthofyear(self):
</span><span class="noop">        &#34;&#34;&#34;Month of the year index (January = 0...).&#34;&#34;&#34;
</span><span class="hit">        from hydpy.pub import timegrids
</span><span class="hit">        if ((self._monthofyear is None) or
</span><span class="noop">                (hash(timegrids) != self._monthofyear_hash)):
</span><span class="hit">            def monthofyear(date):
</span><span class="hit">                return date.month-1
</span><span class="hit">            self._monthofyear = self._calcidxs(monthofyear)
</span><span class="hit">            self._monthofyear_hash = hash(timegrids)
</span><span class="hit">        return self._monthofyear
</span><span class="noop">
</span><span class="hit">    def _setmonthofyear(self, values):
</span><span class="hit">        from hydpy.pub import timegrids
</span><span class="hit">        self._monthofyear = self._convertandtest(values, &#39;monthofyear&#39;)
</span><span class="hit">        self._monthofyear_hash = hash(timegrids)
</span><span class="noop">
</span><span class="hit">    def _delmonthofyear(self):
</span><span class="hit">        self._monthofyear = None
</span><span class="noop">
</span><span class="hit">    monthofyear = property(_getmonthofyear, _setmonthofyear, _delmonthofyear)
</span><span class="noop">
</span><span class="hit">    def _getdayofyear(self):
</span><span class="noop">        &#34;&#34;&#34;Day of the year index (the first of January = 0...).
</span><span class="noop">
</span><span class="noop">        For reasons of consistency between leap years and non-leap years,
</span><span class="noop">        assuming a daily time step, index 59 is always associated with the
</span><span class="noop">        29th of February.  Hence, it is missing in non-leap years:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import pub
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.timetools import Timegrids, Timegrid
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.indextools import Indexer
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids = Timegrids(Timegrid(&#39;27.02.2004&#39;,
</span><span class="noop">        ...                                    &#39;3.03.2004&#39;,
</span><span class="noop">        ...                                    &#39;1d&#39;))
</span><span class="noop">        &gt;&gt;&gt; Indexer().dayofyear
</span><span class="noop">        array([57, 58, 59, 60, 61])
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids = Timegrids(Timegrid(&#39;27.02.2005&#39;,
</span><span class="noop">        ...                                    &#39;3.03.2005&#39;,
</span><span class="noop">        ...                                    &#39;1d&#39;))
</span><span class="noop">        &gt;&gt;&gt; Indexer().dayofyear
</span><span class="noop">        array([57, 58, 60, 61])
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        from hydpy.pub import timegrids
</span><span class="hit">        if ((self._dayofyear is None) or
</span><span class="noop">                (hash(timegrids) != self._dayofyear_hash)):
</span><span class="hit">            def dayofyear(date):
</span><span class="hit">                return (date.dayofyear-1 +
</span><span class="noop">                        ((date.month &gt; 2) and (not date.leapyear)))
</span><span class="hit">            self._dayofyear = self._calcidxs(dayofyear)
</span><span class="hit">            self._dayofyear_hash = hash(timegrids)
</span><span class="hit">        return self._dayofyear
</span><span class="noop">
</span><span class="hit">    def _setdayofyear(self, values):
</span><span class="hit">        from hydpy.pub import timegrids
</span><span class="hit">        self._dayofyear = self._convertandtest(values, &#39;dayofyear&#39;)
</span><span class="hit">        self._dayofyear_hash = hash(timegrids)
</span><span class="noop">
</span><span class="hit">    def _deldayofyear(self):
</span><span class="hit">        self._dayofyear = None
</span><span class="noop">
</span><span class="hit">    dayofyear = property(_getdayofyear, _setdayofyear, _deldayofyear)
</span><span class="noop">
</span><span class="hit">    def _gettimeofyear(self):
</span><span class="noop">        &#34;&#34;&#34;Time of the year index (first simulation step of each year = 0...).
</span><span class="noop">
</span><span class="noop">        The property :attr:`~Indexer.timeofyear` is best explained through
</span><span class="noop">        it with property :attr:`~Indexer.dayofyear`:
</span><span class="noop">
</span><span class="noop">        Let us reconsider one of the examples of the documentation on
</span><span class="noop">        property :attr:`~Indexer.dayofyear`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import pub
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.timetools import Timegrids, Timegrid
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.indextools import Indexer
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids = Timegrids(Timegrid(&#39;27.02.2005&#39;,
</span><span class="noop">        ...                                    &#39;3.03.2005&#39;,
</span><span class="noop">        ...                                    &#39;1d&#39;))
</span><span class="noop">
</span><span class="noop">        Due to the simulation stepsize beeing one day, the index arrays
</span><span class="noop">        calculated by both properties are identical:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; Indexer().dayofyear
</span><span class="noop">        array([57, 58, 60, 61])
</span><span class="noop">        &gt;&gt;&gt; Indexer().timeofyear
</span><span class="noop">        array([57, 58, 60, 61])
</span><span class="noop">
</span><span class="noop">        In the next example the step size is halved:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids = Timegrids(Timegrid(&#39;27.02.2005&#39;,
</span><span class="noop">        ...                                    &#39;3.03.2005&#39;,
</span><span class="noop">        ...                                    &#39;12h&#39;))
</span><span class="noop">
</span><span class="noop">        Now the there a generally two subsequent simulation steps associated
</span><span class="noop">        with the same day:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; Indexer().dayofyear
</span><span class="noop">        array([57, 57, 58, 58, 60, 60, 61, 61])
</span><span class="noop">
</span><span class="noop">        However, the `timeofyear` array gives the index of the
</span><span class="noop">        respective simulation steps of the actual year:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; Indexer().timeofyear
</span><span class="noop">        array([114, 115, 116, 117, 120, 121, 122, 123])
</span><span class="noop">
</span><span class="noop">        Note the gap in the returned index array due to 2005 beeing not a
</span><span class="noop">        leap year.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        from hydpy.pub import timegrids
</span><span class="hit">        if ((self._timeofyear is None) or
</span><span class="noop">                (hash(timegrids) != self._timeofyear_hash)):
</span><span class="hit">            if timegrids is None:
</span><span class="hit">                refgrid = None
</span><span class="noop">            else:
</span><span class="hit">                refgrid = timetools.Timegrid(timetools.Date(&#39;2000.01.01&#39;),
</span><span class="noop">                                             timetools.Date(&#39;2001.01.01&#39;),
</span><span class="noop">                                             timegrids.stepsize)
</span><span class="noop">
</span><span class="hit">            def timeofyear(date):
</span><span class="hit">                date = date.copy()
</span><span class="hit">                date.year = 2000
</span><span class="hit">                return refgrid[date]
</span><span class="noop">
</span><span class="hit">            self._timeofyear = self._calcidxs(timeofyear)
</span><span class="hit">            self._timeofyear_hash = hash(timegrids)
</span><span class="hit">        return self._timeofyear
</span><span class="noop">
</span><span class="hit">    def _settimeofyear(self, values):
</span><span class="hit">        from hydpy.pub import timegrids
</span><span class="hit">        self._timeofyear = self._convertandtest(values, &#39;timeofyear&#39;)
</span><span class="hit">        self._timeofyear_hash = hash(timegrids)
</span><span class="noop">
</span><span class="hit">    def _deltimeofyear(self):
</span><span class="hit">        self._timeofyear = None
</span><span class="noop">
</span><span class="hit">    timeofyear = property(_gettimeofyear, _settimeofyear, _deltimeofyear)
</span><span class="noop">
</span><span class="hit">    def _convertandtest(self, values, name):
</span><span class="noop">        &#34;&#34;&#34;Try to convert the given values to a :mod:`numpy`
</span><span class="noop">        :class:`~numpy.ndarrray` and check if it is plausible.  If so, return
</span><span class="noop">        the array, other raise a :class:`~exceptions.ValueError` or re-raise a
</span><span class="noop">        :mod:`numpy` specific exception.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        from hydpy.pub import timegrids
</span><span class="hit">        try:
</span><span class="hit">            array = numpy.array(values, dtype=int)
</span><span class="hit">        except BaseException:
</span><span class="hit">            objecttools.augmentexcmessage(&#39;While trying to assign a new `%s` &#39;
</span><span class="noop">                                          &#39;index array to an Indexer object&#39;
</span><span class="noop">                                          % name)
</span><span class="hit">        if array.ndim != 1:
</span><span class="hit">            raise ValueError(&#39;The `%s` index array of an Indexer object must &#39;
</span><span class="noop">                             &#39;be 1-dimensional.  However, the given value has &#39;
</span><span class="noop">                             &#39;interpreted as a %d-dimensional object.&#39;
</span><span class="noop">                             % (name, array.ndim))
</span><span class="hit">        if timegrids is not None:
</span><span class="hit">            if len(array) != len(timegrids.init):
</span><span class="hit">                raise ValueError(&#39;The %s` index array of an Indexer object &#39;
</span><span class="noop">                                 &#39;must have a number of entries fitting to &#39;
</span><span class="noop">                                 &#39;the initialization time period precisely.  &#39;
</span><span class="noop">                                 &#39;However, the given value has been &#39;
</span><span class="noop">                                 &#39;interpreted to be of length %d and the &#39;
</span><span class="noop">                                 &#39;length of the Timegrid object representing &#39;
</span><span class="noop">                                 &#39;the actual initialization time period is %d.&#39;
</span><span class="noop">                                 % (name, len(array), len(timegrids.init)))
</span><span class="hit">        return array
</span><span class="noop">
</span><span class="hit">    def _calcidxs(self, func):
</span><span class="noop">        &#34;&#34;&#34;Return the required indexes based on the given lambda function and
</span><span class="noop">        the :class:`~hydpy.core.timetools.Timegrids` object handled by module
</span><span class="noop">        :mod:`~hydpy.pub`.  Raise a :class:`~exceptions.RuntimeError` if the
</span><span class="noop">        latter is not available.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        from hydpy.pub import timegrids
</span><span class="hit">        if timegrids is None:
</span><span class="hit">            raise RuntimeError(&#39;An Indexer object has been asked for an &#39;
</span><span class="noop">                               &#39;%s array.  Such an array has neither been &#39;
</span><span class="noop">                               &#39;determined yet nor can it be determined &#39;
</span><span class="noop">                               &#39;automatically at the moment.   Either &#39;
</span><span class="noop">                               &#39;define an %s array manually and pass it to &#39;
</span><span class="noop">                               &#39;the Indexer object, or make a proper &#39;
</span><span class="noop">                               &#39;Timegrids object available within the pub &#39;
</span><span class="noop">                               &#39;module.  In usual HydPy applications, the &#39;
</span><span class="noop">                               &#39;latter is done automatically.&#39;
</span><span class="noop">                               % (func.__name__, func.__name__))
</span><span class="hit">        idxs = numpy.empty(len(timegrids.init), dtype=int)
</span><span class="hit">        for (jdx, date) in enumerate(timegrids.init):
</span><span class="hit">            idxs[jdx] = func(date)
</span><span class="hit">        return idxs
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/magictools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/magictools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from the Python standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import os
</span><span class="hit">import sys
</span><span class="hit">import inspect
</span><span class="hit">import warnings
</span><span class="hit">import importlib
</span><span class="hit">import doctest
</span><span class="hit">import types
</span><span class="hit">import collections
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy.core import objecttools
</span><span class="hit">from hydpy.core import timetools
</span><span class="hit">from hydpy.core import filetools
</span><span class="hit">from hydpy.core import parametertools
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="hit">from hydpy.core import devicetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Tester(object):
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        frame = inspect.currentframe().f_back
</span><span class="hit">        self.filepath = frame.f_code.co_filename
</span><span class="hit">        self.package = frame.f_locals[&#39;__package__&#39;]
</span><span class="hit">        self.ispackage = os.path.split(self.filepath)[-1] == &#39;__init__.py&#39;
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def filenames(self):
</span><span class="miss">        if self.ispackage:
</span><span class="miss">            return os.listdir(os.path.dirname(self.filepath))
</span><span class="noop">        else:
</span><span class="miss">            return [self.filepath]
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def modulenames(self):
</span><span class="miss">        return [os.path.split(fn)[-1].split(&#39;.&#39;)[0] for fn in self.filenames
</span><span class="noop">                if (fn.endswith(&#39;.py&#39;) and not fn.startswith(&#39;_&#39;))]
</span><span class="noop">
</span><span class="hit">    def doit(self):
</span><span class="miss">        usedefaultvalues = pub.options.usedefaultvalues
</span><span class="miss">        pub.options.usedefaultvalues = False
</span><span class="miss">        printprogress = pub.options.printprogress
</span><span class="miss">        pub.options.printprogress = False
</span><span class="miss">        warnsimulationstep = pub.options.warnsimulationstep
</span><span class="miss">        pub.options.warnsimulationstep = False
</span><span class="miss">        timegrids = pub.timegrids
</span><span class="miss">        pub.timegrids = None
</span><span class="miss">        _simulationstep = parametertools.Parameter._simulationstep
</span><span class="miss">        parametertools.Parameter._simulationstep = None
</span><span class="miss">        dirverbose = pub.options.dirverbose
</span><span class="miss">        reprcomments = pub.options.reprcomments
</span><span class="miss">        pub.options.reprcomments = False
</span><span class="miss">        reprdigits = pub.options.reprdigits
</span><span class="miss">        pub.options.reprdigits = 6
</span><span class="miss">        warntrim = pub.options.warntrim
</span><span class="miss">        pub.options.warntrim = False
</span><span class="miss">        nodes = devicetools.Node._registry.copy()
</span><span class="miss">        elements = devicetools.Element._registry.copy()
</span><span class="miss">        devicetools.Node.clearregistry()
</span><span class="miss">        devicetools.Element.clearregistry()
</span><span class="miss">        try:
</span><span class="miss">            color = 34 if pub.options.usecython else 36
</span><span class="miss">            with PrintStyle(color=color, font=4):
</span><span class="miss">                print(
</span><span class="noop">                  &#39;Test %s %s in %sython mode.&#39;
</span><span class="noop">                  % (&#39;package&#39; if self.ispackage else &#39;module&#39;,
</span><span class="noop">                     self.package if self.ispackage else self.modulenames[0],
</span><span class="noop">                     &#39;C&#39; if pub.options.usecython else &#39;P&#39;))
</span><span class="miss">            with PrintStyle(color=color, font=2):
</span><span class="miss">                for name in self.modulenames:
</span><span class="miss">                    print(&#39;    * %s:&#39; % name, )
</span><span class="miss">                    with StdOutErr(indent=8):
</span><span class="miss">                        modulename = &#39;.&#39;.join((self.package, name))
</span><span class="miss">                        module = importlib.import_module(modulename)
</span><span class="miss">                        warnings.filterwarnings(&#39;error&#39;, module=modulename)
</span><span class="miss">                        warnings.filterwarnings(&#39;ignore&#39;,
</span><span class="noop">                                                category=ImportWarning)
</span><span class="miss">                        doctest.testmod(module, extraglobs={&#39;testing&#39;: True},
</span><span class="noop">                                        optionflags=doctest.ELLIPSIS)
</span><span class="miss">                        warnings.resetwarnings()
</span><span class="noop">        finally:
</span><span class="miss">            pub.options.usedefaultvalues = usedefaultvalues
</span><span class="miss">            pub.options.printprogress = printprogress
</span><span class="miss">            pub.options.warnsimulationstep = warnsimulationstep
</span><span class="miss">            pub.timegrids = timegrids
</span><span class="miss">            parametertools.Parameter._simulationstep = _simulationstep
</span><span class="miss">            pub.options.dirverbose = dirverbose
</span><span class="miss">            pub.options.reprcomments = reprcomments
</span><span class="miss">            pub.options.reprdigits = reprdigits
</span><span class="miss">            pub.options.warntrim = warntrim
</span><span class="miss">            devicetools.Node.clearregistry()
</span><span class="miss">            devicetools.Element.clearregistry()
</span><span class="miss">            devicetools.Node._registry = nodes
</span><span class="miss">            devicetools.Element._registry = elements
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class PrintStyle(object):
</span><span class="noop">
</span><span class="hit">    def __init__(self, color, font):
</span><span class="hit">        self.color = color
</span><span class="hit">        self.font = font
</span><span class="noop">
</span><span class="hit">    def __enter__(self):
</span><span class="hit">        print(&#39;\x1B[%d;30;%dm&#39; % (self.font, self.color))
</span><span class="noop">
</span><span class="hit">    def __exit__(self, exception, message, traceback_):
</span><span class="hit">        print(&#39;\x1B[0m&#39;)
</span><span class="hit">        if exception:
</span><span class="miss">            objecttools.augmentexcmessage()
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class StdOutErr(object):
</span><span class="noop">
</span><span class="hit">    def __init__(self, indent=0):
</span><span class="miss">        self.indent = indent
</span><span class="miss">        self.stdout = sys.stdout
</span><span class="miss">        self.stderr = sys.stderr
</span><span class="miss">        self.encoding = sys.stdout.encoding
</span><span class="miss">        self.texts = []
</span><span class="noop">
</span><span class="hit">    def __enter__(self):
</span><span class="miss">        self.encoding = sys.stdout.encoding
</span><span class="miss">        sys.stdout = self
</span><span class="miss">        sys.stderr = self
</span><span class="noop">
</span><span class="hit">    def __exit__(self, exception, message, traceback_):
</span><span class="miss">        if not self.texts:
</span><span class="miss">            self.print_(&#39;no failures occurred&#39;)
</span><span class="noop">        else:
</span><span class="miss">            for text in self.texts:
</span><span class="miss">                self.print_(text)
</span><span class="miss">        sys.stdout = self.stdout
</span><span class="miss">        sys.stderr = self.stderr
</span><span class="miss">        if exception:
</span><span class="miss">            objecttools.augmentexcmessage()
</span><span class="noop">
</span><span class="hit">    def write(self, text):
</span><span class="miss">        self.texts.extend(text.split(&#39;\n&#39;))
</span><span class="noop">
</span><span class="hit">    def print_(self, text):
</span><span class="miss">        if text.strip():
</span><span class="miss">            self.stdout.write(self.indent*&#39; &#39; + text + &#39;\n&#39;)
</span><span class="noop">
</span><span class="hit">    def flush(self):
</span><span class="miss">        pass
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def parameterstep(timestep=None):
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">    Define a parameter time step size within a parameter control file.
</span><span class="noop">
</span><span class="noop">    Argument:
</span><span class="noop">      * timestep(:class:`~hydpy.core.timetools.Period`): Time step size.
</span><span class="noop">
</span><span class="noop">    Function :func:`parameterstep` should usually be be applied in a line
</span><span class="noop">    immediately behind the model import.  Defining the step size of time
</span><span class="noop">    dependent parameters is a prerequisite to access any model specific
</span><span class="noop">    parameter.
</span><span class="noop">
</span><span class="noop">    Note that :func:`parameterstep` implements some namespace magic by
</span><span class="noop">    means of the module :mod:`inspect`.  This makes things a little
</span><span class="noop">    complicated for framework developers, but it eases the definition of
</span><span class="noop">    parameter control files for framework users.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    if timestep is not None:
</span><span class="hit">        parametertools.Parameter._parameterstep = timetools.Period(timestep)
</span><span class="hit">    namespace = inspect.currentframe().f_back.f_locals
</span><span class="hit">    model = namespace.get(&#39;model&#39;)
</span><span class="hit">    if model is None:
</span><span class="hit">        model = namespace[&#39;Model&#39;]()
</span><span class="hit">        namespace[&#39;model&#39;] = model
</span><span class="hit">        if pub.options.usecython and &#39;cythonizer&#39; in namespace:
</span><span class="hit">            cythonizer = namespace[&#39;cythonizer&#39;]
</span><span class="hit">            namespace[&#39;cythonmodule&#39;] = cythonizer.cymodule
</span><span class="hit">            model.cymodel = cythonizer.cymodule.Model()
</span><span class="hit">            namespace[&#39;cymodel&#39;] = model.cymodel
</span><span class="hit">            for (name, func) in cythonizer.pyxwriter.listofmodeluserfunctions:
</span><span class="hit">                setattr(model, name, getattr(model.cymodel, name))
</span><span class="hit">            for func in (&#39;doit&#39;, &#39;new2old&#39;, &#39;openfiles&#39;, &#39;closefiles&#39;,
</span><span class="noop">                         &#39;loaddata&#39;, &#39;savedata&#39;):
</span><span class="hit">                if hasattr(model.cymodel, func):
</span><span class="hit">                    setattr(model, func, getattr(model.cymodel, func))
</span><span class="hit">        if &#39;Parameters&#39; not in namespace:
</span><span class="hit">            namespace[&#39;Parameters&#39;] = parametertools.Parameters
</span><span class="hit">        model.parameters = namespace[&#39;Parameters&#39;](namespace)
</span><span class="hit">        if &#39;Sequences&#39; not in namespace:
</span><span class="hit">            namespace[&#39;Sequences&#39;] = sequencetools.Sequences
</span><span class="hit">        model.sequences = namespace[&#39;Sequences&#39;](namespace)
</span><span class="hit">        namespace[&#39;parameters&#39;] = model.parameters
</span><span class="hit">        for (name, pars) in model.parameters:
</span><span class="hit">            namespace[name] = pars
</span><span class="hit">        namespace[&#39;sequences&#39;] = model.sequences
</span><span class="hit">        for (name, seqs) in model.sequences:
</span><span class="hit">            namespace[name] = seqs
</span><span class="hit">    try:
</span><span class="hit">        namespace.update(namespace[&#39;CONSTANTS&#39;])
</span><span class="hit">    except KeyError:
</span><span class="hit">        pass
</span><span class="hit">    focus = namespace.get(&#39;focus&#39;)
</span><span class="hit">    for (name, par) in model.parameters.control:
</span><span class="hit">        try:
</span><span class="hit">            if (focus is None) or (par is focus):
</span><span class="hit">                namespace[par.name] = par
</span><span class="noop">            else:
</span><span class="miss">                namespace[par.name] = lambda *args, **kwargs: None
</span><span class="miss">        except AttributeError:
</span><span class="miss">            pass
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def simulationstep(timestep):
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">    Define a simulation time step size for testing purposes within a
</span><span class="noop">    parameter control file.
</span><span class="noop">
</span><span class="noop">    Argument:
</span><span class="noop">        * timestep(:class:`~hydpy.core.timetools.Period`): Time step size.
</span><span class="noop">
</span><span class="noop">    Using :func:`simulationstep` only affects the values of time dependent
</span><span class="noop">    parameters, when `pub.timegrids.stepsize` is not defined.  It thus has
</span><span class="noop">    no influence on usual hydpy simulations at all.  Use it just to check
</span><span class="noop">    your parameter control files.  Write it in a line immediately behind
</span><span class="noop">    the one calling :func:`parameterstep`.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    if pub.options.warnsimulationstep:
</span><span class="miss">        warnings.warn(&#39;Note that the applied function `simulationstep` is &#39;
</span><span class="noop">                      &#39;inteded for testing purposes only.  When doing a &#39;
</span><span class="noop">                      &#39;hydpy simulation, parameter values are initialized &#39;
</span><span class="noop">                      &#39;based on the actual simulation time step as defined &#39;
</span><span class="noop">                      &#39;under `pub.timegrids.stepsize` and the value given &#39;
</span><span class="noop">                      &#39;to `simulationstep` is ignored.&#39;)
</span><span class="hit">    parametertools.Parameter._simulationstep = timetools.Period(timestep)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def controlcheck(controldir=&#39;default&#39;, projectdir=None, controlfile=None):
</span><span class="miss">    namespace = inspect.currentframe().f_back.f_locals
</span><span class="miss">    model = namespace.get(&#39;model&#39;)
</span><span class="miss">    if model is None:
</span><span class="miss">        if projectdir is None:
</span><span class="miss">            projectdir = os.path.dirname(os.path.abspath(os.curdir))
</span><span class="miss">            projectdir = os.path.split(projectdir)[-1]
</span><span class="miss">        os.chdir(os.path.join(&#39;..&#39;, &#39;..&#39;, &#39;..&#39;))
</span><span class="miss">        controlpath = os.path.abspath(os.path.join(&#39;control&#39;,
</span><span class="noop">                                                   projectdir,
</span><span class="noop">                                                   controldir))
</span><span class="miss">        initfile = os.path.split(namespace[&#39;__file__&#39;])[-1]
</span><span class="miss">        if controlfile is None:
</span><span class="miss">            controlfile = initfile
</span><span class="miss">        filepath = os.path.join(controlpath, controlfile)
</span><span class="miss">        if not os.path.exists(filepath):
</span><span class="miss">            raise IOError(&#39;The check of consistency between the control &#39;
</span><span class="noop">                          &#39;parameter file %s and the initial condition file &#39;
</span><span class="noop">                          &#39;%s failed.  The control parameter file does not &#39;
</span><span class="noop">                          &#39;exist in directory %s.&#39;
</span><span class="noop">                          % (controlfile, initfile, controlpath))
</span><span class="miss">        controlmanager = filetools.ControlManager()
</span><span class="miss">        controlmanager.projectdirectory = projectdir
</span><span class="miss">        controlmanager.selecteddirectory = controldir
</span><span class="miss">        model = controlmanager.loadfile(controlfile)[&#39;model&#39;]
</span><span class="miss">        model.parameters.update()
</span><span class="miss">        namespace[&#39;model&#39;] = model
</span><span class="miss">        for name1 in (&#39;states&#39;, &#39;logs&#39;):
</span><span class="miss">            subseqs = getattr(model.sequences, name1, None)
</span><span class="miss">            if subseqs is not None:
</span><span class="miss">                for (name2, seq) in subseqs:
</span><span class="miss">                    namespace[name2] = seq
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">_PAR_SPEC2CAPT = collections.OrderedDict(((&#39;parameters&#39;, &#39;Parameter tools&#39;),
</span><span class="noop">                                          (&#39;constants&#39;, &#39;Constants&#39;),
</span><span class="noop">                                          (&#39;control&#39;, &#39;Control parameters&#39;),
</span><span class="noop">                                          (&#39;derived&#39;, &#39;Derived parameters&#39;)))
</span><span class="noop">
</span><span class="hit">_SEQ_SPEC2CAPT = collections.OrderedDict(((&#39;sequences&#39;, &#39;Sequence tools&#39;),
</span><span class="noop">                                          (&#39;inputs&#39;, &#39;Input sequences&#39;),
</span><span class="noop">                                          (&#39;fluxes&#39;, &#39;Flux sequences&#39;),
</span><span class="noop">                                          (&#39;states&#39;, &#39;State sequences&#39;),
</span><span class="noop">                                          (&#39;logs&#39;, &#39;Log sequences&#39;),
</span><span class="noop">                                          (&#39;inlets&#39;, &#39;Inlet sequences&#39;),
</span><span class="noop">                                          (&#39;outlets&#39;, &#39;Outlet sequences&#39;),
</span><span class="noop">                                          (&#39;receivers&#39;, &#39;Receiver sequences&#39;),
</span><span class="noop">                                          (&#39;senders&#39;, &#39;Sender sequences&#39;),
</span><span class="noop">                                          (&#39;aides&#39;, &#39;Aide sequences&#39;)))
</span><span class="noop">
</span><span class="hit">_all_spec2capt = _PAR_SPEC2CAPT.copy()
</span><span class="hit">_all_spec2capt.update(_SEQ_SPEC2CAPT)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def _add_title(title, marker):
</span><span class="noop">    &#34;&#34;&#34;Return a title for a basemodels docstring.&#34;&#34;&#34;
</span><span class="hit">    return [&#39;&#39;, title, marker*len(title)]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def _add_lines(specification, module):
</span><span class="noop">    &#34;&#34;&#34;Return autodoc commands for a basemodels docstring.
</span><span class="noop">
</span><span class="noop">    Note that `collection classes` (e.g. `Model`, `ControlParameters`,
</span><span class="noop">    `InputSequences` are placed on top of the respective section and the
</span><span class="noop">    `contained classes` (e.g. model methods, `ControlParameter` instances,
</span><span class="noop">    `InputSequence` instances at the bottom.  This differs from the order
</span><span class="noop">    of their definition in the respective modules, but results in a better
</span><span class="noop">    documentation structure.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    caption = _all_spec2capt.get(specification, &#39;dummy&#39;)
</span><span class="hit">    if caption.split()[-1] in (&#39;parameters&#39;, &#39;sequences&#39;):
</span><span class="hit">        exists_collectionclass = True
</span><span class="hit">        name_collectionclass = caption.title().replace(&#39; &#39;, &#39;&#39;)
</span><span class="noop">    else:
</span><span class="hit">        exists_collectionclass = False
</span><span class="hit">    lines = []
</span><span class="hit">    if specification == &#39;model&#39;:
</span><span class="hit">        lines += [&#39;&#39;,
</span><span class="noop">                  &#39;.. autoclass:: &#39; + module.__name__ + &#39;.Model&#39;,
</span><span class="noop">                  &#39;    :members:&#39;,
</span><span class="noop">                  &#39;    :show-inheritance:&#39;]
</span><span class="hit">    elif exists_collectionclass:
</span><span class="hit">        lines += [&#39;&#39;,
</span><span class="noop">                  &#39;.. autoclass:: %s.%s&#39; % (module.__name__,
</span><span class="noop">                                            name_collectionclass),
</span><span class="noop">                  &#39;    :members:&#39;,
</span><span class="noop">                  &#39;    :show-inheritance:&#39;]
</span><span class="hit">    lines += [&#39;&#39;,
</span><span class="noop">              &#39;.. automodule:: &#39; + module.__name__,
</span><span class="noop">              &#39;    :members:&#39;,
</span><span class="noop">              &#39;    :show-inheritance:&#39;]
</span><span class="hit">    if specification == &#39;model&#39;:
</span><span class="hit">        lines += [&#39;    :exclude-members: Model&#39;]
</span><span class="hit">    elif exists_collectionclass:
</span><span class="hit">        lines += [&#39;    :exclude-members: &#39; + name_collectionclass]
</span><span class="hit">    return lines
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def autodoc_basemodel():
</span><span class="noop">    &#34;&#34;&#34;Add an exhaustive docstring to the `__init__` module of a basemodel.
</span><span class="noop">
</span><span class="noop">    One just has to write `autodoc_basemodel()` at the bottom of an `__init__`
</span><span class="noop">    module of a basemodel, and all model, parameter and sequence information
</span><span class="noop">    are appended to the modules docstring.  The resulting docstring is suitable
</span><span class="noop">    automatic documentation generation via `Sphinx` and `autodoc`.  Hence
</span><span class="noop">    it helps in constructing HydPy&#39;s online documentation and supports the
</span><span class="noop">    embeded help feature of `Spyder` (to see the result, import the package
</span><span class="noop">    of an arbitrary basemodel, e.g. `from hydpy.models import lland` and
</span><span class="noop">    press `cntr+i` with the cursor placed on `lland` written in the IPython
</span><span class="noop">    console afterwards).
</span><span class="noop">
</span><span class="noop">    Note that the resulting documentation will be complete only when the
</span><span class="noop">    modules of the basemodel are named in the standard way, e.g. `lland_model`,
</span><span class="noop">    `lland_control`, `lland_inputs`.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    namespace = inspect.currentframe().f_back.f_locals
</span><span class="hit">    doc = namespace.get(&#39;__doc__&#39;)
</span><span class="hit">    if doc is None:
</span><span class="miss">        doc = &#39;&#39;
</span><span class="hit">    basemodulename = namespace[&#39;__name__&#39;].split(&#39;.&#39;)[-1]
</span><span class="hit">    modules = {key: value for key, value in namespace.items()
</span><span class="noop">               if (isinstance(value, types.ModuleType) and
</span><span class="noop">                   key.startswith(basemodulename+&#39;_&#39;))}
</span><span class="hit">    lines = []
</span><span class="hit">    specification = &#39;model&#39;
</span><span class="hit">    modulename = basemodulename+&#39;_&#39;+specification
</span><span class="hit">    if modulename in modules:
</span><span class="hit">        module = modules[modulename]
</span><span class="hit">        lines += _add_title(&#39;Model features&#39;, &#39;-&#39;)
</span><span class="hit">        lines += _add_lines(specification, module)
</span><span class="hit">    for (spec2capt, title) in zip((_PAR_SPEC2CAPT, _SEQ_SPEC2CAPT),
</span><span class="noop">                                  (&#39;Parameter features&#39;, &#39;Sequence features&#39;)):
</span><span class="hit">        new_lines = _add_title(title, &#39;-&#39;)
</span><span class="hit">        found_module = False
</span><span class="hit">        for (specification, caption) in spec2capt.items():
</span><span class="hit">            modulename = basemodulename+&#39;_&#39;+specification
</span><span class="hit">            module = modules.get(modulename)
</span><span class="hit">            if module:
</span><span class="hit">                found_module = True
</span><span class="hit">                new_lines += _add_title(caption, &#39;.&#39;)
</span><span class="hit">                new_lines += _add_lines(specification, module)
</span><span class="hit">        if found_module:
</span><span class="hit">            lines += new_lines
</span><span class="hit">    doc += &#39;\n&#39;.join(lines)
</span><span class="hit">    namespace[&#39;__doc__&#39;] = doc
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/modelimports.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/modelimports.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">&#34;&#34;&#34;This module bundles imports generally required for implementing nmodels.
</span><span class="noop">
</span><span class="noop">Module :mod:`modelimports` is supposed to shorten the import section
</span><span class="noop">of base and application models implemented.  Just write:
</span><span class="noop">
</span><span class="noop">&gt;&gt;&gt; from hydpy.core.modelimports import *
</span><span class="noop">
</span><span class="noop">Thereafter, the following objects are available:
</span><span class="noop"> * module :mod:`numpy`
</span><span class="noop"> * numpys :obj:`~numpy.nan` and :obj:`~numpy.inf`
</span><span class="noop"> * functions :func:`~hydpy.core.magictools.parameterstep`,
</span><span class="noop">   :func:`~hydpy.core.magictools.simulationstep`,
</span><span class="noop">   :func:`~hydpy.core.magictools.autodoc_basemodel`,
</span><span class="noop">   of module :mod:`~hydpy.core.magictools`
</span><span class="noop"> * class :class:`~hydpy.core.magictools.Tester`
</span><span class="noop">   of module :mod:`~hydpy.core.magictools`
</span><span class="noop"> * class :class:`~hydpy.cythons.modelutils.Cythonizer`
</span><span class="noop">   of module :mod:`~hydpy.cythons.modelutils`
</span><span class="noop">
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...third party
</span><span class="hit">import numpy
</span><span class="hit">from numpy import nan
</span><span class="hit">from numpy import inf
</span><span class="noop"># ...HydPy specific
</span><span class="noop"># Load the required `magic` functions into the local namespace.
</span><span class="hit">from hydpy.core.magictools import parameterstep
</span><span class="hit">from hydpy.core.magictools import simulationstep
</span><span class="hit">from hydpy.core.magictools import controlcheck
</span><span class="hit">from hydpy.core.magictools import autodoc_basemodel
</span><span class="hit">from hydpy.core.magictools import Tester
</span><span class="hit">from hydpy.cythons.modelutils import Cythonizer
</span><span class="noop">
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/modeltools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/modeltools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import types
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core import objecttools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MetaModelType(type):
</span><span class="hit">    def __new__(cls, name, parents, dict_):
</span><span class="hit">        for tuplename in (&#39;_RUNMETHODS&#39;, &#39;_ADDMETHODS&#39;):
</span><span class="hit">            methods = dict_.get(tuplename, ())
</span><span class="hit">            if methods:
</span><span class="hit">                if tuplename == &#39;_RUNMETHODS&#39;:
</span><span class="hit">                    lst = [&#39;\n\n\n    The following &#34;run methods&#34; are called &#39;
</span><span class="noop">                           &#39;each simulation step run in the given sequence:&#39;]
</span><span class="hit">                elif tuplename == &#39;_ADDMETHODS&#39;:
</span><span class="hit">                    lst = [&#39;\n\n\n    The following &#34;additional methods&#34; are &#39;
</span><span class="noop">                           &#39;called by at least one &#34;run method&#34;:&#39;]
</span><span class="hit">                for method in methods:
</span><span class="hit">                    lst.append(&#39;      * :func:`~%s` `%s`&#39;
</span><span class="noop">                               % (&#39;.&#39;.join((method.__module__,
</span><span class="noop">                                            method.__name__)),
</span><span class="noop">                                  objecttools.description(method)))
</span><span class="hit">                dict_[&#39;__doc__&#39;] += &#39;\n&#39;.join(l for l in lst)
</span><span class="hit">        return type.__new__(cls, name, parents, dict_)
</span><span class="noop">
</span><span class="hit">MetaModelClass = MetaModelType(&#39;MetaModelClass&#39;, (), {})
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Model(MetaModelClass):
</span><span class="noop">    &#34;&#34;&#34;Base class for all hydrological models.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    _RUNMETHODS = ()
</span><span class="hit">    _ADDMETHODS = ()
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        self.element = None
</span><span class="hit">        self.parameters = None
</span><span class="hit">        self.sequences = None
</span><span class="hit">        self.cymodel = type(&#39;dummy&#39;, (), {})
</span><span class="hit">        self.cymodel.idx_sim = -999
</span><span class="hit">        self._init_methods()
</span><span class="noop">
</span><span class="hit">    def _init_methods(self):
</span><span class="noop">        &#34;&#34;&#34;Convert all pure Python run and add functions of the model class to
</span><span class="noop">        methods and assign them to the model instance.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        for tuplename in (&#39;_RUNMETHODS&#39;, &#39;_ADDMETHODS&#39;):
</span><span class="hit">            functions = getattr(self, tuplename, ())
</span><span class="hit">            uniques = {}
</span><span class="hit">            for func in functions:
</span><span class="hit">                name = func.__name__
</span><span class="hit">                method = types.MethodType(func, self)
</span><span class="hit">                setattr(self, name, method)
</span><span class="hit">                shortname = &#39;_&#39;.join(name.split(&#39;_&#39;)[:-1])
</span><span class="hit">                if shortname in uniques:
</span><span class="miss">                    uniques[shortname] = None
</span><span class="noop">                else:
</span><span class="hit">                    uniques[shortname] = method
</span><span class="hit">            for (shortname, method) in uniques.items():
</span><span class="hit">                if method is not None:
</span><span class="hit">                    setattr(self, shortname, method)
</span><span class="noop">
</span><span class="hit">    def connect(self):
</span><span class="noop">        &#34;&#34;&#34;Connect the link sequences of the actual model.&#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            for group in (&#39;inlets&#39;, &#39;receivers&#39;, &#39;outlets&#39;, &#39;senders&#39;):
</span><span class="hit">                self._connect_subgroup(group)
</span><span class="miss">        except BaseException:
</span><span class="miss">            objecttools.augmentexcmessage(
</span><span class="noop">                &#39;While trying to build the node connection of the `%s` &#39;
</span><span class="noop">                &#39;sequences of the model handled by element `%s`&#39;
</span><span class="noop">                % (group[:-1],  objecttools.devicename(self)))
</span><span class="noop">
</span><span class="hit">    def _connect_subgroup(self, group):
</span><span class="hit">        isentry = group in (&#39;inlets&#39;, &#39;receivers&#39;)
</span><span class="hit">        available_nodes = getattr(self.element, group).slaves
</span><span class="hit">        links = getattr(self.sequences, group, ())
</span><span class="hit">        applied_nodes = []
</span><span class="hit">        for (name, seq) in links:
</span><span class="hit">            selected_nodes = [node for node in available_nodes
</span><span class="noop">                              if node.variable.lower() == name]
</span><span class="hit">            if isentry:
</span><span class="hit">                selected_doubles = [node.getdouble_via_exits()
</span><span class="noop">                                    for node in selected_nodes]
</span><span class="noop">            else:
</span><span class="hit">                selected_doubles = [node.getdouble_via_entries()
</span><span class="noop">                                    for node in selected_nodes]
</span><span class="hit">            if seq.NDIM == 0:
</span><span class="hit">                if len(selected_nodes) == 1:
</span><span class="hit">                    applied_nodes.append(selected_nodes[0])
</span><span class="hit">                    seq.setpointer(selected_doubles[0])
</span><span class="miss">                elif len(selected_nodes) == 0:
</span><span class="miss">                    raise RuntimeError(&#39;Sequence `%s` cannot be connected, &#39;
</span><span class="noop">                                       &#39;as no node is available which is &#39;
</span><span class="noop">                                       &#39;handling the variable `%s`.&#39;
</span><span class="noop">                                       % (name, seq.name.upper()))
</span><span class="noop">                else:
</span><span class="miss">                    raise RuntimeError(&#39;Sequence `%s` cannot be connected, &#39;
</span><span class="noop">                                       &#39;as it is 0-dimensional but multiple &#39;
</span><span class="noop">                                       &#39;nodes are available which are &#39;
</span><span class="noop">                                       &#39;handling variable `%s`.&#39;
</span><span class="noop">                                       % (name, seq.name.upper()))
</span><span class="hit">            elif seq.NDIM == 1:
</span><span class="hit">                seq.shape = len(selected_nodes)
</span><span class="hit">                zipped = zip(selected_nodes, selected_doubles)
</span><span class="hit">                for idx, (node, double) in enumerate(zipped):
</span><span class="hit">                    applied_nodes.append(node)
</span><span class="hit">                    seq.setpointer(double, idx)
</span><span class="hit">        if len(applied_nodes) &lt; len(available_nodes):
</span><span class="miss">            remaining_nodes = [node.name for node in available_nodes
</span><span class="noop">                               if node not in applied_nodes]
</span><span class="miss">            raise RuntimeError(&#39;The following nodes have not been connected &#39;
</span><span class="noop">                               &#39;to any sequences: `%s`.&#39;
</span><span class="noop">                               % &#39;, &#39;.join(remaining_nodes))
</span><span class="noop">
</span><span class="hit">    def doit(self, idx):
</span><span class="hit">        self.idx_sim = idx
</span><span class="hit">        self.loaddata()
</span><span class="hit">        self.update_inlets()
</span><span class="hit">        self.run()
</span><span class="hit">        self.update_outlets()
</span><span class="hit">        self.update_senders()
</span><span class="hit">        self.new2old()
</span><span class="hit">        self.savedata()
</span><span class="noop">
</span><span class="hit">    def run(self):
</span><span class="hit">        for method in self._RUNMETHODS:
</span><span class="hit">            if not method.__name__.startswith(&#39;update_&#39;):
</span><span class="hit">                method(self)
</span><span class="noop">
</span><span class="hit">    def loaddata(self):
</span><span class="hit">        self.sequences.loaddata(self.idx_sim)
</span><span class="noop">
</span><span class="hit">    def savedata(self):
</span><span class="hit">        self.sequences.savedata(self.idx_sim)
</span><span class="noop">
</span><span class="hit">    def update_inlets(self):
</span><span class="noop">        &#34;&#34;&#34;Maybe.&#34;&#34;&#34;
</span><span class="hit">        pass
</span><span class="noop">
</span><span class="hit">    def update_outlets(self):
</span><span class="noop">        &#34;&#34;&#34;In any case.&#34;&#34;&#34;
</span><span class="miss">        pass
</span><span class="noop">
</span><span class="hit">    def update_receivers(self):
</span><span class="miss">        pass
</span><span class="noop">
</span><span class="hit">    def update_senders(self):
</span><span class="hit">        pass
</span><span class="noop">
</span><span class="hit">    def new2old(self):
</span><span class="noop">        &#34;&#34;&#34;Assign the new/final state values of the actual time step to the
</span><span class="noop">        new/initial state values of the next time step.  Needs to be
</span><span class="noop">        overwritten in Cython mode.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            self.sequences.states.new2old()
</span><span class="hit">        except AttributeError:
</span><span class="hit">            pass
</span><span class="noop">
</span><span class="hit">    def _getidx_sim(self):
</span><span class="noop">        &#34;&#34;&#34;Index of the actual simulation time step.&#34;&#34;&#34;
</span><span class="hit">        return self.cymodel.idx_sim
</span><span class="noop">
</span><span class="hit">    def _setidx_sim(self, value):
</span><span class="hit">        self.cymodel.idx_sim = int(value)
</span><span class="noop">
</span><span class="hit">    idx_sim = property(_getidx_sim, _setidx_sim)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/objecttools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/objecttools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
677 &nbsp;
678 &nbsp;
679 &nbsp;
680 &nbsp;
681 &nbsp;
682 &nbsp;
683 &nbsp;
684 &nbsp;
685 &nbsp;
686 &nbsp;
687 &nbsp;
688 &nbsp;
689 &nbsp;
690 &nbsp;
691 &nbsp;
692 &nbsp;
693 &nbsp;
694 &nbsp;
695 &nbsp;
696 &nbsp;
697 &nbsp;
698 &nbsp;
699 &nbsp;
700 &nbsp;
701 &nbsp;
702 &nbsp;
703 &nbsp;
704 &nbsp;
705 &nbsp;
706 &nbsp;
707 &nbsp;
708 &nbsp;
709 &nbsp;
710 &nbsp;
711 &nbsp;
712 &nbsp;
713 &nbsp;
714 &nbsp;
715 &nbsp;
716 &nbsp;
717 &nbsp;
718 &nbsp;
719 &nbsp;
720 &nbsp;
721 &nbsp;
722 &nbsp;
723 &nbsp;
724 &nbsp;
725 &nbsp;
726 &nbsp;
727 &nbsp;
728 &nbsp;
729 &nbsp;
730 &nbsp;
731 &nbsp;
732 &nbsp;
733 &nbsp;
734 &nbsp;
735 &nbsp;
736 &nbsp;
737 &nbsp;
738 &nbsp;
739 &nbsp;
740 &nbsp;
741 &nbsp;
742 &nbsp;
743 &nbsp;
744 &nbsp;
745 &nbsp;
746 &nbsp;
747 &nbsp;
748 &nbsp;
749 &nbsp;
750 &nbsp;
751 &nbsp;
752 &nbsp;
753 &nbsp;
754 &nbsp;
755 &nbsp;
756 &nbsp;
757 &nbsp;
758 &nbsp;
759 &nbsp;
760 &nbsp;
761 &nbsp;
762 &nbsp;
763 &nbsp;
764 &nbsp;
765 &nbsp;
766 &nbsp;
767 &nbsp;
768 &nbsp;
769 &nbsp;
770 &nbsp;
771 &nbsp;
772 &nbsp;
773 &nbsp;
774 &nbsp;
775 &nbsp;
776 &nbsp;
777 &nbsp;
778 &nbsp;
779 &nbsp;
780 &nbsp;
781 &nbsp;
782 &nbsp;
783 &nbsp;
784 &nbsp;
785 &nbsp;
786 &nbsp;
787 &nbsp;
788 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import inspect
</span><span class="hit">import sys
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.cythons import pointer
</span><span class="noop"># from hydpy.pub import ... (actual import commands moved to
</span><span class="noop"># different functions below to avoid circular dependencies)
</span><span class="noop">
</span><span class="hit">_INT_NAN = -999999
</span><span class="noop">&#34;&#34;&#34;Surrogate for `nan`, which is available for floating point values
</span><span class="noop">but not for integer values.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def dir_(self):
</span><span class="noop">    &#34;&#34;&#34;The prefered way for HydPy objects to respond to :func:`dir`.
</span><span class="noop">
</span><span class="noop">    Note thedepencence on the `pub.options.dirverbose`.  If this option is
</span><span class="noop">    set `True`, all attributes and methods of the given instance and its
</span><span class="noop">    class (including those inherited from the parent classes) are returned:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.pub import options
</span><span class="noop">    &gt;&gt;&gt; options.dirverbose = True
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import dir_
</span><span class="noop">    &gt;&gt;&gt; class Test(object):
</span><span class="noop">    ...     only_public_attribute =  None
</span><span class="noop">    &gt;&gt;&gt; print(len(dir_(Test())) &gt; 1) # Long list, try it yourself...
</span><span class="noop">    True
</span><span class="noop">
</span><span class="noop">    If the option is set to `False`, only the `public` attributes and methods
</span><span class="noop">    (which do need begin with `_`) are returned:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; options.dirverbose = False
</span><span class="noop">    &gt;&gt;&gt; print(dir_(Test())) # Short list with one single entry...
</span><span class="noop">    [&#39;only_public_attribute&#39;]
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    from hydpy.pub import options
</span><span class="hit">    names = set()
</span><span class="hit">    for thing in list(inspect.getmro(type(self))) + [self]:
</span><span class="hit">        for name in vars(thing).keys():
</span><span class="hit">            if options.dirverbose or not name.startswith(&#39;_&#39;):
</span><span class="hit">                names.add(name)
</span><span class="hit">    if names:
</span><span class="hit">        names = list(names)
</span><span class="noop">    else:
</span><span class="miss">        names = [&#39; &#39;]
</span><span class="hit">    return names
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def classname(self):
</span><span class="noop">    &#34;&#34;&#34;Return the class name of the given instance object or class.
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import classname
</span><span class="noop">    &gt;&gt;&gt; from hydpy.pub import options
</span><span class="noop">    &gt;&gt;&gt; print(classname(float))
</span><span class="noop">    float
</span><span class="noop">    &gt;&gt;&gt; print(classname(options))
</span><span class="noop">    Options
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    if not inspect.isclass(self):
</span><span class="hit">        self = type(self)
</span><span class="hit">    return str(self).split(&#34;&#39;&#34;)[1].split(&#39;.&#39;)[-1]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def instancename(self):
</span><span class="noop">    &#34;&#34;&#34;Return the class name of the given instance object or class in lower
</span><span class="noop">    case letters.
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import instancename
</span><span class="noop">    &gt;&gt;&gt; from hydpy.pub import options
</span><span class="noop">    &gt;&gt;&gt; print(instancename(options))
</span><span class="noop">    options
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    return classname(self).lower()
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def modulename(self):
</span><span class="noop">    &#34;&#34;&#34;Return the module name of the given instance object.
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import modulename
</span><span class="noop">    &gt;&gt;&gt; from hydpy.pub import options
</span><span class="noop">    &gt;&gt;&gt; print(modulename(options))
</span><span class="noop">    objecttools
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    return self.__module__.split(&#39;.&#39;)[-1]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def devicename(self):
</span><span class="noop">    &#34;&#34;&#34;Try to return the name of the (indirect) master
</span><span class="noop">    :class:`~hydpy.core.devicetools.Node` or
</span><span class="noop">    :class:`~hydpy.core.devicetools.Element` instance,
</span><span class="noop">    otherwise return `?`.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    while True:
</span><span class="hit">        device = getattr(self, &#39;element&#39;, getattr(self, &#39;node&#39;, None))
</span><span class="hit">        if device is not None:
</span><span class="miss">            return device.name
</span><span class="hit">        for test in (&#39;model&#39;, &#39;seqs&#39;, &#39;subseqs&#39;, &#39;pars&#39;, &#39;subpars&#39;):
</span><span class="hit">            master = getattr(self, test, None)
</span><span class="hit">            if master is not None:
</span><span class="hit">                self = master
</span><span class="hit">                break
</span><span class="noop">        else:
</span><span class="hit">            return &#39;?&#39;
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def augmentexcmessage(prefix=None, suffix=None):
</span><span class="noop">    &#34;&#34;&#34;Augment an exception message with additional information while keeping
</span><span class="noop">    the original traceback.
</span><span class="noop">
</span><span class="noop">    You can prefix and/or suffix text.  If you prefix something (which happens
</span><span class="noop">    much more often in the HydPy framework), the sub-clause &#39;, the following
</span><span class="noop">    error occured:&#39; is automatically included:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core import objecttools
</span><span class="noop">    &gt;&gt;&gt; import textwrap
</span><span class="noop">    &gt;&gt;&gt; try:
</span><span class="noop">    ...     1 + &#39;1&#39;
</span><span class="noop">    ... except TypeError:
</span><span class="noop">    ...     try:
</span><span class="noop">    ...         prefix = &#39;While showing how prefixing works&#39;
</span><span class="noop">    ...         suffix = &#39;(This is a final remark.)&#39;
</span><span class="noop">    ...         objecttools.augmentexcmessage(prefix, suffix)
</span><span class="noop">    ...     except TypeError as exc:
</span><span class="noop">    ...         for line in textwrap.wrap(exc.args[0], width=76):
</span><span class="noop">    ...             print(line)
</span><span class="noop">    While showing how prefixing works, the following error occured: unsupported
</span><span class="noop">    operand type(s) for +: &#39;int&#39; and &#39;str&#39; (This is a final remark.)
</span><span class="noop">
</span><span class="noop">    Note that the ancillary purpose of function :func:`augmentexcmessage` is
</span><span class="noop">    to make re-raising exceptions compatible with both Python 2 and 3.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    from hydpy.pub import pyversion
</span><span class="hit">    exception, message, traceback_ = sys.exc_info()
</span><span class="hit">    if prefix is not None:
</span><span class="hit">        message = (&#39;%s, the following error occured: %s&#39;
</span><span class="noop">                   % (prefix, message))
</span><span class="hit">    if suffix is not None:
</span><span class="hit">        message = &#39; &#39;.join((message, suffix))
</span><span class="hit">    if pyversion &lt; 3:
</span><span class="hit">        exec(&#39;raise exception, message, traceback_&#39;)
</span><span class="noop">    else:
</span><span class="miss">        raise exception(message).with_traceback(traceback_)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def description(self):
</span><span class="noop">    &#34;&#34;&#34;Returns the first &#34;paragraph&#34; of the docstring of the given object.
</span><span class="noop">
</span><span class="noop">    Note that ugly things like multiple whitespaces and newline characters
</span><span class="noop">    are removed:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core import objecttools
</span><span class="noop">    &gt;&gt;&gt; objecttools.description(objecttools.augmentexcmessage)
</span><span class="noop">    &#39;Augment an exception message with additional information while keeping the original traceback.&#39;
</span><span class="noop">
</span><span class="noop">    In case the given object does not define a docstring, the following
</span><span class="noop">    is returned:
</span><span class="noop">    &gt;&gt;&gt; objecttools.description(type(&#39;Test&#39;, (), {}))
</span><span class="noop">    &#39;no description available&#39;
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    if self.__doc__ in (None, &#39;&#39;):
</span><span class="hit">        return &#39;no description available&#39;
</span><span class="noop">    else:
</span><span class="hit">        return &#39; &#39;.join(self.__doc__.split(&#39;\n\n&#39;)[0].split())
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def repr_(value):
</span><span class="noop">    &#34;&#34;&#34;Modifies :func:`repr` for strings and floats, mainly for supporting
</span><span class="noop">    clean float representations that are compatible with :mod:`doctest`.
</span><span class="noop">
</span><span class="noop">    When value is a string, it is returned without any modification:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import repr_
</span><span class="noop">    &gt;&gt;&gt; repr(&#39;test&#39;)
</span><span class="noop">    &#34;&#39;test&#39;&#34;
</span><span class="noop">    &gt;&gt;&gt; repr_(&#39;test&#39;)
</span><span class="noop">    &#39;test&#39;
</span><span class="noop">
</span><span class="noop">    When value is a float, the result depends on how the option
</span><span class="noop">    :attr:`~Options.reprdigits` is set. If it is :class:`None`, :func:`repr`
</span><span class="noop">    defines the number of digits in the usual, system dependend manner:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.pub import options
</span><span class="noop">    &gt;&gt;&gt; options.reprdigits = None
</span><span class="noop">    &gt;&gt;&gt; repr(1./3.) == repr_(1./3.)
</span><span class="noop">    True
</span><span class="noop">
</span><span class="noop">    Through setting :attr:`~Options.reprdigits` to a positive integer value,
</span><span class="noop">    one defines the maximum number of decimal places, which allows for
</span><span class="noop">    doctesting across different systems and Python versions:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; options.reprdigits = 6
</span><span class="noop">    &gt;&gt;&gt; repr_(1./3.)
</span><span class="noop">    &#39;0.333333&#39;
</span><span class="noop">    &gt;&gt;&gt; repr_(2./3.)
</span><span class="noop">    &#39;0.666667&#39;
</span><span class="noop">    &gt;&gt;&gt; repr_(1./2.)
</span><span class="noop">    &#39;0.5&#39;
</span><span class="noop">
</span><span class="noop">    :func:`repr_` can also be applied on numpy&#39;s float types:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; import numpy
</span><span class="noop">    &gt;&gt;&gt; repr_(numpy.float(1./3.))
</span><span class="noop">    &#39;0.333333&#39;
</span><span class="noop">    &gt;&gt;&gt; repr_(numpy.float64(1./3.))
</span><span class="noop">    &#39;0.333333&#39;
</span><span class="noop">    &gt;&gt;&gt; repr_(numpy.float32(1./3.))
</span><span class="noop">    &#39;0.333333&#39;
</span><span class="noop">    &gt;&gt;&gt; repr_(numpy.float16(1./3.))
</span><span class="noop">    &#39;0.333252&#39;
</span><span class="noop">
</span><span class="noop">    Note that the deviation from the `true` result in the last example is due
</span><span class="noop">    to the low precision of :class:`~numpy.float16`.
</span><span class="noop">
</span><span class="noop">    On all types not mentioned above, the usual :func:`repr` function is
</span><span class="noop">    applied, e.g.:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; repr([1, 2, 3])
</span><span class="noop">    &#39;[1, 2, 3]&#39;
</span><span class="noop">    &gt;&gt;&gt; repr_([1, 2, 3])
</span><span class="noop">    &#39;[1, 2, 3]&#39;
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    from hydpy.pub import options
</span><span class="hit">    if isinstance(value, (pointer.Double, pointer.PDouble)):
</span><span class="hit">        value = float(value)
</span><span class="hit">    if isinstance(value, str):
</span><span class="hit">        return value
</span><span class="hit">    elif ((options.reprdigits is not None) and
</span><span class="noop">          isinstance(value,
</span><span class="noop">                     (float, numpy.float64, numpy.float32, numpy.float16))):
</span><span class="hit">        string = &#39;{0:.{1}f}&#39;.format(value, options.reprdigits)
</span><span class="hit">        string = string.rstrip(&#39;0&#39;)
</span><span class="hit">        if string.endswith(&#39;.&#39;):
</span><span class="hit">            string += &#39;0&#39;
</span><span class="hit">        return string
</span><span class="noop">    else:
</span><span class="hit">        return repr(value)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def round_(value, rjust=0, **kwargs):
</span><span class="noop">    &#34;&#34;&#34;Shortcut for `print(repr_(value), **kwargs)`.
</span><span class="noop">
</span><span class="noop">    See the documentation on function :func:`repr_` for any details.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    print(repr_(value).rjust(rjust), **kwargs)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Options(object):
</span><span class="noop">    &#34;&#34;&#34;Singleton class for `global` options.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        self._printprogress = True
</span><span class="hit">        self._verbosedir = False
</span><span class="hit">        self._reprcomments = True
</span><span class="hit">        self._usecython = True
</span><span class="hit">        self._skipdoctests = False
</span><span class="hit">        self._refreshmodels = False
</span><span class="hit">        self._reprdigits = None
</span><span class="hit">        self._warntrim = True
</span><span class="hit">        self._warnsimulationstep = True
</span><span class="hit">        self._checkseries = True
</span><span class="hit">        self._warnmissingcontrolfile = False
</span><span class="hit">        self._warnmissingobsfile = True
</span><span class="hit">        self._warnmissingsimfile = True
</span><span class="hit">        self._usedefaultvalues = False
</span><span class="noop">
</span><span class="hit">    def _getprintprogress(self):
</span><span class="noop">        &#34;&#34;&#34;True/False flag indicating whether information about the progress
</span><span class="noop">        of certain processes shall be printed to the standard output or not.
</span><span class="noop">        The default is `True`.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return self._printprogress
</span><span class="noop">
</span><span class="hit">    def _setprintprogress(self, value):
</span><span class="hit">        self._printprogress = bool(value)
</span><span class="noop">
</span><span class="hit">    printprogress = property(_getprintprogress, _setprintprogress)
</span><span class="noop">
</span><span class="hit">    def _getdirverbose(self):
</span><span class="noop">        &#34;&#34;&#34;True/False flag indicationg whether the listboxes for the member
</span><span class="noop">        selection of the classes of the HydPy framework should be complete
</span><span class="noop">        (True) or restrictive (False).  The latter is more viewable and hence
</span><span class="noop">        the default.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return self._verbosedir
</span><span class="noop">
</span><span class="hit">    def _setdirverbose(self, value):
</span><span class="hit">        self._verbosedir = bool(value)
</span><span class="noop">
</span><span class="hit">    dirverbose = property(_getdirverbose, _setdirverbose)
</span><span class="noop">
</span><span class="hit">    def _getreprcomments(self):
</span><span class="noop">        &#34;&#34;&#34;True/False flag indicationg whether comments shall be included
</span><span class="noop">        in string representations of some classes of the HydPy framework or
</span><span class="noop">        not.  The default is `True`.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return self._reprcomments
</span><span class="noop">
</span><span class="hit">    def _setreprcomments(self, value):
</span><span class="hit">        self._reprcomments = bool(value)
</span><span class="noop">
</span><span class="hit">    reprcomments = property(_getreprcomments, _setreprcomments)
</span><span class="noop">
</span><span class="hit">    def _getusecython(self):
</span><span class="noop">        &#34;&#34;&#34;True/False flag indicating whether Cython models (True) or pure
</span><span class="noop">        Python models (False) shall be applied if possible.  Using Cython
</span><span class="noop">        models is more time efficient and thus the default.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return self._usecython
</span><span class="noop">
</span><span class="hit">    def _setusecython(self, value):
</span><span class="hit">        self._usecython = bool(value)
</span><span class="noop">
</span><span class="hit">    usecython = property(_getusecython, _setusecython)
</span><span class="noop">
</span><span class="hit">    def _getskipdoctests(self):
</span><span class="noop">        &#34;&#34;&#34;True/False flag indicating whether documetation tests shall be
</span><span class="noop">        performed under certain situations.  Applying tests increases
</span><span class="noop">        reliabilty and is thus the default.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return self._skipdoctests
</span><span class="noop">
</span><span class="hit">    def _setskipdoctests(self, value):
</span><span class="hit">        self._skipdoctests = bool(value)
</span><span class="noop">
</span><span class="hit">    skipdoctests = property(_getskipdoctests, _setskipdoctests)
</span><span class="noop">
</span><span class="hit">    def _getreprdigits(self):
</span><span class="noop">        &#34;&#34;&#34;Required precision of string representations of floating point
</span><span class="noop">        numbers, defined as the minimum number of digits to be reproduced
</span><span class="noop">        by the string representation (see function :func:`repr_`).
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return self._reprdigits
</span><span class="noop">
</span><span class="hit">    def _setreprdigits(self, value):
</span><span class="hit">        if value is None:
</span><span class="hit">            self._reprdigits = value
</span><span class="noop">        else:
</span><span class="hit">            self._reprdigits = int(value)
</span><span class="noop">
</span><span class="hit">    reprdigits = property(_getreprdigits, _setreprdigits)
</span><span class="noop">
</span><span class="hit">    def _getwarntrim(self):
</span><span class="noop">        &#34;&#34;&#34;True/False flag indicating whether a warning shall be raised
</span><span class="noop">        whenever certain values needed to be trimmed due to violating
</span><span class="noop">        certain boundaries. Such warnings increase savety and are thus
</span><span class="noop">        the default is `True`.  However, to cope with the limited precision
</span><span class="noop">        of floating point numbers only those violations beyond a small
</span><span class="noop">        tolerance value are reported (see :class:`Trimmer`).  Warnings
</span><span class="noop">        with identical information are reported only once.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return self._warntrim
</span><span class="noop">
</span><span class="hit">    def _setwarntrim(self, value):
</span><span class="hit">        self._warntrim = bool(value)
</span><span class="noop">
</span><span class="hit">    warntrim = property(_getwarntrim, _setwarntrim)
</span><span class="noop">
</span><span class="hit">    def _getwarnsimulationstep(self):
</span><span class="noop">        &#34;&#34;&#34;True/False flag indicating whether a warning shall be raised
</span><span class="noop">        when function :func:`~hydpy.core.magictools.simulationstep` is
</span><span class="noop">        called for the first time.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return self._warnsimulationstep
</span><span class="noop">
</span><span class="hit">    def _setwarnsimulationstep(self, value):
</span><span class="hit">        self._warnsimulationstep = bool(value)
</span><span class="noop">
</span><span class="hit">    warnsimulationstep = property(_getwarnsimulationstep,
</span><span class="noop">                                  _setwarnsimulationstep)
</span><span class="noop">
</span><span class="hit">    def _getcheckseries(self):
</span><span class="noop">        &#34;&#34;&#34;True/False flag indicating whether an error shall be raised
</span><span class="noop">        when e.g. an incomplete input time series, not spanning the whole
</span><span class="noop">        initialization time period, is loaded.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        return self._checkseries
</span><span class="noop">
</span><span class="hit">    def _setcheckseries(self, value):
</span><span class="miss">        self._checkseries = bool(value)
</span><span class="noop">
</span><span class="hit">    checkseries = property(_getcheckseries, _setcheckseries)
</span><span class="noop">
</span><span class="hit">    def _getwarnmissingcontrolfile(self):
</span><span class="noop">        &#34;&#34;&#34;True/False flag indicating whether only a warning shall be raised
</span><span class="noop">        when a required control file is missing, or an exception.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        return self._warnmissingcontrolfile
</span><span class="noop">
</span><span class="hit">    def _setwarnmissingcontrolfile(self, value):
</span><span class="miss">        self._warnmissingcontrolfile = bool(value)
</span><span class="noop">
</span><span class="hit">    warnmissingcontrolfile = property(_getwarnmissingcontrolfile,
</span><span class="noop">                                      _setwarnmissingcontrolfile)
</span><span class="noop">
</span><span class="hit">    def _getwarnmissingobsfile(self):
</span><span class="noop">        &#34;&#34;&#34;True/False flag indicating whether a warning shall be raised when a
</span><span class="noop">        requested observation sequence demanded by a node instance is missing.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        return self._warnmissingobsfile
</span><span class="noop">
</span><span class="hit">    def _setwarnmissingobsfile(self, value):
</span><span class="miss">        self._warnmissingobsfile = bool(value)
</span><span class="noop">
</span><span class="hit">    warnmissingobsfile = property(_getwarnmissingobsfile,
</span><span class="noop">                                  _setwarnmissingobsfile)
</span><span class="noop">
</span><span class="hit">    def _getwarnmissingsimfile(self):
</span><span class="noop">        &#34;&#34;&#34;True/False flag indicating whether a warning shall be raised when a
</span><span class="noop">        requested simulation sequence demanded a node instance is missing.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        return self._warnmissingsimfile
</span><span class="noop">
</span><span class="hit">    def _setwarnmissingsimfile(self, value):
</span><span class="miss">        self._warnmissingsimfile = bool(value)
</span><span class="noop">
</span><span class="hit">    warnmissingsimfile = property(_getwarnmissingsimfile,
</span><span class="noop">                                  _setwarnmissingsimfile)
</span><span class="noop">
</span><span class="hit">    def _getusedefaultvalues(self):
</span><span class="noop">        &#34;&#34;&#34;True/False flag indicating whether parameters values shall be
</span><span class="noop">        initialized with standard values or not.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return self._usedefaultvalues
</span><span class="noop">
</span><span class="hit">    def _setusedefaultvalues(self, value):
</span><span class="hit">        self._usedefaultvalues = bool(value)
</span><span class="noop">
</span><span class="hit">    usedefaultvalues = property(_getusedefaultvalues,
</span><span class="noop">                                _setusedefaultvalues)
</span><span class="noop">
</span><span class="hit">    __dir__ = dir_
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def trim(self, lower=None, upper=None):
</span><span class="noop">    &#34;&#34;&#34;Trim the value(s) of  a :class:`ValueMath` instance.
</span><span class="noop">
</span><span class="noop">    One can pass the lower and/or the upper boundary as a function argument.
</span><span class="noop">    Otherwise, boundary values are taken from the class attribute `SPAN`
</span><span class="noop">    of the given :class:`ValueMath` instance, if available.
</span><span class="noop">
</span><span class="noop">    Note that method :func:`trim` works differently on :class:`ValueMath`
</span><span class="noop">    instances handling values of different types.  For floating point values,
</span><span class="noop">    an actual trimming is performed.  Additionally, a warning message is
</span><span class="noop">    raised if the trimming results in a change in value exceeding the
</span><span class="noop">    threshold value defined by function :func:`_tolerance`.  (This warning
</span><span class="noop">    message can be suppressed by setting the related option flag to False.)
</span><span class="noop">    For integer values, instead of a warning an exception is raised.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    span = getattr(self, &#39;SPAN&#39;, (None, None))
</span><span class="hit">    if lower is None:
</span><span class="hit">        lower = span[0]
</span><span class="hit">    if upper is None:
</span><span class="hit">        upper = span[1]
</span><span class="hit">    type_ = getattr(self, &#39;TYPE&#39;, float)
</span><span class="hit">    if type_ is float:
</span><span class="hit">        if self.NDIM == 0:
</span><span class="hit">            _trim_float_0d(self, lower, upper)
</span><span class="noop">        else:
</span><span class="hit">            _trim_float_nd(self, lower, upper)
</span><span class="hit">    elif type_ in (int, bool):
</span><span class="hit">        if self.NDIM == 0:
</span><span class="hit">            _trim_int_0d(self, lower, upper)
</span><span class="noop">        else:
</span><span class="hit">            _trim_int_nd(self, lower, upper)
</span><span class="noop">    else:
</span><span class="miss">        raise NotImplementedError(
</span><span class="noop">            &#39;Method `trim` can only be applied on parameters handling &#39;
</span><span class="noop">            &#39;integer or floating point values, but value type of parameter &#39;
</span><span class="noop">            &#39;`%s` is `%s`.&#39; % (self.name, classname(self.TYPE)))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def _trim_float_0d(self, lower, upper):
</span><span class="hit">    from hydpy.pub import options
</span><span class="hit">    if numpy.isnan(self.value):
</span><span class="miss">        return
</span><span class="hit">    if (lower is None) or numpy.isnan(lower):
</span><span class="hit">        lower = -numpy.inf
</span><span class="hit">    if (upper is None) or numpy.isnan(upper):
</span><span class="hit">        upper = numpy.inf
</span><span class="hit">    if self &lt; lower:
</span><span class="hit">        if (self+_tolerance(self)) &lt; (lower-_tolerance(lower)):
</span><span class="hit">            if options.warntrim:
</span><span class="miss">                self.warntrim()
</span><span class="hit">        self.value = lower
</span><span class="hit">    elif self &gt; upper:
</span><span class="hit">        if (self-_tolerance(self)) &gt; (upper+_tolerance(upper)):
</span><span class="hit">            if options.warntrim:
</span><span class="miss">                self.warntrim()
</span><span class="hit">        self.value = upper
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def _trim_float_nd(self, lower, upper):
</span><span class="hit">    from hydpy.pub import options
</span><span class="hit">    if lower is None:
</span><span class="hit">        lower = -numpy.inf
</span><span class="hit">    lower = numpy.full(self.shape, lower, dtype=float)
</span><span class="hit">    lower[numpy.where(numpy.isnan(lower))] = -numpy.inf
</span><span class="hit">    if upper is None:
</span><span class="hit">        upper = numpy.inf
</span><span class="hit">    upper = numpy.full(self.shape, upper, dtype=float)
</span><span class="hit">    upper[numpy.where(numpy.isnan(upper))] = numpy.inf
</span><span class="hit">    idxs = numpy.where(numpy.isnan(self.values))
</span><span class="hit">    self[idxs] = lower[idxs]
</span><span class="hit">    if numpy.any(self &lt; lower) or numpy.any(self &gt; upper):
</span><span class="hit">        if (numpy.any((self+_tolerance(self)) &lt;
</span><span class="noop">                      (lower-_tolerance(lower))) or
</span><span class="noop">                numpy.any((self-_tolerance(self)) &gt;
</span><span class="noop">                          (upper+_tolerance(upper)))):
</span><span class="hit">            if options.warntrim:
</span><span class="miss">                self.warntrim()
</span><span class="hit">        self.values = numpy.clip(self.values, lower, upper)
</span><span class="hit">    self[idxs] = numpy.nan
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def _trim_int_0d(self, lower, upper):
</span><span class="hit">    if lower is None:
</span><span class="miss">        lower = _INT_NAN
</span><span class="hit">    if upper is None:
</span><span class="hit">        upper = -_INT_NAN
</span><span class="hit">    if (self != _INT_NAN) and ((self &lt; lower) or (self &gt; upper)):
</span><span class="miss">        raise ValueError(
</span><span class="noop">            &#39;The value `%d` of parameter `%s` of element `%s` is not valid.  &#39;
</span><span class="noop">            % (self.value, self.name, devicename(self)))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def _trim_int_nd(self, lower, upper):
</span><span class="hit">    if lower is None:
</span><span class="hit">        lower = _INT_NAN
</span><span class="hit">    lower = numpy.full(self.shape, lower, dtype=int)
</span><span class="hit">    if upper is None:
</span><span class="hit">        upper = -_INT_NAN
</span><span class="hit">    upper = numpy.full(self.shape, upper, dtype=int)
</span><span class="hit">    idxs = numpy.where(self == _INT_NAN)
</span><span class="hit">    self[idxs] = lower[idxs]
</span><span class="hit">    if numpy.any(self &lt; lower) or numpy.any(self &gt; upper):
</span><span class="miss">        raise ValueError(
</span><span class="noop">            &#39;At least one value of parameter `%s` of element `%s` is not &#39;
</span><span class="noop">            &#39;valid.&#39; % (self.name, devicename(self)))
</span><span class="hit">    self[idxs] = _INT_NAN
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def _tolerance(values):
</span><span class="noop">    &#34;&#34;&#34;Returns some sort of &#34;numerical accuracy&#34; to be expected for the
</span><span class="noop">    given floating point value, see method :func:`trim`.&#34;&#34;&#34;
</span><span class="hit">    return abs(values*1e-15)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ValueMath(object):
</span><span class="noop">    &#34;&#34;&#34;Base class for :class:`~hydpy.core.parametertools.Parameter` and
</span><span class="noop">    :class:`~hydpy.core.sequencetools.Sequence`.  Implements special
</span><span class="noop">    methods for arithmetic calculations, comparisons and type conversions.
</span><span class="noop">
</span><span class="noop">    The subclasses are required to provide the members `NDIM` (usually a
</span><span class="noop">    class attribute) and `value` (usually a property).  But for testing
</span><span class="noop">    purposes, one can simply add them as instance attributes.
</span><span class="noop">
</span><span class="noop">    A few examples for 0-dimensional objects:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.objecttools import ValueMath
</span><span class="noop">    &gt;&gt;&gt; vm0 = ValueMath()
</span><span class="noop">    &gt;&gt;&gt; vm0.NDIM = 0
</span><span class="noop">    &gt;&gt;&gt; vm0.value = 2.
</span><span class="noop">    &gt;&gt;&gt; print(vm0 + vm0)
</span><span class="noop">    4.0
</span><span class="noop">    &gt;&gt;&gt; print(3. - vm0)
</span><span class="noop">    1.0
</span><span class="noop">    &gt;&gt;&gt; vm0 /= 2.
</span><span class="noop">    &gt;&gt;&gt; print(vm0.value)
</span><span class="noop">    1.0
</span><span class="noop">    &gt;&gt;&gt; print(vm0 &gt; vm0)
</span><span class="noop">    False
</span><span class="noop">    &gt;&gt;&gt; print(vm0 != 1.5)
</span><span class="noop">    True
</span><span class="noop">
</span><span class="noop">    Similar examples for 1-dimensional objects:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; import numpy
</span><span class="noop">    &gt;&gt;&gt; vm1 = ValueMath()
</span><span class="noop">    &gt;&gt;&gt; vm1.NDIM = 1
</span><span class="noop">    &gt;&gt;&gt; vm1.value = numpy.array([1.,2.,3.])
</span><span class="noop">    &gt;&gt;&gt; print(vm1 + vm1)
</span><span class="noop">    [ 2.  4.  6.]
</span><span class="noop">    &gt;&gt;&gt; print(3. - vm1)
</span><span class="noop">    [ 2.  1.  0.]
</span><span class="noop">    &gt;&gt;&gt; vm1 /= 2.
</span><span class="noop">    &gt;&gt;&gt; print(vm1.value)
</span><span class="noop">    [ 0.5  1.   1.5]
</span><span class="noop">    &gt;&gt;&gt; print(vm1 &gt; vm1)
</span><span class="noop">    [False False False]
</span><span class="noop">    &gt;&gt;&gt; print(vm1 != 1.5)
</span><span class="noop">    [ True  True False]
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">    # Subclasses need to define...
</span><span class="hit">    NDIM = None  # ... e.g. as class attribute (int)
</span><span class="hit">    name = None  # ... e.g. as property (str)
</span><span class="hit">    value = None  # ... e.g. as property (float or ndarray of dtype float)
</span><span class="noop">    # ...and optionally...
</span><span class="hit">    INIT = None
</span><span class="noop">
</span><span class="hit">    @staticmethod
</span><span class="noop">    def _arithmetic_conversion(other):
</span><span class="hit">        try:
</span><span class="hit">            return other.value
</span><span class="hit">        except AttributeError:
</span><span class="hit">            return other
</span><span class="noop">
</span><span class="hit">    def _arithmetic_exception(self, verb, other):
</span><span class="miss">        augmentexcmessage(&#39;While trying to %s %s instance `%s` and %s `%s`&#39;
</span><span class="noop">                          % (verb, classname(self), self.name,
</span><span class="noop">                             classname(other), other))
</span><span class="noop">
</span><span class="hit">    def __add__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            return self.value + self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;add&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __radd__(self, other):
</span><span class="hit">        return self.__add__(other)
</span><span class="noop">
</span><span class="hit">    def __iadd__(self, other):
</span><span class="miss">        self.value = self.__add__(other)
</span><span class="miss">        return self
</span><span class="noop">
</span><span class="hit">    def __sub__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            return self.value - self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;subtract&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __rsub__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            return self._arithmetic_conversion(other) - self.value
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;subtract&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __isub__(self, other):
</span><span class="miss">        self.value = self.__sub__(other)
</span><span class="miss">        return self
</span><span class="noop">
</span><span class="hit">    def __mul__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            return self.value * self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;multiply&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __rmul__(self, other):
</span><span class="hit">        return self.__mul__(other)
</span><span class="noop">
</span><span class="hit">    def __imul__(self, other):
</span><span class="hit">        self.value = self.__mul__(other)
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def __truediv__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            return self.value / self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;divide&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __rtruediv__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            return self._arithmetic_conversion(other) / self.value
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;divide&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __itruediv__(self, other):
</span><span class="hit">        self.value = self.__truediv__(other)
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def __floordiv__(self, other):
</span><span class="miss">        try:
</span><span class="miss">            return self.value // self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;floor divide&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __rfloordiv__(self, other):
</span><span class="miss">        try:
</span><span class="miss">            return self._arithmetic_conversion(other) // self.value
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;floor divide&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __ifloordiv__(self, other):
</span><span class="miss">        self.value = self.__floordiv__(other)
</span><span class="miss">        return self
</span><span class="noop">
</span><span class="hit">    def __mod__(self, other):
</span><span class="miss">        try:
</span><span class="miss">            return self.value % self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;mod divide&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __rmod__(self, other):
</span><span class="miss">        try:
</span><span class="miss">            return self._arithmetic_conversion(other) % self.value
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;mod divide&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __imod__(self, other):
</span><span class="miss">        self.value = self.__mod__(other)
</span><span class="miss">        return self
</span><span class="noop">
</span><span class="hit">    def __pow__(self, other):
</span><span class="miss">        try:
</span><span class="miss">            return self.value**self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;exponentiate&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __rpow__(self, other):
</span><span class="miss">        try:
</span><span class="miss">            return self._arithmetic_conversion(other)**self.value
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;exponentiate&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __ipow__(self, other):
</span><span class="miss">        self.value = self.__pow__(other)
</span><span class="miss">        return self
</span><span class="noop">
</span><span class="hit">    def __neg__(self):
</span><span class="miss">        return -self.value
</span><span class="noop">
</span><span class="hit">    def __pos__(self):
</span><span class="miss">        return +self.value
</span><span class="noop">
</span><span class="hit">    def __abs__(self):
</span><span class="miss">        return abs(self.value)
</span><span class="noop">
</span><span class="hit">    def __invert__(self):
</span><span class="miss">        return 1./self.value
</span><span class="noop">
</span><span class="hit">    def __lt__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            return self.value &lt; self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;compare (&lt;)&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __le__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            return self.value &lt;= self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;compare (&lt;=)&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __eq__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            return self.value == self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;compare (==)&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __ne__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            return self.value != self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;compare (!=)&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __ge__(self, other):
</span><span class="miss">        try:
</span><span class="miss">            return self.value &gt;= self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;compare (&gt;=)&#39;, other)
</span><span class="noop">
</span><span class="hit">    def __gt__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            return self.value &gt; self._arithmetic_conversion(other)
</span><span class="miss">        except BaseException:
</span><span class="miss">            self._arithmetic_exception(&#39;compare (&gt;)&#39;, other)
</span><span class="noop">
</span><span class="hit">    def _typeconversion(self, type_):
</span><span class="hit">        if not self.NDIM:
</span><span class="hit">            return type_(self.value)
</span><span class="noop">        else:
</span><span class="miss">            raise TypeError(&#39;The %s instance `%s` is %d-dimensional and thus &#39;
</span><span class="noop">                            &#39;cannot be converted to a scalar %s value.&#39;
</span><span class="noop">                            % (classname(self), self.name, self.NDIM,
</span><span class="noop">                               classname(type_)))
</span><span class="noop">
</span><span class="hit">    def __float__(self):
</span><span class="hit">        return self._typeconversion(float)
</span><span class="noop">
</span><span class="hit">    def __int__(self):
</span><span class="miss">        return self._typeconversion(int)
</span><span class="noop">
</span><span class="hit">    def __round__(self, ndigits=0):
</span><span class="miss">        return numpy.round(self.value, ndigits)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/parametertools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/parametertools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
677 &nbsp;
678 &nbsp;
679 &nbsp;
680 &nbsp;
681 &nbsp;
682 &nbsp;
683 &nbsp;
684 &nbsp;
685 &nbsp;
686 &nbsp;
687 &nbsp;
688 &nbsp;
689 &nbsp;
690 &nbsp;
691 &nbsp;
692 &nbsp;
693 &nbsp;
694 &nbsp;
695 &nbsp;
696 &nbsp;
697 &nbsp;
698 &nbsp;
699 &nbsp;
700 &nbsp;
701 &nbsp;
702 &nbsp;
703 &nbsp;
704 &nbsp;
705 &nbsp;
706 &nbsp;
707 &nbsp;
708 &nbsp;
709 &nbsp;
710 &nbsp;
711 &nbsp;
712 &nbsp;
713 &nbsp;
714 &nbsp;
715 &nbsp;
716 &nbsp;
717 &nbsp;
718 &nbsp;
719 &nbsp;
720 &nbsp;
721 &nbsp;
722 &nbsp;
723 &nbsp;
724 &nbsp;
725 &nbsp;
726 &nbsp;
727 &nbsp;
728 &nbsp;
729 &nbsp;
730 &nbsp;
731 &nbsp;
732 &nbsp;
733 &nbsp;
734 &nbsp;
735 &nbsp;
736 &nbsp;
737 &nbsp;
738 &nbsp;
739 &nbsp;
740 &nbsp;
741 &nbsp;
742 &nbsp;
743 &nbsp;
744 &nbsp;
745 &nbsp;
746 &nbsp;
747 &nbsp;
748 &nbsp;
749 &nbsp;
750 &nbsp;
751 &nbsp;
752 &nbsp;
753 &nbsp;
754 &nbsp;
755 &nbsp;
756 &nbsp;
757 &nbsp;
758 &nbsp;
759 &nbsp;
760 &nbsp;
761 &nbsp;
762 &nbsp;
763 &nbsp;
764 &nbsp;
765 &nbsp;
766 &nbsp;
767 &nbsp;
768 &nbsp;
769 &nbsp;
770 &nbsp;
771 &nbsp;
772 &nbsp;
773 &nbsp;
774 &nbsp;
775 &nbsp;
776 &nbsp;
777 &nbsp;
778 &nbsp;
779 &nbsp;
780 &nbsp;
781 &nbsp;
782 &nbsp;
783 &nbsp;
784 &nbsp;
785 &nbsp;
786 &nbsp;
787 &nbsp;
788 &nbsp;
789 &nbsp;
790 &nbsp;
791 &nbsp;
792 &nbsp;
793 &nbsp;
794 &nbsp;
795 &nbsp;
796 &nbsp;
797 &nbsp;
798 &nbsp;
799 &nbsp;
800 &nbsp;
801 &nbsp;
802 &nbsp;
803 &nbsp;
804 &nbsp;
805 &nbsp;
806 &nbsp;
807 &nbsp;
808 &nbsp;
809 &nbsp;
810 &nbsp;
811 &nbsp;
812 &nbsp;
813 &nbsp;
814 &nbsp;
815 &nbsp;
816 &nbsp;
817 &nbsp;
818 &nbsp;
819 &nbsp;
820 &nbsp;
821 &nbsp;
822 &nbsp;
823 &nbsp;
824 &nbsp;
825 &nbsp;
826 &nbsp;
827 &nbsp;
828 &nbsp;
829 &nbsp;
830 &nbsp;
831 &nbsp;
832 &nbsp;
833 &nbsp;
834 &nbsp;
835 &nbsp;
836 &nbsp;
837 &nbsp;
838 &nbsp;
839 &nbsp;
840 &nbsp;
841 &nbsp;
842 &nbsp;
843 &nbsp;
844 &nbsp;
845 &nbsp;
846 &nbsp;
847 &nbsp;
848 &nbsp;
849 &nbsp;
850 &nbsp;
851 &nbsp;
852 &nbsp;
853 &nbsp;
854 &nbsp;
855 &nbsp;
856 &nbsp;
857 &nbsp;
858 &nbsp;
859 &nbsp;
860 &nbsp;
861 &nbsp;
862 &nbsp;
863 &nbsp;
864 &nbsp;
865 &nbsp;
866 &nbsp;
867 &nbsp;
868 &nbsp;
869 &nbsp;
870 &nbsp;
871 &nbsp;
872 &nbsp;
873 &nbsp;
874 &nbsp;
875 &nbsp;
876 &nbsp;
877 &nbsp;
878 &nbsp;
879 &nbsp;
880 &nbsp;
881 &nbsp;
882 &nbsp;
883 &nbsp;
884 &nbsp;
885 &nbsp;
886 &nbsp;
887 &nbsp;
888 &nbsp;
889 &nbsp;
890 &nbsp;
891 &nbsp;
892 &nbsp;
893 &nbsp;
894 &nbsp;
895 &nbsp;
896 &nbsp;
897 &nbsp;
898 &nbsp;
899 &nbsp;
900 &nbsp;
901 &nbsp;
902 &nbsp;
903 &nbsp;
904 &nbsp;
905 &nbsp;
906 &nbsp;
907 &nbsp;
908 &nbsp;
909 &nbsp;
910 &nbsp;
911 &nbsp;
912 &nbsp;
913 &nbsp;
914 &nbsp;
915 &nbsp;
916 &nbsp;
917 &nbsp;
918 &nbsp;
919 &nbsp;
920 &nbsp;
921 &nbsp;
922 &nbsp;
923 &nbsp;
924 &nbsp;
925 &nbsp;
926 &nbsp;
927 &nbsp;
928 &nbsp;
929 &nbsp;
930 &nbsp;
931 &nbsp;
932 &nbsp;
933 &nbsp;
934 &nbsp;
935 &nbsp;
936 &nbsp;
937 &nbsp;
938 &nbsp;
939 &nbsp;
940 &nbsp;
941 &nbsp;
942 &nbsp;
943 &nbsp;
944 &nbsp;
945 &nbsp;
946 &nbsp;
947 &nbsp;
948 &nbsp;
949 &nbsp;
950 &nbsp;
951 &nbsp;
952 &nbsp;
953 &nbsp;
954 &nbsp;
955 &nbsp;
956 &nbsp;
957 &nbsp;
958 &nbsp;
959 &nbsp;
960 &nbsp;
961 &nbsp;
962 &nbsp;
963 &nbsp;
964 &nbsp;
965 &nbsp;
966 &nbsp;
967 &nbsp;
968 &nbsp;
969 &nbsp;
970 &nbsp;
971 &nbsp;
972 &nbsp;
973 &nbsp;
974 &nbsp;
975 &nbsp;
976 &nbsp;
977 &nbsp;
978 &nbsp;
979 &nbsp;
980 &nbsp;
981 &nbsp;
982 &nbsp;
983 &nbsp;
984 &nbsp;
985 &nbsp;
986 &nbsp;
987 &nbsp;
988 &nbsp;
989 &nbsp;
990 &nbsp;
991 &nbsp;
992 &nbsp;
993 &nbsp;
994 &nbsp;
995 &nbsp;
996 &nbsp;
997 &nbsp;
998 &nbsp;
999 &nbsp;
1000 &nbsp;
1001 &nbsp;
1002 &nbsp;
1003 &nbsp;
1004 &nbsp;
1005 &nbsp;
1006 &nbsp;
1007 &nbsp;
1008 &nbsp;
1009 &nbsp;
1010 &nbsp;
1011 &nbsp;
1012 &nbsp;
1013 &nbsp;
1014 &nbsp;
1015 &nbsp;
1016 &nbsp;
1017 &nbsp;
1018 &nbsp;
1019 &nbsp;
1020 &nbsp;
1021 &nbsp;
1022 &nbsp;
1023 &nbsp;
1024 &nbsp;
1025 &nbsp;
1026 &nbsp;
1027 &nbsp;
1028 &nbsp;
1029 &nbsp;
1030 &nbsp;
1031 &nbsp;
1032 &nbsp;
1033 &nbsp;
1034 &nbsp;
1035 &nbsp;
1036 &nbsp;
1037 &nbsp;
1038 &nbsp;
1039 &nbsp;
1040 &nbsp;
1041 &nbsp;
1042 &nbsp;
1043 &nbsp;
1044 &nbsp;
1045 &nbsp;
1046 &nbsp;
1047 &nbsp;
1048 &nbsp;
1049 &nbsp;
1050 &nbsp;
1051 &nbsp;
1052 &nbsp;
1053 &nbsp;
1054 &nbsp;
1055 &nbsp;
1056 &nbsp;
1057 &nbsp;
1058 &nbsp;
1059 &nbsp;
1060 &nbsp;
1061 &nbsp;
1062 &nbsp;
1063 &nbsp;
1064 &nbsp;
1065 &nbsp;
1066 &nbsp;
1067 &nbsp;
1068 &nbsp;
1069 &nbsp;
1070 &nbsp;
1071 &nbsp;
1072 &nbsp;
1073 &nbsp;
1074 &nbsp;
1075 &nbsp;
1076 &nbsp;
1077 &nbsp;
1078 &nbsp;
1079 &nbsp;
1080 &nbsp;
1081 &nbsp;
1082 &nbsp;
1083 &nbsp;
1084 &nbsp;
1085 &nbsp;
1086 &nbsp;
1087 &nbsp;
1088 &nbsp;
1089 &nbsp;
1090 &nbsp;
1091 &nbsp;
1092 &nbsp;
1093 &nbsp;
1094 &nbsp;
1095 &nbsp;
1096 &nbsp;
1097 &nbsp;
1098 &nbsp;
1099 &nbsp;
1100 &nbsp;
1101 &nbsp;
1102 &nbsp;
1103 &nbsp;
1104 &nbsp;
1105 &nbsp;
1106 &nbsp;
1107 &nbsp;
1108 &nbsp;
1109 &nbsp;
1110 &nbsp;
1111 &nbsp;
1112 &nbsp;
1113 &nbsp;
1114 &nbsp;
1115 &nbsp;
1116 &nbsp;
1117 &nbsp;
1118 &nbsp;
1119 &nbsp;
1120 &nbsp;
1121 &nbsp;
1122 &nbsp;
1123 &nbsp;
1124 &nbsp;
1125 &nbsp;
1126 &nbsp;
1127 &nbsp;
1128 &nbsp;
1129 &nbsp;
1130 &nbsp;
1131 &nbsp;
1132 &nbsp;
1133 &nbsp;
1134 &nbsp;
1135 &nbsp;
1136 &nbsp;
1137 &nbsp;
1138 &nbsp;
1139 &nbsp;
1140 &nbsp;
1141 &nbsp;
1142 &nbsp;
1143 &nbsp;
1144 &nbsp;
1145 &nbsp;
1146 &nbsp;
1147 &nbsp;
1148 &nbsp;
1149 &nbsp;
1150 &nbsp;
1151 &nbsp;
1152 &nbsp;
1153 &nbsp;
1154 &nbsp;
1155 &nbsp;
1156 &nbsp;
1157 &nbsp;
1158 &nbsp;
1159 &nbsp;
1160 &nbsp;
1161 &nbsp;
1162 &nbsp;
1163 &nbsp;
1164 &nbsp;
1165 &nbsp;
1166 &nbsp;
1167 &nbsp;
1168 &nbsp;
1169 &nbsp;
1170 &nbsp;
1171 &nbsp;
1172 &nbsp;
1173 &nbsp;
1174 &nbsp;
1175 &nbsp;
1176 &nbsp;
1177 &nbsp;
1178 &nbsp;
1179 &nbsp;
1180 &nbsp;
1181 &nbsp;
1182 &nbsp;
1183 &nbsp;
1184 &nbsp;
1185 &nbsp;
1186 &nbsp;
1187 &nbsp;
1188 &nbsp;
1189 &nbsp;
1190 &nbsp;
1191 &nbsp;
1192 &nbsp;
1193 &nbsp;
1194 &nbsp;
1195 &nbsp;
1196 &nbsp;
1197 &nbsp;
1198 &nbsp;
1199 &nbsp;
1200 &nbsp;
1201 &nbsp;
1202 &nbsp;
1203 &nbsp;
1204 &nbsp;
1205 &nbsp;
1206 &nbsp;
1207 &nbsp;
1208 &nbsp;
1209 &nbsp;
1210 &nbsp;
1211 &nbsp;
1212 &nbsp;
1213 &nbsp;
1214 &nbsp;
1215 &nbsp;
1216 &nbsp;
1217 &nbsp;
1218 &nbsp;
1219 &nbsp;
1220 &nbsp;
1221 &nbsp;
1222 &nbsp;
1223 &nbsp;
1224 &nbsp;
1225 &nbsp;
1226 &nbsp;
1227 &nbsp;
1228 &nbsp;
1229 &nbsp;
1230 &nbsp;
1231 &nbsp;
1232 &nbsp;
1233 &nbsp;
1234 &nbsp;
1235 &nbsp;
1236 &nbsp;
1237 &nbsp;
1238 &nbsp;
1239 &nbsp;
1240 &nbsp;
1241 &nbsp;
1242 &nbsp;
1243 &nbsp;
1244 &nbsp;
1245 &nbsp;
1246 &nbsp;
1247 &nbsp;
1248 &nbsp;
1249 &nbsp;
1250 &nbsp;
1251 &nbsp;
1252 &nbsp;
1253 &nbsp;
1254 &nbsp;
1255 &nbsp;
1256 &nbsp;
1257 &nbsp;
1258 &nbsp;
1259 &nbsp;
1260 &nbsp;
1261 &nbsp;
1262 &nbsp;
1263 &nbsp;
1264 &nbsp;
1265 &nbsp;
1266 &nbsp;
1267 &nbsp;
1268 &nbsp;
1269 &nbsp;
1270 &nbsp;
1271 &nbsp;
1272 &nbsp;
1273 &nbsp;
1274 &nbsp;
1275 &nbsp;
1276 &nbsp;
1277 &nbsp;
1278 &nbsp;
1279 &nbsp;
1280 &nbsp;
1281 &nbsp;
1282 &nbsp;
1283 &nbsp;
1284 &nbsp;
1285 &nbsp;
1286 &nbsp;
1287 &nbsp;
1288 &nbsp;
1289 &nbsp;
1290 &nbsp;
1291 &nbsp;
1292 &nbsp;
1293 &nbsp;
1294 &nbsp;
1295 &nbsp;
1296 &nbsp;
1297 &nbsp;
1298 &nbsp;
1299 &nbsp;
1300 &nbsp;
1301 &nbsp;
1302 &nbsp;
1303 &nbsp;
1304 &nbsp;
1305 &nbsp;
1306 &nbsp;
1307 &nbsp;
1308 &nbsp;
1309 &nbsp;
1310 &nbsp;
1311 &nbsp;
1312 &nbsp;
1313 &nbsp;
1314 &nbsp;
1315 &nbsp;
1316 &nbsp;
1317 &nbsp;
1318 &nbsp;
1319 &nbsp;
1320 &nbsp;
1321 &nbsp;
1322 &nbsp;
1323 &nbsp;
1324 &nbsp;
1325 &nbsp;
1326 &nbsp;
1327 &nbsp;
1328 &nbsp;
1329 &nbsp;
1330 &nbsp;
1331 &nbsp;
1332 &nbsp;
1333 &nbsp;
1334 &nbsp;
1335 &nbsp;
1336 &nbsp;
1337 &nbsp;
1338 &nbsp;
1339 &nbsp;
1340 &nbsp;
1341 &nbsp;
1342 &nbsp;
1343 &nbsp;
1344 &nbsp;
1345 &nbsp;
1346 &nbsp;
1347 &nbsp;
1348 &nbsp;
1349 &nbsp;
1350 &nbsp;
1351 &nbsp;
1352 &nbsp;
1353 &nbsp;
1354 &nbsp;
1355 &nbsp;
1356 &nbsp;
1357 &nbsp;
1358 &nbsp;
1359 &nbsp;
1360 &nbsp;
1361 &nbsp;
1362 &nbsp;
1363 &nbsp;
1364 &nbsp;
1365 &nbsp;
1366 &nbsp;
1367 &nbsp;
1368 &nbsp;
1369 &nbsp;
1370 &nbsp;
1371 &nbsp;
1372 &nbsp;
1373 &nbsp;
1374 &nbsp;
1375 &nbsp;
1376 &nbsp;
1377 &nbsp;
1378 &nbsp;
1379 &nbsp;
1380 &nbsp;
1381 &nbsp;
1382 &nbsp;
1383 &nbsp;
1384 &nbsp;
1385 &nbsp;
1386 &nbsp;
1387 &nbsp;
1388 &nbsp;
1389 &nbsp;
1390 &nbsp;
1391 &nbsp;
1392 &nbsp;
1393 &nbsp;
1394 &nbsp;
1395 &nbsp;
1396 &nbsp;
1397 &nbsp;
1398 &nbsp;
1399 &nbsp;
1400 &nbsp;
1401 &nbsp;
1402 &nbsp;
1403 &nbsp;
1404 &nbsp;
1405 &nbsp;
1406 &nbsp;
1407 &nbsp;
1408 &nbsp;
1409 &nbsp;
1410 &nbsp;
1411 &nbsp;
1412 &nbsp;
1413 &nbsp;
1414 &nbsp;
1415 &nbsp;
1416 &nbsp;
1417 &nbsp;
1418 &nbsp;
1419 &nbsp;
1420 &nbsp;
1421 &nbsp;
1422 &nbsp;
1423 &nbsp;
1424 &nbsp;
1425 &nbsp;
1426 &nbsp;
1427 &nbsp;
1428 &nbsp;
1429 &nbsp;
1430 &nbsp;
1431 &nbsp;
1432 &nbsp;
1433 &nbsp;
1434 &nbsp;
1435 &nbsp;
1436 &nbsp;
1437 &nbsp;
1438 &nbsp;
1439 &nbsp;
1440 &nbsp;
1441 &nbsp;
1442 &nbsp;
1443 &nbsp;
1444 &nbsp;
1445 &nbsp;
1446 &nbsp;
1447 &nbsp;
1448 &nbsp;
1449 &nbsp;
1450 &nbsp;
1451 &nbsp;
1452 &nbsp;
1453 &nbsp;
1454 &nbsp;
1455 &nbsp;
1456 &nbsp;
1457 &nbsp;
1458 &nbsp;
1459 &nbsp;
1460 &nbsp;
1461 &nbsp;
1462 &nbsp;
1463 &nbsp;
1464 &nbsp;
1465 &nbsp;
1466 &nbsp;
1467 &nbsp;
1468 &nbsp;
1469 &nbsp;
1470 &nbsp;
1471 &nbsp;
1472 &nbsp;
1473 &nbsp;
1474 &nbsp;
1475 &nbsp;
1476 &nbsp;
1477 &nbsp;
1478 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...standard
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import os
</span><span class="hit">import inspect
</span><span class="hit">import time
</span><span class="hit">import copy
</span><span class="hit">import textwrap
</span><span class="hit">import warnings
</span><span class="noop"># ...third party
</span><span class="hit">import numpy
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy.core import objecttools
</span><span class="hit">from hydpy.core import filetools
</span><span class="hit">from hydpy.core import timetools
</span><span class="noop">
</span><span class="noop">
</span><span class="noop"># The import of `_strptime` is not thread save.  The following call of
</span><span class="noop"># `strptime` is supposed to prevent possible problems arising from this bug.
</span><span class="hit">time.strptime(&#39;1999&#39;, &#39;%Y&#39;)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Parameters(object):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling all parameters of a specific model.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self, kwargs):
</span><span class="hit">        self.model = kwargs.get(&#39;model&#39;)
</span><span class="hit">        self.control = None
</span><span class="hit">        self.derived = None
</span><span class="hit">        cythonmodule = kwargs.get(&#39;cythonmodule&#39;)
</span><span class="hit">        cymodel = kwargs.get(&#39;cymodel&#39;)
</span><span class="hit">        for (name, cls) in kwargs.items():
</span><span class="hit">            if name.endswith(&#39;Parameters&#39;) and issubclass(cls, SubParameters):
</span><span class="hit">                if cythonmodule:
</span><span class="hit">                    cls_fastaccess = getattr(cythonmodule, name)
</span><span class="hit">                    subpars = cls(self, cls_fastaccess, cymodel)
</span><span class="noop">                else:
</span><span class="hit">                    subpars = cls(self, None, None)
</span><span class="hit">                setattr(self, subpars.name, subpars)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="noop">        &#34;&#34;&#34;Calls the update methods of all derived parameters.&#34;&#34;&#34;
</span><span class="hit">        if self.derived:
</span><span class="hit">            for par in self.derived._PARCLASSES:
</span><span class="hit">                name = objecttools.instancename(par)
</span><span class="hit">                try:
</span><span class="hit">                    self.derived.__dict__[name].update()
</span><span class="miss">                except BaseException:
</span><span class="miss">                    objecttools.augmentexcmessage(
</span><span class="noop">                        &#39;While trying to update the derived parameter `%s` of &#39;
</span><span class="noop">                        &#39;element `%s`&#39; % (name, objecttools.devicename(self)))
</span><span class="noop">
</span><span class="hit">    def savecontrols(self, parameterstep=None, simulationstep=None,
</span><span class="noop">                     filename=None, dirname=None):
</span><span class="miss">        if self.control:
</span><span class="miss">            if filename is None:
</span><span class="miss">                filename = self._controldefaultfilename
</span><span class="miss">            if not filename.endswith(&#39;.py&#39;):
</span><span class="miss">                filename += &#39;.py&#39;
</span><span class="miss">            if dirname is None:
</span><span class="miss">                dirname = pub.controlmanager.controlpath
</span><span class="miss">            filepath = os.path.join(dirname, filename)
</span><span class="miss">            with open(filepath, &#39;w&#39;) as file_:
</span><span class="miss">                file_.write(&#39;from hydpy.models.%s import *\n\n&#39;
</span><span class="noop">                            % self.model.__module__.split(&#39;.&#39;)[2])
</span><span class="miss">                if not parameterstep:
</span><span class="miss">                    parameterstep = pub.timegrids.stepsize
</span><span class="miss">                file_.write(&#39;parameterstep(&#34;%s&#34;)\n&#39; % parameterstep)
</span><span class="miss">                if not simulationstep:
</span><span class="miss">                    simulationstep = pub.timegrids.stepsize
</span><span class="miss">                file_.write(&#39;simulationstep(&#34;%s&#34;)\n\n&#39; % simulationstep)
</span><span class="miss">                for (name, par) in self.control:
</span><span class="miss">                    _parameterstep = par._parameterstep
</span><span class="miss">                    try:
</span><span class="miss">                        par.parameterstep = parameterstep
</span><span class="miss">                        file_.write(repr(par) + &#39;\n&#39;)
</span><span class="noop">                    finally:
</span><span class="miss">                        par._parameterstep = _parameterstep
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def _controldefaultfilename(self):
</span><span class="miss">        filename = objecttools.devicename(self)
</span><span class="miss">        if filename == &#39;?&#39;:
</span><span class="miss">            raise RuntimeError(
</span><span class="noop">                &#39;To save the control parameters of a model to a file, its &#39;
</span><span class="noop">                &#39;filename must be known.  This can be done, by passing &#39;
</span><span class="noop">                &#39;filename to function `savecontrols` directly.  &#39;
</span><span class="noop">                &#39;But in complete HydPy applications, it is usally &#39;
</span><span class="noop">                &#39;assumed to be consistent with the name of the element &#39;
</span><span class="noop">                &#39;handling the model.  Actually, neither a filename is given &#39;
</span><span class="noop">                &#39;nor does the model know its master element.&#39;)
</span><span class="noop">        else:
</span><span class="miss">            return filename + &#39;.py&#39;
</span><span class="noop">
</span><span class="hit">    def verify(self):
</span><span class="noop">        &#34;&#34;&#34;&#34;&#34;&#34;
</span><span class="miss">        for (name, parameter) in self.control:
</span><span class="miss">            parameter.verify()
</span><span class="miss">        for (name, parameter) in self.derived:
</span><span class="miss">            parameter.verify()
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="hit">        for (key, value) in vars(self).items():
</span><span class="hit">            if isinstance(value, SubParameters):
</span><span class="hit">                yield key, value
</span><span class="noop">
</span><span class="hit">    def __len__(self):
</span><span class="miss">        return len(dict(self))
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MetaSubParametersType(type):
</span><span class="hit">    def __new__(cls, name, parents, dict_):
</span><span class="hit">        parclasses = dict_.get(&#39;_PARCLASSES&#39;)
</span><span class="hit">        if parclasses is None:
</span><span class="hit">            raise NotImplementedError(
</span><span class="noop">                &#39;For class `%s`, the required tuple `_PARCLASSES` is not &#39;
</span><span class="noop">                &#39;defined.  Please see the documentation of class &#39;
</span><span class="noop">                &#39;`SubParameters` of module `parametertools` for further &#39;
</span><span class="noop">                &#39;information.&#39; % name)
</span><span class="hit">        if parclasses:
</span><span class="hit">            lst = [&#39;\n\n\n    The following parameter classes are selected:&#39;]
</span><span class="hit">            for parclass in parclasses:
</span><span class="hit">                    lst.append(&#39;      * :class:`~%s` `%s`&#39;
</span><span class="noop">                               % (&#39;.&#39;.join((parclass.__module__,
</span><span class="noop">                                            parclass.__name__)),
</span><span class="noop">                                  objecttools.description(parclass)))
</span><span class="hit">            doc = dict_.get(&#39;__doc__&#39;, None)
</span><span class="hit">            if doc is None:
</span><span class="hit">                doc = &#39;&#39;
</span><span class="hit">            dict_[&#39;__doc__&#39;] = doc + &#39;\n&#39;.join(l for l in lst)
</span><span class="hit">        return type.__new__(cls, name, parents, dict_)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">MetaSubParametersClass = MetaSubParametersType(&#39;MetaSubParametersClass&#39;,
</span><span class="noop">                                               (), {&#39;_PARCLASSES&#39;: ()})
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class SubParameters(MetaSubParametersClass):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling subgroups of model parameters.
</span><span class="noop">
</span><span class="noop">    When trying to implement a new model, one has to define its parameter
</span><span class="noop">    classes.  Currently, the HydPy framework  distinguishes between control
</span><span class="noop">    parameters and derived parameters.  These parameter classes should be
</span><span class="noop">    collected by subclasses of class :class:`SubParameters` called
</span><span class="noop">    `ControlParameters` or `DerivedParameters` respectivly.  This should be
</span><span class="noop">    done via the `_PARCLASSES` tuple in the following manner:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.parametertools import SingleParameter, SubParameters
</span><span class="noop">    &gt;&gt;&gt; class Par2(SingleParameter):
</span><span class="noop">    ...     pass
</span><span class="noop">    &gt;&gt;&gt; class Par1(SingleParameter):
</span><span class="noop">    ...     pass
</span><span class="noop">    &gt;&gt;&gt; class ControlParameters(SubParameters):
</span><span class="noop">    ...     _PARCLASSES = (Par2, Par1)
</span><span class="noop">
</span><span class="noop">    The order within the tuple determines the order of iteration, e.g.:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; control = ControlParameters(None) # Assign `None` for brevity.
</span><span class="noop">    &gt;&gt;&gt; control
</span><span class="noop">    par2(nan)
</span><span class="noop">    par1(nan)
</span><span class="noop">
</span><span class="noop">    If one forgets to define a `_PARCLASSES` tuple so (and maybe tries to add
</span><span class="noop">    the parameters in the constructor of the subclass of
</span><span class="noop">    :class:`SubParameters`, the following error is raised:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; class ControlParameters(SubParameters):
</span><span class="noop">    ...     pass
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    NotImplementedError: For class `ControlParameters`, the required tuple `_PARCLASSES` is not defined.  Please see the documentation of class `SubParameters` of module `parametertools` for further information.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = ()
</span><span class="noop">
</span><span class="hit">    def __init__(self, pars, cls_fastaccess=None, cymodel=None):
</span><span class="hit">        self.pars = pars
</span><span class="hit">        if cls_fastaccess is None:
</span><span class="hit">            self.fastaccess = type(&#39;FastAccess&#39;, (), {})
</span><span class="noop">        else:
</span><span class="hit">            self.fastaccess = cls_fastaccess()
</span><span class="hit">            setattr(cymodel, self.name, self.fastaccess)
</span><span class="hit">        for Par in self._PARCLASSES:
</span><span class="hit">            setattr(self, objecttools.instancename(Par), Par())
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def getname(cls):
</span><span class="hit">        return objecttools.instancename(cls)[:-10]
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def name(self):
</span><span class="hit">        return self.getname()
</span><span class="noop">
</span><span class="hit">    def __setattr__(self, name, value):
</span><span class="noop">        &#34;&#34;&#34;Attributes and methods should usually not be replaced.  Existing
</span><span class="noop">        :class:`Parameter` attributes are protected in a way, that only their
</span><span class="noop">        values are changed through assignements.  For new :class:`Parameter`
</span><span class="noop">        attributes, additional `fastaccess` references are defined.  If you
</span><span class="noop">        actually want to replace a parameter, you have to delete it first.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            attr = getattr(self, name)
</span><span class="hit">        except AttributeError:
</span><span class="hit">            object.__setattr__(self, name, value)
</span><span class="hit">            if isinstance(value, Parameter):
</span><span class="hit">                value.connect(self)
</span><span class="noop">        else:
</span><span class="hit">            try:
</span><span class="hit">                attr._setvalue(value)
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise RuntimeError(&#39;`%s` instances do not allow the direct&#39;
</span><span class="noop">                                   &#39;replacement of their members.  After &#39;
</span><span class="noop">                                   &#39;initialization you should usually only &#39;
</span><span class="noop">                                   &#39;change parameter values through &#39;
</span><span class="noop">                                   &#39;assignements.  If you really need to &#39;
</span><span class="noop">                                   &#39;replace a object member, delete it &#39;
</span><span class="noop">                                   &#39;beforehand.&#39; % objecttools.classname(self))
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="hit">        for Par in self._PARCLASSES:
</span><span class="hit">            name = objecttools.instancename(Par)
</span><span class="hit">            yield name, getattr(self, name)
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        lines = []
</span><span class="hit">        if pub.options.reprcomments:
</span><span class="miss">            lines.append(&#39;#%s object defined in module %s.&#39;
</span><span class="noop">                         % (objecttools.classname(self),
</span><span class="noop">                            objecttools.modulename(self)))
</span><span class="miss">            lines.append(&#39;#The implemented parameters with their actual &#39;
</span><span class="noop">                         &#39;values are:&#39;)
</span><span class="hit">        for (name, parameter) in self:
</span><span class="hit">            try:
</span><span class="hit">                lines.append(&#39;%s&#39; % repr(parameter))
</span><span class="miss">            except BaseException:
</span><span class="miss">                lines.append(&#39;%s(?)&#39; % name)
</span><span class="hit">        return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Parameter(objecttools.ValueMath):
</span><span class="noop">    &#34;&#34;&#34;Base class for :class:`SingleParameter` and :class:`MultiParameter`.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    _parameterstep = None
</span><span class="hit">    _simulationstep = None
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        self.subpars = None
</span><span class="hit">        self.fastaccess = type(&#39;JustForDemonstrationPurposes&#39;, (),
</span><span class="noop">                               {self.name: None})()
</span><span class="noop">
</span><span class="hit">    def _getname(self):
</span><span class="noop">        &#34;&#34;&#34;Name of the parameter, which is the name if the instantiating
</span><span class="noop">        subclass of :class:`Parameter` in lower case letters.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return objecttools.classname(self).lower()
</span><span class="hit">    name = property(_getname)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="noop">        &#34;&#34;&#34;The prefered way to pass values to :class:`Parameter` instances
</span><span class="noop">        within parameter control files.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if args and kwargs:
</span><span class="miss">            raise ValueError(&#39;For parameter %s of element %s both positional &#39;
</span><span class="noop">                             &#39;and keyword arguments are given, which is &#39;
</span><span class="noop">                             &#39;ambiguous.&#39;
</span><span class="noop">                             % (self.name, objecttools.devicename(self)))
</span><span class="hit">        elif not args and not kwargs:
</span><span class="miss">            raise ValueError(&#39;For parameter %s of element %s neither a &#39;
</span><span class="noop">                             &#39;positional nor a keyword argument is given.&#39;
</span><span class="noop">                             % (self.name, objecttools.devicename(self)))
</span><span class="hit">        elif &#39;pyfile&#39; in kwargs:
</span><span class="miss">            values = self._getvalues_from_auxiliaryfile(kwargs[&#39;pyfile&#39;])
</span><span class="miss">            self.values = self.applytimefactor(values)
</span><span class="miss">            del(kwargs[&#39;pyfile&#39;])
</span><span class="hit">        elif args:
</span><span class="hit">            self.values = self.applytimefactor(numpy.array(args))
</span><span class="noop">        else:
</span><span class="hit">            raise NotImplementedError(&#39;The value(s) of parameter %s of &#39;
</span><span class="noop">                                      &#39;element %s could not be set based on &#39;
</span><span class="noop">                                      &#39;the given keyword arguments.&#39;
</span><span class="noop">                                      % (self.name,
</span><span class="noop">                                         objecttools.devicename(self)))
</span><span class="hit">        self.trim()
</span><span class="noop">
</span><span class="hit">    def _getvalues_from_auxiliaryfile(self, pyfile):
</span><span class="noop">        &#34;&#34;&#34;Tries to return the parameter values from the auxiliary control file
</span><span class="noop">        with the given name.
</span><span class="noop">
</span><span class="noop">        Things are a little complicated here.  To understand this method, you
</span><span class="noop">        should first take a look at function :func:`parameterstep`.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        frame = inspect.currentframe().f_back.f_back
</span><span class="miss">        while frame:
</span><span class="miss">            namespace = frame.f_locals
</span><span class="miss">            try:
</span><span class="miss">                subnamespace = {&#39;model&#39;: namespace[&#39;model&#39;],
</span><span class="noop">                                &#39;focus&#39;: self}
</span><span class="miss">                break
</span><span class="miss">            except KeyError:
</span><span class="miss">                frame = frame.f_back
</span><span class="noop">        else:
</span><span class="miss">            raise RuntimeError(&#39;Something has gone wrong when trying to &#39;
</span><span class="noop">                               &#39;read parameter `%s` from file `%s`.&#39;
</span><span class="noop">                               % (self.name, pyfile))
</span><span class="miss">        filetools.ControlManager.read2dict(pyfile, subnamespace)
</span><span class="miss">        try:
</span><span class="miss">            subself = subnamespace[self.name]
</span><span class="miss">        except KeyError:
</span><span class="miss">            raise RuntimeError(&#39;Something has gone wrong when trying to &#39;
</span><span class="noop">                               &#39;read parameter `%s` from file `%s`.&#39;
</span><span class="noop">                               % (self.name, pyfile))
</span><span class="miss">        return subself.values
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def initvalue(self):
</span><span class="hit">        initvalue = (getattr(self, &#39;INIT&#39;, None) if
</span><span class="noop">                     pub.options.usedefaultvalues else None)
</span><span class="hit">        if initvalue is None:
</span><span class="hit">            type_ = getattr(self, &#39;TYPE&#39;, float)
</span><span class="hit">            if type_ is float:
</span><span class="hit">                initvalue = numpy.nan
</span><span class="hit">            elif type_ is int:
</span><span class="hit">                initvalue = objecttools._INT_NAN
</span><span class="hit">            elif type_ is bool:
</span><span class="hit">                initvalue = False
</span><span class="noop">            else:
</span><span class="miss">                NotImplementedError(
</span><span class="noop">                    &#39;For parameter `%s` no `INIT` class attribute is &#39;
</span><span class="noop">                    &#39;defined, but no standard value for its TYPE `%s`&#39;
</span><span class="noop">                    &#39;is available&#39; % (self.name, objecttools.classname(type_)))
</span><span class="hit">        return initvalue
</span><span class="noop">
</span><span class="hit">    def _getparameterstep(self):
</span><span class="noop">        &#34;&#34;&#34;The parameter time step size new parameter values might be related
</span><span class="noop">        to.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if Parameter._parameterstep is None:
</span><span class="miss">            raise RuntimeError(&#39;The general parameter time step has not been &#39;
</span><span class="noop">                               &#39;defined so far.&#39;)
</span><span class="noop">        else:
</span><span class="hit">            return self._parameterstep
</span><span class="noop">
</span><span class="hit">    def _setparameterstep(self, value):
</span><span class="miss">        try:
</span><span class="miss">            Parameter._parameterstep = timetools.Period(value)
</span><span class="miss">        except Exception:
</span><span class="miss">            objecttools.augmentexcmessage(&#39;While trying to set the general &#39;
</span><span class="noop">                                          &#39;parameter time step&#39;)
</span><span class="noop">
</span><span class="hit">    parameterstep = property(_getparameterstep, _setparameterstep)
</span><span class="noop">
</span><span class="hit">    def _getsimulationstep(self):
</span><span class="noop">        &#34;&#34;&#34;The simulation time step size new parameter values might be related
</span><span class="noop">        to.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            return pub.timegrids.stepsize
</span><span class="hit">        except AttributeError:
</span><span class="hit">            return Parameter._simulationstep
</span><span class="noop">
</span><span class="hit">    def _setsimulationstep(self, value):
</span><span class="hit">        try:
</span><span class="hit">            Parameter._simulationstep = timetools.Period(value)
</span><span class="miss">        except Exception:
</span><span class="miss">            objecttools.augmentexcmessage(&#39;While trying to set the general &#39;
</span><span class="noop">                                          &#39;simulation time step&#39;)
</span><span class="noop">
</span><span class="hit">    simulationstep = property(_getsimulationstep, _setsimulationstep)
</span><span class="noop">
</span><span class="hit">    def _gettimefactor(self):
</span><span class="noop">        &#34;&#34;&#34;Factor to adapt a new parameter value related to
</span><span class="noop">        :attr:`parameterstep` to a different simulation time step.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            parfactor = pub.timegrids.parfactor
</span><span class="hit">        except AttributeError:
</span><span class="hit">            if self._simulationstep is None:
</span><span class="miss">                raise RuntimeError(&#39;The calculation of the effective value &#39;
</span><span class="noop">                                   &#39;of parameter `%s` requires a definition &#39;
</span><span class="noop">                                   &#39;of the actual simulation time step.  &#39;
</span><span class="noop">                                   &#39;The simulation time step is project &#39;
</span><span class="noop">                                   &#39;specific.  When initializing the HydPy &#39;
</span><span class="noop">                                   &#39;framework, it is automatically specified &#39;
</span><span class="noop">                                   &#39;under `pub.timegrids.stepsize.  For &#39;
</span><span class="noop">                                   &#39;testing purposes, one can alternatively &#39;
</span><span class="noop">                                   &#39;apply the function `simulationstep`.  &#39;
</span><span class="noop">                                   &#39;Please see the documentation for more &#39;
</span><span class="noop">                                   &#39;details.&#39; % self.name)
</span><span class="noop">            else:
</span><span class="hit">                date1 = timetools.Date(&#39;2000.01.01&#39;)
</span><span class="hit">                date2 = date1 + self._simulationstep
</span><span class="hit">                parfactor = timetools.Timegrids(timetools.Timegrid(
</span><span class="noop">                                 date1, date2, self._simulationstep)).parfactor
</span><span class="hit">        return parfactor(self.parameterstep)
</span><span class="noop">
</span><span class="hit">    timefactor = property(_gettimefactor)
</span><span class="noop">
</span><span class="hit">    trim = objecttools.trim
</span><span class="noop">
</span><span class="hit">    def warntrim(self):
</span><span class="miss">        warnings.warn(&#39;For parameter %s of element %s at least one value &#39;
</span><span class="noop">                      &#39;needed to be trimmed.  Two possible reasons could be &#39;
</span><span class="noop">                      &#39;that the a parameter bound violated or that the values &#39;
</span><span class="noop">                      &#39;of two (or more) different parameters are inconsistent.&#39;
</span><span class="noop">                      % (self.name, objecttools.devicename(self)))
</span><span class="noop">
</span><span class="hit">    def applytimefactor(self, values):
</span><span class="noop">        &#34;&#34;&#34;Change the given parameter value/values in accordance with the
</span><span class="noop">        actual parameter simulation time step if necessary, and return it/them.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="noop">        # Note: At least `values /= self.timefactor` is less flexible than
</span><span class="noop">        # `values = values / self.timefactor` regarding the type of `values`.
</span><span class="hit">        if self.TIME is True:
</span><span class="hit">            values = values * self.timefactor
</span><span class="hit">        elif self.TIME is False:
</span><span class="hit">            values = values / self.timefactor
</span><span class="hit">        return values
</span><span class="noop">
</span><span class="hit">    def reverttimefactor(self, values):
</span><span class="noop">        &#34;&#34;&#34;Change the given parameter value/values inversely in accordance
</span><span class="noop">        with the actual parameter simulation time step if necessary, and
</span><span class="noop">        return it/them.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="noop">        # Note: At least `values /= self.timefactor` is less flexible than
</span><span class="noop">        # `values = values / self.timefactor` regarding the type of `values`.
</span><span class="hit">        if self.TIME is True:
</span><span class="hit">            values = values / self.timefactor
</span><span class="hit">        elif self.TIME is False:
</span><span class="hit">            values = values * self.timefactor
</span><span class="hit">        return values
</span><span class="noop">
</span><span class="hit">    def commentrepr(self):
</span><span class="noop">        &#34;&#34;&#34;Returns a list with comments, e.g. for making string representations
</span><span class="noop">        more informative.  When :attr:`pub.options.reprcomments` is set to
</span><span class="noop">        `False`, an empty list is returned.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        lines = []
</span><span class="hit">        if pub.options.reprcomments:
</span><span class="hit">            if self.__doc__ is not None:
</span><span class="hit">                comment = &#39;%s].&#39; % self.__doc__.split(&#39;]&#39;)[0]
</span><span class="hit">                lines.extend(&#39;# &#39;+line.strip() for line in comment.split(&#39;\n&#39;))
</span><span class="noop">            else:
</span><span class="miss">                lines.append(&#39;# Instance of parameter class `%s` defined in &#39;
</span><span class="noop">                             &#39;module `%s`.&#39;
</span><span class="noop">                             % (objecttools.classname(self), self.__module__))
</span><span class="hit">            if self.TIME is not None:
</span><span class="hit">                lines.append(&#39;# The actual value representation depends on &#39;
</span><span class="noop">                             &#39;the actual parameter step size,&#39;)
</span><span class="hit">                lines.append(&#39;# which is `%s`.&#39; % self.parameterstep)
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    def __str__(self):
</span><span class="miss">        return str(self.values)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class SingleParameter(Parameter):
</span><span class="noop">    &#34;&#34;&#34;Base class for model parameters handling a single value.&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN, INIT = 0, float, None, (None, None), None
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        Parameter.__init__(self)
</span><span class="hit">        if self.INIT is not None:
</span><span class="hit">            self(self.INIT)
</span><span class="noop">
</span><span class="hit">    def connect(self, subpars):
</span><span class="hit">        self.subpars = subpars
</span><span class="hit">        self.fastaccess = subpars.fastaccess
</span><span class="hit">        setattr(self.fastaccess, self.name, self.initvalue)
</span><span class="noop">
</span><span class="hit">    def _getshape(self):
</span><span class="noop">        &#34;&#34;&#34;An empty tuple.  (Only intended for increasing consistent usability
</span><span class="noop">        of :class:`SingleParameter` and :class:`MultiParameter` instances.)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        return ()
</span><span class="noop">
</span><span class="hit">    def _setshape(self, shape):
</span><span class="miss">        raise RuntimeError(&#39;The shape information of `SingleParameters` &#39;
</span><span class="noop">                           &#39;as `%s` cannot be changed.&#39; % self.name)
</span><span class="noop">
</span><span class="hit">    shape = property(_getshape, _setshape)
</span><span class="noop">
</span><span class="hit">    def _getvalue(self):
</span><span class="noop">        &#34;&#34;&#34;The actual parameter value handled by the respective
</span><span class="noop">        :class:`SingleParameter` instance.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return getattr(self.fastaccess, self.name, numpy.nan)
</span><span class="noop">
</span><span class="hit">    def _setvalue(self, value):
</span><span class="hit">        try:
</span><span class="hit">            temp = value[0]
</span><span class="hit">            if len(value) &gt; 1:
</span><span class="miss">                raise ValueError(&#39;%d values are assigned to the scalar &#39;
</span><span class="noop">                                 &#39;parameter `%s`, which is ambiguous.&#39;
</span><span class="noop">                                 % (len(value)), self.name)
</span><span class="hit">            value = temp
</span><span class="hit">        except (TypeError, IndexError):
</span><span class="hit">            pass
</span><span class="hit">        try:
</span><span class="hit">            value = self.TYPE(value)
</span><span class="miss">        except (ValueError, TypeError):
</span><span class="miss">            raise TypeError(&#39;When trying to set the value of parameter `%s`, &#39;
</span><span class="noop">                            &#39;it was not possible to convert `%s` to type &#39;
</span><span class="noop">                            &#39;`%s`.&#39; % (self.name, value,
</span><span class="noop">                                       objecttools.classname(self.TYPE)))
</span><span class="hit">        setattr(self.fastaccess, self.name, value)
</span><span class="noop">
</span><span class="hit">    value = property(_getvalue, _setvalue)
</span><span class="hit">    values = value
</span><span class="noop">
</span><span class="hit">    def verify(self):
</span><span class="noop">        &#34;&#34;&#34;Raises a :class:`~exceptions.RuntimeError` if the value of the
</span><span class="noop">        instance of the respective subclass of :class:`SingleParameter` is
</span><span class="noop">        `nan`.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        if numpy.isnan(self.value):
</span><span class="miss">            raise RuntimeError(&#39;The value of parameter `%s` has not been &#39;
</span><span class="noop">                               &#39;set yet.&#39; % self.name)
</span><span class="noop">
</span><span class="hit">    def __len__(self):
</span><span class="noop">        &#34;&#34;&#34;Returns 1.  (This method is only intended for increasing consistent
</span><span class="noop">        usability of :class:`SingleParameter` and :class:`MultiParameter`
</span><span class="noop">        instances.)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return 1
</span><span class="noop">
</span><span class="hit">    def __getitem__(self, key):
</span><span class="hit">        if key in (0, slice(None, None, None)):
</span><span class="hit">            return self.value
</span><span class="noop">        else:
</span><span class="hit">            raise IndexError(&#39;The only allowed index for scalar parameters &#39;
</span><span class="noop">                             &#39;like `%s` is `0` (or `:`), but `%s` is given.&#39;
</span><span class="noop">                             % (self.name, key))
</span><span class="noop">
</span><span class="hit">    def __setitem__(self, key, value):
</span><span class="miss">        if key in (0, slice(None, None, None)):
</span><span class="miss">            self.value = value
</span><span class="noop">        else:
</span><span class="miss">            raise IndexError(&#39;The only allowed index for scalar parameters &#39;
</span><span class="noop">                             &#39;like `%s` is `0` (or `:`), but `%s` is given.&#39;
</span><span class="noop">                             % (self.name, key))
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        lines = self.commentrepr()
</span><span class="hit">        lines.append(&#39;%s(%s)&#39;
</span><span class="noop">                     % (self.name,
</span><span class="noop">                        objecttools.repr_(self.reverttimefactor(self.value))))
</span><span class="hit">        return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MultiParameter(Parameter):
</span><span class="noop">    &#34;&#34;&#34;Base class for model parameters handling multiple values.&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="hit">    def connect(self, subpars):
</span><span class="hit">        self.subpars = subpars
</span><span class="hit">        self.fastaccess = subpars.fastaccess
</span><span class="hit">        setattr(self.fastaccess, self.name, None)
</span><span class="noop">
</span><span class="hit">    def _getshape(self):
</span><span class="noop">        &#34;&#34;&#34;A tuple containing the lengths in all dimensions of the parameter
</span><span class="noop">        values.  Note that setting a new shape results in a loss of all values
</span><span class="noop">        of the respective parameter.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            return getattr(self.fastaccess, self.name).shape
</span><span class="hit">        except AttributeError:
</span><span class="hit">            raise RuntimeError(&#39;Shape information for parameter `%s` &#39;
</span><span class="noop">                               &#39;can only be retrieved after it has been &#39;
</span><span class="noop">                               &#39;defined.&#39; % self.name)
</span><span class="noop">
</span><span class="hit">    def _setshape(self, shape):
</span><span class="hit">        try:
</span><span class="hit">            array = numpy.full(shape, self.initvalue, dtype=self.TYPE)
</span><span class="miss">        except Exception:
</span><span class="miss">            objecttools.augmentexcmessage(&#39;While trying create a new numpy &#39;
</span><span class="noop">                                          &#39;ndarray` for parameter `%s`&#39;
</span><span class="noop">                                          % self.name)
</span><span class="hit">        if array.ndim == self.NDIM:
</span><span class="hit">            setattr(self.fastaccess, self.name, array)
</span><span class="noop">        else:
</span><span class="miss">            raise ValueError(&#39;Parameter `%s` is %d-dimensional but the &#39;
</span><span class="noop">                             &#39;given shape indicates %d dimensions.&#39;
</span><span class="noop">                             % (self.name, self.NDIM, array.ndim))
</span><span class="noop">
</span><span class="hit">    shape = property(_getshape, _setshape)
</span><span class="noop">
</span><span class="hit">    def _getvalue(self):
</span><span class="noop">        &#34;&#34;&#34;The actual parameter value(s) handled by the respective
</span><span class="noop">        :class:`Parameter` instance.  For consistency, `value` and `values`
</span><span class="noop">        can always be used interchangeably.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        value = getattr(self.fastaccess, self.name, None)
</span><span class="hit">        if value is None:
</span><span class="miss">            return value
</span><span class="noop">        else:
</span><span class="hit">            return numpy.asarray(value)
</span><span class="noop">
</span><span class="hit">    def _setvalue(self, value):
</span><span class="hit">        try:
</span><span class="hit">            value = value.value
</span><span class="hit">        except AttributeError:
</span><span class="hit">            pass
</span><span class="hit">        try:
</span><span class="hit">            value = numpy.full(self.shape, value, dtype=self.TYPE)
</span><span class="miss">        except ValueError:
</span><span class="miss">            raise ValueError(&#39;The values `%s` cannot be converted to a numpy &#39;
</span><span class="noop">                             &#39;ndarray with shape %s containing entries of &#39;
</span><span class="noop">                             &#39;type %s.&#39; % (value, self.shape,
</span><span class="noop">                                           objecttools.classname(self.TYPE)))
</span><span class="hit">        setattr(self.fastaccess, self.name, value)
</span><span class="noop">
</span><span class="hit">    value = property(_getvalue, _setvalue)
</span><span class="hit">    values = value
</span><span class="noop">
</span><span class="hit">    def _getverifymask(self):
</span><span class="noop">        &#34;&#34;&#34;A numpy array with all entries being `True` of the same
</span><span class="noop">        shape as the values handled by the respective parameter.  All entries
</span><span class="noop">        beeing `True` indicates that the method :func:`~MultiParameter.verify`
</span><span class="noop">        checks all entries of the numpy array storing the parameter values.
</span><span class="noop">        Overwrite :func:`~MultiParameter.verify` for :class:`MultiParameter`
</span><span class="noop">        subclasses, where certain entries do not to be checked.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        return numpy.full(self.shape, True, dtype=bool)
</span><span class="noop">
</span><span class="hit">    verifymask = property(_getverifymask)
</span><span class="noop">
</span><span class="hit">    def verify(self):
</span><span class="noop">        &#34;&#34;&#34;Raises a :class:`~exceptions.RuntimeError` if at least one of the
</span><span class="noop">        required values of the instance of the respective subclass of
</span><span class="noop">        :class:`MultiParameter` is `None` or `nan`. The property
</span><span class="noop">        :func:`~MultiParameter.verifymask` defines, which values are
</span><span class="noop">        considered to be necessary.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        if self.values is None:
</span><span class="miss">            raise RuntimeError(&#39;The values of parameter `%s` have not &#39;
</span><span class="noop">                               &#39;been set yet.&#39; % self.name)
</span><span class="miss">        nmbnan = sum(numpy.isnan(self.values[self.verifymask]))
</span><span class="miss">        if nmbnan:
</span><span class="miss">            raise RuntimeError(&#39;For parameter `%s`, %d required values have &#39;
</span><span class="noop">                               &#39;not been set yet.&#39; % (self.name, nmbnan))
</span><span class="noop">
</span><span class="hit">    def copy(self):
</span><span class="noop">        &#34;&#34;&#34;Return a deep copy of the parameter values.&#34;&#34;&#34;
</span><span class="hit">        return copy.deepcopy(self.values)
</span><span class="noop">
</span><span class="hit">    def __len__(self):
</span><span class="noop">        &#34;&#34;&#34;Returns the number of values handled by the :class:`MultiParameter`
</span><span class="noop">        instance.  It is required, that the `shape` has been set beforehand,
</span><span class="noop">        which specifies the length in each dimension.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return numpy.cumprod(self.shape)[-1]
</span><span class="noop">
</span><span class="hit">    def __getitem__(self, key):
</span><span class="hit">        try:
</span><span class="hit">            return self.values[key]
</span><span class="hit">        except Exception:
</span><span class="hit">            self._raiseitemexception()
</span><span class="noop">
</span><span class="hit">    def __setitem__(self, key, values):
</span><span class="hit">        try:
</span><span class="hit">            self.values[key] = values
</span><span class="miss">        except Exception:
</span><span class="miss">            self._raiseitemexception()
</span><span class="noop">
</span><span class="hit">    def _raiseitemexception(self):
</span><span class="hit">        if self.values is None:
</span><span class="miss">            raise RuntimeError(&#39;Parameter `%s` has no values so far.&#39;
</span><span class="noop">                               % self.name)
</span><span class="noop">        else:
</span><span class="hit">            objecttools.augmentexcmessage(&#39;While trying to item access the &#39;
</span><span class="noop">                                          &#39;values of parameter `%s`&#39;
</span><span class="noop">                                          % self.name)
</span><span class="noop">
</span><span class="hit">    def compressrepr(self):
</span><span class="noop">        &#34;&#34;&#34;Returns a compressed parameter value string, which is (in
</span><span class="noop">        accordance with :attr:`~MultiParameter.NDIM`) contained in a
</span><span class="noop">        nested list.  If the compression fails, a
</span><span class="noop">        :class:`~exceptions.NotImplementedError` is raised.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if self.value is None:
</span><span class="miss">            unique = numpy.array([numpy.nan])
</span><span class="noop">        else:
</span><span class="hit">            unique = numpy.unique(self.values)
</span><span class="hit">        if sum(numpy.isnan(unique)) == len(unique.flatten()):
</span><span class="miss">            unique = numpy.array([numpy.nan])
</span><span class="noop">        else:
</span><span class="hit">            unique = self.reverttimefactor(unique)
</span><span class="hit">        if len(unique) == 1:
</span><span class="hit">            result = objecttools.repr_(unique[0])
</span><span class="hit">            for idx in range(self.NDIM):
</span><span class="hit">                result = [result]
</span><span class="hit">            return result
</span><span class="noop">        else:
</span><span class="hit">            raise NotImplementedError(&#39;For parameter `%s` there is no &#39;
</span><span class="noop">                                      &#39;compression method implemented, &#39;
</span><span class="noop">                                      &#39;working for its actual values.&#39;
</span><span class="noop">                                      % self.name)
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        lines = self.commentrepr()
</span><span class="hit">        try:
</span><span class="hit">            values = self.compressrepr()
</span><span class="hit">        except NotImplementedError:
</span><span class="hit">            values = self.reverttimefactor(self.values)
</span><span class="miss">        except BaseException:
</span><span class="miss">            objecttools.augmentexcmessage(&#39;While trying to find a compressed &#39;
</span><span class="noop">                                          &#39;string representation for &#39;
</span><span class="noop">                                          &#39;parameter `%s`&#39; % self.name)
</span><span class="hit">        if self.NDIM == 1:
</span><span class="hit">            cols = &#39;, &#39;.join(objecttools.repr_(value) for value in values)
</span><span class="hit">            wrappedlines = textwrap.wrap(cols, 80-len(self.name)-2)
</span><span class="hit">            for (idx, line) in enumerate(wrappedlines):
</span><span class="hit">                if not idx:
</span><span class="hit">                    lines.append(&#39;%s(%s&#39; % (self.name, line))
</span><span class="noop">                else:
</span><span class="miss">                    lines.append((len(self.name)+1)*&#39; &#39; + line)
</span><span class="hit">            lines[-1] += &#39;)&#39;
</span><span class="hit">            return &#39;\n&#39;.join(lines)
</span><span class="miss">        elif self.NDIM == 2:
</span><span class="miss">            skip = (1+len(self.name)) * &#39; &#39;
</span><span class="miss">            for (idx, row) in enumerate(values):
</span><span class="miss">                cols = &#39;, &#39;.join(objecttools.repr_(value) for value in row)
</span><span class="miss">                if not idx:
</span><span class="miss">                    lines.append(&#39;%s(%s,&#39; % (self.name, cols))
</span><span class="noop">                else:
</span><span class="miss">                    lines.append(&#39;%s%s,&#39; % (skip, cols))
</span><span class="miss">            lines[-1] = lines[-1][:-1] + &#39;)&#39;
</span><span class="miss">            return &#39;\n&#39;.join(lines)
</span><span class="noop">        else:
</span><span class="miss">            raise NotImplementedError(&#39;`repr` does not yet support &#39;
</span><span class="noop">                                      &#39;parameters, which handle %d-&#39;
</span><span class="noop">                                      &#39;dimensional matrices.&#39; % self.NDIM)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ZipParameter(MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Base class for model parameters handling multiple values that offers
</span><span class="noop">    additional keyword zipping fuctionality.
</span><span class="noop">
</span><span class="noop">    When inheriting an actual parameter class from :class:`ZipParameter` one
</span><span class="noop">    needs to define suitable class constants
</span><span class="noop">    :const:`~ZipParameter.REQUIRED_VALUES` (a :class:`tuple`) and
</span><span class="noop">    :const:`~ZipParameter.MODEL_CONSTANTS` (a :class:`dict`).  Additionally,
</span><span class="noop">    a property named `refparameter` must be defined.
</span><span class="noop">
</span><span class="noop">    The implementation and functioning of subclasses of :class:`ZipParameter`
</span><span class="noop">    is best illustrated by an example: see the documentation of the class
</span><span class="noop">    :class:`~hydpy.models.hland.hland_parameters.MultiParameter` of the
</span><span class="noop">    HydPy-H-Land model.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    REQUIRED_VALUES = ()
</span><span class="hit">    MODEL_CONSTANTS = {}
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="noop">        &#34;&#34;&#34;The prefered way to pass values to :class:`Parameter` instances
</span><span class="noop">        within parameter control files.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            Parameter.__call__(self, *args, **kwargs)
</span><span class="hit">        except NotImplementedError as exc:
</span><span class="hit">            if kwargs:
</span><span class="hit">                refvalues = self.refparameter.values
</span><span class="hit">                if min(refvalues) &lt; 1:
</span><span class="miss">                    raise RuntimeError(&#39;Parameter %s does not seem to &#39;
</span><span class="noop">                                       &#39;be prepared properly for element %s.  &#39;
</span><span class="noop">                                       &#39;Hence, setting values for parameter &#39;
</span><span class="noop">                                       &#39;%s via keyword arguments is not &#39;
</span><span class="noop">                                       &#39;possible.&#39;
</span><span class="noop">                                       % (self.refparameter.name,
</span><span class="noop">                                          objecttools.devicename(self),
</span><span class="noop">                                          self.name))
</span><span class="hit">                self.values = kwargs.pop(&#39;default&#39;, numpy.nan)
</span><span class="hit">                for (key, value) in kwargs.items():
</span><span class="hit">                    sel = self.MODEL_CONSTANTS.get(key.upper())
</span><span class="hit">                    if sel is None:
</span><span class="hit">                        raise exc
</span><span class="noop">                    else:
</span><span class="hit">                        self.values[refvalues == sel] = value
</span><span class="hit">                self.values = self.applytimefactor(self.values)
</span><span class="hit">                self.trim()
</span><span class="noop">            else:
</span><span class="miss">                raise exc
</span><span class="noop">
</span><span class="hit">    def _getshape(self):
</span><span class="noop">        &#34;&#34;&#34;Return a tuple containing the lengths in all dimensions of the
</span><span class="noop">        parameter values.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            return MultiParameter._getshape(self)
</span><span class="hit">        except RuntimeError:
</span><span class="hit">            raise RuntimeError(&#39;Shape information for parameter `%s` can &#39;
</span><span class="noop">                               &#39;only be retrieved after it has been defined. &#39;
</span><span class="noop">                               &#39; You can do this manually, but usually it is &#39;
</span><span class="noop">                               &#39;done automatically by defining the value of &#39;
</span><span class="noop">                               &#39;parameter `%s` first in each parameter &#39;
</span><span class="noop">                               &#39;control file.&#39;
</span><span class="noop">                               % (self.name, self.shapeparameter.name))
</span><span class="noop">
</span><span class="hit">    shape = property(_getshape, MultiParameter._setshape)
</span><span class="noop">
</span><span class="hit">    def _getverifymask(self):
</span><span class="noop">        &#34;&#34;&#34;A numpy array of the same shape as the value array handled
</span><span class="noop">        by the respective parameter.  `True` entries indicate that certain
</span><span class="noop">        parameter values are required, which depends on the tuple
</span><span class="noop">        :const:`REQUIRED_VALUES` of the respective subclass.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        mask = numpy.full(self.shape, False, dtype=bool)
</span><span class="hit">        refvalues = self.refparameter.values
</span><span class="hit">        for reqvalue in self.REQUIRED_VALUES:
</span><span class="hit">            mask[refvalues == reqvalue] = True
</span><span class="hit">        return mask
</span><span class="noop">
</span><span class="hit">    verifymask = property(_getverifymask)
</span><span class="noop">
</span><span class="hit">    def compressrepr(self):
</span><span class="noop">        &#34;&#34;&#34;Returns a compressed parameter value string, which is (in
</span><span class="noop">        accordance with :attr:`NDIM`) contained in a nested list.  If the
</span><span class="noop">        compression fails, a :class:`~exceptions.NotImplementedError` is
</span><span class="noop">        raised.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            return MultiParameter.compressrepr(self)
</span><span class="hit">        except NotImplementedError as exc:
</span><span class="hit">            results = []
</span><span class="hit">            refvalues = self.refparameter.values
</span><span class="hit">            if min(refvalues) &lt; 1:
</span><span class="hit">                raise NotImplementedError(&#39;Parameter %s is not defined &#39;
</span><span class="noop">                                          &#39;poperly, which circumvents finding &#39;
</span><span class="noop">                                          &#39;a suitable compressed.&#39;)
</span><span class="hit">            for (key, value) in self.MODEL_CONSTANTS.items():
</span><span class="hit">                if value in self.REQUIRED_VALUES:
</span><span class="hit">                    unique = numpy.unique(self.values[refvalues == value])
</span><span class="hit">                    unique = self.reverttimefactor(unique)
</span><span class="hit">                    if len(unique) == 1:
</span><span class="hit">                        results.append(&#39;%s=%s&#39;
</span><span class="noop">                                       % (key.lower(),
</span><span class="noop">                                          objecttools.repr_(unique[0])))
</span><span class="hit">                    elif len(unique) &gt; 1:
</span><span class="hit">                        raise exc
</span><span class="hit">            result = &#39;, &#39;.join(sorted(results))
</span><span class="hit">            for idx in range(self.NDIM):
</span><span class="hit">                result = [result]
</span><span class="hit">            return result
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class SeasonalParameter(MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Class for the flexible handling of parameters with anual cycles.
</span><span class="noop">
</span><span class="noop">    Let us prepare a 1-dimensional :class:`SeasonalParameter` instance:
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.parametertools import SeasonalParameter
</span><span class="noop">    &gt;&gt;&gt; seasonalparameter = SeasonalParameter()
</span><span class="noop">    &gt;&gt;&gt; seasonalparameter.NDIM = 1
</span><span class="noop">
</span><span class="noop">    For the following examples, we assume a simulation step size of one day:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.timetools import Period
</span><span class="noop">    &gt;&gt;&gt; seasonalparameter.simulationstep = Period(&#39;1d&#39;)
</span><span class="noop">
</span><span class="noop">    To define its shape, the first entry of the assigned :class:`tuple`
</span><span class="noop">    object is ignored:
</span><span class="noop">    &gt;&gt;&gt; seasonalparameter.shape = (None,)
</span><span class="noop">
</span><span class="noop">    Instead it is derived from the `simulationstep` defined above:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; seasonalparameter.shape
</span><span class="noop">    (366,)
</span><span class="noop">
</span><span class="noop">    The annual pattern of seasonal parameters is defined through pairs of
</span><span class="noop">    :class:`~hydpy.core.timetools.TOY` objects and different values (e.g.
</span><span class="noop">    of type :class:`float`).  One can define them all at once in the
</span><span class="noop">    following manner:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; seasonalparameter(_1=2., _7_1=4., _3_1_0_0_0=5.)
</span><span class="noop">
</span><span class="noop">    Note that, as :class:`str` objects, all keywords in the call above would
</span><span class="noop">    be proper :class:`~hydpy.core.timetools.TOY` initialization arguments.
</span><span class="noop">    If they are not properly written, the following exception is raised:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; SeasonalParameter()(_a=1.)
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    ValueError: While trying to define parameter `seasonalparameter` of element `?`, the following error occured: While trying to retrieve the month for TOY (time of year) object based on the string `_a`, the following error occured: For TOY (time of year) objects, all properties must be of type `int`, but the value `a` of type `str` given for property `month` cannot be converted to `int`.
</span><span class="noop">
</span><span class="noop">    As the following string representation shows, are the pairs of each
</span><span class="noop">    :class:`SeasonalParameter` instance automatically sorted:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; seasonalparameter
</span><span class="noop">    seasonalparameter(toy_1_1_0_0_0=2.0,
</span><span class="noop">                      toy_3_1_0_0_0=5.0,
</span><span class="noop">                      toy_7_1_0_0_0=4.0)
</span><span class="noop">
</span><span class="noop">    By default, `toy` is used as a prefix string.  Using this prefix string,
</span><span class="noop">    one can change the toy-value pairs via attribute access:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; seasonalparameter.toy_1_1_0_0_0
</span><span class="noop">    2.0
</span><span class="noop">    &gt;&gt;&gt; del seasonalparameter.toy_1_1_0_0_0
</span><span class="noop">    &gt;&gt;&gt; seasonalparameter.toy_2_1_0_0_0 = 2.
</span><span class="noop">    &gt;&gt;&gt; seasonalparameter
</span><span class="noop">    seasonalparameter(toy_2_1_0_0_0=2.0,
</span><span class="noop">                      toy_3_1_0_0_0=5.0,
</span><span class="noop">                      toy_7_1_0_0_0=4.0)
</span><span class="noop">
</span><span class="noop">    On applying function :func:`len` on :class:`SeasonalParameter` objects,
</span><span class="noop">    the number of toy-value pairs is returned:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; len(seasonalparameter)
</span><span class="noop">    3
</span><span class="noop">
</span><span class="noop">    New values are checked to be compatible predefined shape:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; seasonalparameter.toy_1_1_0_0_0 = [1., 2.]
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    TypeError: While trying to add a new or change an existing toy-value pair for the seasonal parameter `seasonalparameter` of element `?`, the following error occured: float() argument must be a string or a number...
</span><span class="noop">    &gt;&gt;&gt; seasonalparameter = SeasonalParameter()
</span><span class="noop">    &gt;&gt;&gt; seasonalparameter.NDIM = 2
</span><span class="noop">    &gt;&gt;&gt; seasonalparameter.shape = (None, 3)
</span><span class="noop">    &gt;&gt;&gt; seasonalparameter.toy_1_1_0_0_0 = [1., 2.]
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    ValueError: While trying to add a new or change an existing toy-value pair for the seasonal parameter `seasonalparameter` of element `?`, the following error occured: could not broadcast input array from shape (2) into shape (3)
</span><span class="noop">    &gt;&gt;&gt; seasonalparameter.toy_1_1_0_0_0 = [1., 2., 3.]
</span><span class="noop">    &gt;&gt;&gt; seasonalparameter
</span><span class="noop">    seasonalparameter(toy_1_1_0_0_0=[1.0, 2.0, 3.0])
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    def __init__(self):
</span><span class="hit">        MultiParameter.__init__(self)
</span><span class="hit">        self._toy2values = {}
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="noop">        &#34;&#34;&#34;The prefered way to pass values to :class:`Parameter` instances
</span><span class="noop">        within parameter control files.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        self._toy2values.clear()
</span><span class="hit">        try:
</span><span class="hit">            MultiParameter.__call__(self, *args, **kwargs)
</span><span class="hit">            self._toy2values[timetools.TOY()] = self[0]
</span><span class="hit">        except BaseException as exc:
</span><span class="hit">            if kwargs:
</span><span class="hit">                for (toystr, values) in kwargs.items():
</span><span class="hit">                    try:
</span><span class="hit">                        setattr(self, str(timetools.TOY(toystr)), values)
</span><span class="hit">                    except BaseException:
</span><span class="hit">                        objecttools.augmentexcmessage(
</span><span class="noop">                            &#39;While trying to define parameter `%s` of element &#39;
</span><span class="noop">                            &#39;`%s`&#39; % (self.name, objecttools.devicename(self)))
</span><span class="hit">                self.refresh()
</span><span class="noop">            else:
</span><span class="miss">                raise exc
</span><span class="noop">
</span><span class="hit">    def refresh(self):
</span><span class="noop">        &#34;&#34;&#34;Update the actual simulation values based on the toy-value pairs.
</span><span class="noop">
</span><span class="noop">        Usually, one does not need to call refresh explicitly, as it is
</span><span class="noop">        called by methods __call__, __setattr__ and __delattr__ automatically,
</span><span class="noop">        when required.
</span><span class="noop">
</span><span class="noop">        Instantiate a 1-dimensional :class:`SeasonalParameter` object:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; sp = SeasonalParameter()
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.timetools import Period
</span><span class="noop">        &gt;&gt;&gt; sp.simulationstep = Period(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; sp.NDIM = 1
</span><span class="noop">        &gt;&gt;&gt; sp.shape = (None,)
</span><span class="noop">
</span><span class="noop">        When a :class:`SeasonalParameter` object does not contain any
</span><span class="noop">        toy-value pairs yet, the method :func:`SeasonalParameter.refresh`
</span><span class="noop">        sets all actual simulation values to zero:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; sp.values = 1.
</span><span class="noop">        &gt;&gt;&gt; sp.refresh()
</span><span class="noop">        &gt;&gt;&gt; sp.values[0]
</span><span class="noop">        0.0
</span><span class="noop">
</span><span class="noop">        When there is only one toy-value pair, its values are taken for
</span><span class="noop">        all actual simulation values:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; sp.toy_1 = 2. # calls refresh automatically
</span><span class="noop">        &gt;&gt;&gt; sp.values[0]
</span><span class="noop">        2.0
</span><span class="noop">
</span><span class="noop">        Method :func:`SeasonalParameter.refresh` performs a linear
</span><span class="noop">        interpolation for the central time points of each simulation time
</span><span class="noop">        step.  Hence, in the following example the original values of the
</span><span class="noop">        toy-value pairs do not show up:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; sp.toy_12_31 = 4.
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.objecttools import round_
</span><span class="noop">        &gt;&gt;&gt; round_(sp.values[0])
</span><span class="noop">        2.00274
</span><span class="noop">        &gt;&gt;&gt; round_(sp.values[-2])
</span><span class="noop">        3.99726
</span><span class="noop">        &gt;&gt;&gt; sp.values[-1]
</span><span class="noop">        3.0
</span><span class="noop">
</span><span class="noop">        If one wants to preserve the original values in this example, one
</span><span class="noop">        would have to set the corresponding toy instances in the middle of
</span><span class="noop">        some simulation step intervalls:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; del sp.toy_1
</span><span class="noop">        &gt;&gt;&gt; del sp.toy_12_31
</span><span class="noop">        &gt;&gt;&gt; sp.toy_1_1_12 = 2
</span><span class="noop">        &gt;&gt;&gt; sp.toy_12_31_12 = 4.
</span><span class="noop">        &gt;&gt;&gt; sp.values[0]
</span><span class="noop">        2.0
</span><span class="noop">        &gt;&gt;&gt; round_(sp.values[1])
</span><span class="noop">        2.005479
</span><span class="noop">        &gt;&gt;&gt; round_(sp.values[-2])
</span><span class="noop">        3.994521
</span><span class="noop">        &gt;&gt;&gt; sp.values[-1]
</span><span class="noop">        4.0
</span><span class="noop">
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if len(self) == 0:
</span><span class="hit">            self.values[:] = 0.
</span><span class="hit">        elif len(self) == 1:
</span><span class="hit">            values = list(self._toy2values.values())[0]
</span><span class="hit">            self.values[:] = self.applytimefactor(values)
</span><span class="noop">        else:
</span><span class="hit">            tt = timetools
</span><span class="hit">            timegrid = tt.Timegrid(tt.TOY._STARTDATE+self.simulationstep/2,
</span><span class="noop">                                   tt.TOY._ENDDATE+self.simulationstep/2,
</span><span class="noop">                                   self.simulationstep)
</span><span class="hit">            for idx, date in enumerate(timegrid):
</span><span class="hit">                values = self.interp(date)
</span><span class="hit">                self.values[idx] = self.applytimefactor(values)
</span><span class="noop">
</span><span class="hit">    def interp(self, date):
</span><span class="noop">        &#34;&#34;&#34;Perform a linear value interpolation for a date defined by the
</span><span class="noop">        passed :class:`~hydpy.core.timetools.Date` object and return the
</span><span class="noop">        result.
</span><span class="noop">
</span><span class="noop">        Instantiate a 1-dimensional :class:`SeasonalParameter` object:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; sp = SeasonalParameter()
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.timetools import Date, Period
</span><span class="noop">        &gt;&gt;&gt; sp.simulationstep = Period(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; sp.NDIM = 1
</span><span class="noop">        &gt;&gt;&gt; sp.shape = (None,)
</span><span class="noop">
</span><span class="noop">        Define three toy-value pairs:
</span><span class="noop">        &gt;&gt;&gt; sp(_1=2.0, _2=5.0, _12_31=4.0)
</span><span class="noop">
</span><span class="noop">        Passing a :class:`~hydpy.core.timetools.Date` object excatly matching
</span><span class="noop">        a :class:`~hydpy.core.timetools.TOY` object of course simply returns
</span><span class="noop">        the associated value:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; sp.interp(Date(&#39;2000.01.01&#39;))
</span><span class="noop">        2.0
</span><span class="noop">        &gt;&gt;&gt; sp.interp(Date(&#39;2000.02.01&#39;))
</span><span class="noop">        5.0
</span><span class="noop">        &gt;&gt;&gt; sp.interp(Date(&#39;2000.12.31&#39;))
</span><span class="noop">        4.0
</span><span class="noop">
</span><span class="noop">        For all intermediate points, a linear interpolation is performed:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.objecttools import round_
</span><span class="noop">        &gt;&gt;&gt; round_(sp.interp(Date(&#39;2000.01.02&#39;)))
</span><span class="noop">        2.096774
</span><span class="noop">        &gt;&gt;&gt; round_(sp.interp(Date(&#39;2000.01.31&#39;)))
</span><span class="noop">        4.903226
</span><span class="noop">        &gt;&gt;&gt; round_(sp.interp(Date(&#39;2000.02.02&#39;)))
</span><span class="noop">        4.997006
</span><span class="noop">        &gt;&gt;&gt; round_(sp.interp(Date(&#39;2000.12.30&#39;)))
</span><span class="noop">        4.002994
</span><span class="noop">
</span><span class="noop">        Linear interpolation is also allowed between the first and the
</span><span class="noop">        last pair, when they do not capture the end points of the year:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; sp(_1_2=2.0, _12_30=4.0)
</span><span class="noop">        &gt;&gt;&gt; round_(sp.interp(Date(&#39;2000.12.29&#39;)))
</span><span class="noop">        3.99449
</span><span class="noop">        &gt;&gt;&gt; sp.interp(Date(&#39;2000.12.30&#39;))
</span><span class="noop">        4.0
</span><span class="noop">        &gt;&gt;&gt; round_(sp.interp(Date(&#39;2000.12.31&#39;)))
</span><span class="noop">        3.333333
</span><span class="noop">        &gt;&gt;&gt; round_(sp.interp(Date(&#39;2000.01.01&#39;)))
</span><span class="noop">        2.666667
</span><span class="noop">        &gt;&gt;&gt; sp.interp(Date(&#39;2000.01.02&#39;))
</span><span class="noop">        2.0
</span><span class="noop">        &gt;&gt;&gt; round_(sp.interp(Date(&#39;2000.01.03&#39;)))
</span><span class="noop">        2.00551
</span><span class="noop">
</span><span class="noop">        The following example briefly shows interpolation performed for
</span><span class="noop">        2-dimensional parameter:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; sp = SeasonalParameter()
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.timetools import Date, Period
</span><span class="noop">        &gt;&gt;&gt; sp.simulationstep = Period(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; sp.NDIM = 2
</span><span class="noop">        &gt;&gt;&gt; sp.shape = (None, 2)
</span><span class="noop">        &gt;&gt;&gt; sp(_1_1=[1., 2.], _1_3=[-3, 0.])
</span><span class="noop">        &gt;&gt;&gt; result = sp.interp(Date(&#39;2000.01.02&#39;))
</span><span class="noop">        &gt;&gt;&gt; round_(result[0])
</span><span class="noop">        -1.0
</span><span class="noop">        &gt;&gt;&gt; round_(result[1])
</span><span class="noop">        1.0
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">        xnew = timetools.TOY(date)
</span><span class="hit">        xys = list(self)
</span><span class="hit">        for idx, (x1, y1) in enumerate(xys):
</span><span class="hit">            if x1 &gt; xnew:
</span><span class="hit">                x0, y0 = xys[idx-1]
</span><span class="hit">                break
</span><span class="noop">        else:
</span><span class="hit">            x0, y0 = xys[-1]
</span><span class="hit">            x1, y1 = xys[0]
</span><span class="hit">        return y0+(y1-y0)/(x1-x0)*(xnew-x0)
</span><span class="noop">
</span><span class="hit">    def _setshape(self, shape):
</span><span class="hit">        try:
</span><span class="hit">            shape = (int(shape),)
</span><span class="hit">        except TypeError:
</span><span class="hit">            pass
</span><span class="hit">        shape = list(shape)
</span><span class="hit">        if self.simulationstep is None:
</span><span class="miss">            raise RuntimeError(
</span><span class="noop">                &#39;It is not possible the set the shape of the seasonal &#39;
</span><span class="noop">                &#39;parameter `%s` of element `%s` at the moment.  You can &#39;
</span><span class="noop">                &#39;define it manually.  In complete HydPy projects it is &#39;
</span><span class="noop">                &#39;indirecty defined via `pub.timegrids.stepsize` automatically.&#39;
</span><span class="noop">                % (self.name, objecttools.devicename(self)))
</span><span class="hit">        shape[0] = timetools.Period(&#39;366d&#39;)/self.simulationstep
</span><span class="hit">        shape[0] = int(numpy.ceil(round(shape[0], 10)))
</span><span class="hit">        MultiParameter._setshape(self, shape)
</span><span class="hit">    shape = property(MultiParameter._getshape, _setshape)
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="hit">        for toy in sorted(self._toy2values.keys()):
</span><span class="hit">            yield (toy, self._toy2values[toy])
</span><span class="noop">
</span><span class="hit">    def __getattr__(self, name):
</span><span class="hit">        if name.startswith(&#39;toy_&#39;):
</span><span class="hit">            try:
</span><span class="hit">                return self._toy2values[timetools.TOY(name)]
</span><span class="miss">            except BaseException:
</span><span class="miss">                objecttools.augmentexcmessage(
</span><span class="noop">                    &#39;While trying to get an existing toy-value pair for &#39;
</span><span class="noop">                    &#39;the seasonal parameter `%s` of element `%s`&#39;
</span><span class="noop">                    % (self.name, objecttools.devicename(self)))
</span><span class="noop">        else:
</span><span class="hit">            return MultiParameter.__getattr__(self, name)
</span><span class="noop">
</span><span class="hit">    def __setattr__(self, name, value):
</span><span class="hit">        if name.startswith(&#39;toy_&#39;):
</span><span class="hit">            try:
</span><span class="hit">                if self.NDIM == 1:
</span><span class="hit">                    value = float(value)
</span><span class="noop">                else:
</span><span class="hit">                    value = numpy.full(self.shape[1:], value)
</span><span class="hit">                self._toy2values[timetools.TOY(name)] = value
</span><span class="hit">                self.refresh()
</span><span class="hit">            except BaseException:
</span><span class="hit">                objecttools.augmentexcmessage(
</span><span class="noop">                    &#39;While trying to add a new or change an existing &#39;
</span><span class="noop">                    &#39;toy-value pair for the seasonal parameter `%s` of &#39;
</span><span class="noop">                    &#39;element `%s`&#39; % (self.name, objecttools.devicename(self)))
</span><span class="noop">        else:
</span><span class="hit">            MultiParameter.__setattr__(self, name, value)
</span><span class="noop">
</span><span class="hit">    def __delattr__(self, name):
</span><span class="hit">        if name.startswith(&#39;toy_&#39;):
</span><span class="hit">            try:
</span><span class="hit">                del self._toy2values[timetools.TOY(name)]
</span><span class="hit">                self.refresh()
</span><span class="miss">            except BaseException:
</span><span class="miss">                objecttools.augmentexcmessage(
</span><span class="noop">                    &#39;While trying to delete an existing toy-value pair for &#39;
</span><span class="noop">                    &#39;the seasonal parameter `%s` of element `%s`&#39;
</span><span class="noop">                    % (self.name, objecttools.devicename(self)))
</span><span class="noop">        else:
</span><span class="miss">            MultiParameter.__delattr__(self, name)
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        if (len(self) == 1) and (self.NDIM == 1):
</span><span class="miss">            return &#39;%s(%s)&#39; % (self.name, list(self._toy2values.values())[0])
</span><span class="hit">        elif len(self) &gt; 0:
</span><span class="hit">            lines = []
</span><span class="hit">            blanks = &#39; &#39;*(len(self.name))
</span><span class="hit">            for idx, (toy, value) in enumerate(self):
</span><span class="hit">                if self.NDIM == 2:
</span><span class="hit">                    value = list(value)
</span><span class="hit">                kwarg = &#39;%s=%s&#39; % (str(toy), repr(value))
</span><span class="hit">                if idx == 0:
</span><span class="hit">                    lines.append(&#39;%s(%s&#39; % (self.name, kwarg))
</span><span class="noop">                else:
</span><span class="hit">                    lines.append(&#39;%s %s&#39; % (blanks, kwarg))
</span><span class="hit">            lines[-1] += &#39;)&#39;
</span><span class="hit">            return &#39;,\n&#39;.join(lines)
</span><span class="noop">        else:
</span><span class="miss">            return self.name+&#39;()&#39;
</span><span class="noop">
</span><span class="hit">    def __len__(self):
</span><span class="hit">        return len(self._toy2values)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self) + [str(toy) for (toy, value) in self]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class KeywordParameter2DType(type):
</span><span class="noop">    &#34;&#34;&#34;Add the construction of `_ROWCOLMAPPING` to :class:`type`.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __new__(cls, name, parents, dict_):
</span><span class="hit">        rownames = dict_.get(&#39;ROWNAMES&#39;, getattr(parents[0], &#39;ROWNAMES&#39;, ()))
</span><span class="hit">        colnames = dict_.get(&#39;COLNAMES&#39;, getattr(parents[0], &#39;COLNAMES&#39;, ()))
</span><span class="hit">        rowcolmappings = {}
</span><span class="hit">        for (idx, rowname) in enumerate(rownames):
</span><span class="hit">            for (jdx, colname) in enumerate(colnames):
</span><span class="hit">                rowcolmappings[&#39;_&#39;.join((rowname, colname))] = (idx, jdx)
</span><span class="hit">        dict_[&#39;_ROWCOLMAPPINGS&#39;] = rowcolmappings
</span><span class="hit">        return type.__new__(cls, name, parents, dict_)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">KeywordParameter2DMetaclass = KeywordParameter2DType(
</span><span class="noop">                          &#39;KeywordParameter2DMetaclass&#39;, (MultiParameter,), {})
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class KeywordParameter2D(KeywordParameter2DMetaclass):
</span><span class="noop">    &#34;&#34;&#34;Base class for 2-dimensional model parameters which values which depend
</span><span class="noop">    on two factors.
</span><span class="noop">
</span><span class="noop">    When inheriting an actual parameter class from :class:`KeywordParameter2D`
</span><span class="noop">    one needs to define the class attributes
</span><span class="noop">    :const:`~KeywordParameter2D.ROWNAMES` and
</span><span class="noop">    :const:`~KeywordParameter2D.COLNAMES` (both of type :class:`tuple`).
</span><span class="noop">    One usual setting would be that :const:`~KeywordParameter2D.ROWNAMES`
</span><span class="noop">    defines some land use classes and :const:`~KeywordParameter2D.COLNAMES`
</span><span class="noop">    defines seasons, months, or the like.
</span><span class="noop">
</span><span class="noop">    Consider the following example, where the boolean parameter `IsWarm` both
</span><span class="noop">    depends on the half-year period and the hemisphere:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.parametertools import KeywordParameter2D
</span><span class="noop">    &gt;&gt;&gt; class IsWarm(KeywordParameter2D):
</span><span class="noop">    ...     TYPE = bool
</span><span class="noop">    ...     ROWNAMES = (&#39;north&#39;, &#39;south&#39;)
</span><span class="noop">    ...     COLNAMES = (&#39;apr2sep&#39;, &#39;oct2mar&#39;)
</span><span class="noop">
</span><span class="noop">    Instantiate the defined parameter class and define its shape:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; iswarm = IsWarm()
</span><span class="noop">    &gt;&gt;&gt; iswarm.shape = (2, 2)
</span><span class="noop">
</span><span class="noop">    :class:`KeywordParameter2D` allows to set the values of all rows via
</span><span class="noop">    keyword arguments:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; iswarm(north=[True, False],
</span><span class="noop">    ...        south=[False, True])
</span><span class="noop">    &gt;&gt;&gt; iswarm
</span><span class="noop">    iswarm(north=[True, False],
</span><span class="noop">           south=[False, True])
</span><span class="noop">    &gt;&gt;&gt; iswarm.values
</span><span class="noop">    array([[ True, False],
</span><span class="noop">           [False,  True]], dtype=bool)
</span><span class="noop">
</span><span class="noop">    If a keyword is missing, a :class:`~exceptions.TypeError` is raised:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; iswarm(north=[True, False])
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    ValueError: When setting parameter `iswarm` of element `?` via row related keyword arguments, each string defined in `ROWNAMES` must be used as a keyword, but the following keyword is not: `south`.
</span><span class="noop">
</span><span class="noop">    But one can modify single rows via attribute access:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; iswarm.north = False, False
</span><span class="noop">    &gt;&gt;&gt; iswarm.north
</span><span class="noop">    array([False, False], dtype=bool)
</span><span class="noop">
</span><span class="noop">    The same holds true for the columns:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; iswarm.apr2sep = True, False
</span><span class="noop">    &gt;&gt;&gt; iswarm.apr2sep
</span><span class="noop">    array([ True, False], dtype=bool)
</span><span class="noop">
</span><span class="noop">    Even a combined row-column access is supported in the following manner:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; iswarm.north_apr2sep
</span><span class="noop">    True
</span><span class="noop">    &gt;&gt;&gt; iswarm.north_apr2sep = False
</span><span class="noop">    &gt;&gt;&gt; iswarm.north_apr2sep
</span><span class="noop">    False
</span><span class="noop">
</span><span class="noop">    All three forms of attribute access define augmented exception messages
</span><span class="noop">    in case anything goes wrong:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; iswarm.north = True, True, True
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    ValueError: While trying to assign new values to parameter `iswarm` of element `?` via the row related attribute `north`, the following error occured: cannot copy sequence with size 3 to array axis with dimension 2
</span><span class="noop">    &gt;&gt;&gt; iswarm.apr2sep = True, True, True
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    ValueError: While trying to assign new values to parameter `iswarm` of element `?` via the column related attribute `apr2sep`, the following error occured: cannot copy sequence with size 3 to array axis with dimension 2
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; iswarm.shape = (1, 1)
</span><span class="noop">    &gt;&gt;&gt; iswarm.south_apr2sep = False
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    IndexError: While trying to assign new values to parameter `iswarm` of element `?` via the row and column related attribute `south_apr2sep`, the following error occured: index 1 is out of bounds for axis 0 with size 1
</span><span class="noop">    &gt;&gt;&gt; iswarm.shape = (2, 2)
</span><span class="noop">
</span><span class="noop">    Of course, one can define the parameter values in the common manner, e.g.:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; iswarm(True)
</span><span class="noop">    &gt;&gt;&gt; iswarm
</span><span class="noop">    iswarm(north=[True, True],
</span><span class="noop">           south=[True, True])
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM = 2
</span><span class="hit">    ROWNAMES = ()
</span><span class="hit">    COLNAMES = ()
</span><span class="noop">
</span><span class="hit">    def connect(self, subpars):
</span><span class="hit">        MultiParameter.connect(self, subpars)
</span><span class="hit">        self.shape = (len(self.ROWNAMES), len(self.COLNAMES))
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="hit">        try:
</span><span class="hit">            MultiParameter.__call__(self, *args, **kwargs)
</span><span class="hit">        except NotImplementedError:
</span><span class="hit">            for (idx, key) in enumerate(self.ROWNAMES):
</span><span class="hit">                try:
</span><span class="hit">                    values = kwargs[key]
</span><span class="hit">                except KeyError:
</span><span class="hit">                    miss = [key for key in self.ROWNAMES if key not in kwargs]
</span><span class="hit">                    raise ValueError(
</span><span class="noop">                        &#39;When setting parameter `%s` of element `%s` via &#39;
</span><span class="noop">                        &#39;row related keyword arguments, each string &#39;
</span><span class="noop">                        &#39;defined in `ROWNAMES` must be used as a keyword, &#39;
</span><span class="noop">                        &#39;but the following keyword%s not: `%s`.&#39;
</span><span class="noop">                        % (self.name, objecttools.devicename(self),
</span><span class="noop">                           &#39; is&#39; if len(miss) == 1 else &#39;s are&#39;,
</span><span class="noop">                           &#39;, &#39;.join(miss)))
</span><span class="hit">                self.values[idx, :] = values
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        lines = self.commentrepr()
</span><span class="hit">        blanks = (len(self.name)+1) * &#39; &#39;
</span><span class="hit">        for (idx, key) in enumerate(self.ROWNAMES):
</span><span class="hit">            valuerepr = &#39;, &#39;.join(objecttools.repr_(value)
</span><span class="noop">                                  for value in self.values[idx, :])
</span><span class="hit">            line = (&#39;%s=[%s],&#39; % (key, valuerepr))
</span><span class="hit">            if idx == 0:
</span><span class="hit">                lines.append(&#39;%s(%s&#39; % (self.name, line))
</span><span class="noop">            else:
</span><span class="hit">                lines.append(&#39;%s%s&#39; % (blanks, line))
</span><span class="hit">        lines[-1] = lines[-1][:-1]+&#39;)&#39;
</span><span class="hit">        return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="hit">    def __getattr__(self, key):
</span><span class="hit">        if key in self.ROWNAMES:
</span><span class="hit">            try:
</span><span class="hit">                return self.values[self.ROWNAMES.index(key), :]
</span><span class="miss">            except BaseException:
</span><span class="miss">                objecttools.augmentexcmessage(
</span><span class="noop">                    &#39;While trying to retrieve values from parameter `%s` of &#39;
</span><span class="noop">                    &#39;element `%s` via the row related attribute `%s`&#39;
</span><span class="noop">                    % (self.name, objecttools.devicename(self), key))
</span><span class="hit">        elif key in self.COLNAMES:
</span><span class="hit">            try:
</span><span class="hit">                return self.values[:, self.COLNAMES.index(key)]
</span><span class="miss">            except BaseException:
</span><span class="miss">                objecttools.augmentexcmessage(
</span><span class="noop">                    &#39;While trying to retrieve values from parameter `%s` of &#39;
</span><span class="noop">                    &#39;element `%s` via the columnd related attribute `%s`&#39;
</span><span class="noop">                    % (self.name, objecttools.devicename(self), key))
</span><span class="hit">        elif key in self._ROWCOLMAPPINGS:
</span><span class="hit">            idx, jdx = self._ROWCOLMAPPINGS[key]
</span><span class="hit">            try:
</span><span class="hit">                return self.values[idx, jdx]
</span><span class="miss">            except BaseException:
</span><span class="miss">                objecttools.augmentexcmessage(
</span><span class="noop">                    &#39;While trying to retrieve values from parameter `%s` of &#39;
</span><span class="noop">                    &#39;element `%s` via the row and column related attribute &#39;
</span><span class="noop">                    &#39;`%s`&#39; % (self.name, objecttools.devicename(self), key))
</span><span class="noop">        else:
</span><span class="hit">            return MultiParameter.__getattr__(self, key)
</span><span class="noop">
</span><span class="hit">    def __setattr__(self, key, values):
</span><span class="hit">        if key in self.ROWNAMES:
</span><span class="hit">            try:
</span><span class="hit">                self.values[self.ROWNAMES.index(key), :] = values
</span><span class="hit">            except BaseException:
</span><span class="hit">                objecttools.augmentexcmessage(
</span><span class="noop">                    &#39;While trying to assign new values to parameter `%s` of &#39;
</span><span class="noop">                    &#39;element `%s` via the row related attribute `%s`&#39;
</span><span class="noop">                    % (self.name, objecttools.devicename(self), key))
</span><span class="hit">        elif key in self.COLNAMES:
</span><span class="hit">            try:
</span><span class="hit">                self.values[:, self.COLNAMES.index(key)] = values
</span><span class="hit">            except BaseException:
</span><span class="hit">                objecttools.augmentexcmessage(
</span><span class="noop">                    &#39;While trying to assign new values to parameter `%s` of &#39;
</span><span class="noop">                    &#39;element `%s` via the column related attribute `%s`&#39;
</span><span class="noop">                    % (self.name, objecttools.devicename(self), key))
</span><span class="hit">        elif key in self._ROWCOLMAPPINGS:
</span><span class="hit">            idx, jdx = self._ROWCOLMAPPINGS[key]
</span><span class="hit">            try:
</span><span class="hit">                self.values[idx, jdx] = values
</span><span class="hit">            except BaseException:
</span><span class="hit">                objecttools.augmentexcmessage(
</span><span class="noop">                    &#39;While trying to assign new values to parameter `%s` of &#39;
</span><span class="noop">                    &#39;element `%s` via the row and column related attribute &#39;
</span><span class="noop">                    &#39;`%s`&#39; % (self.name, objecttools.devicename(self), key))
</span><span class="noop">        else:
</span><span class="hit">            MultiParameter.__setattr__(self, key, values)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return (objecttools.dir_(self) + list(self.ROWNAMES) +
</span><span class="noop">                list(self.COLNAMES) + list(self._ROWCOLMAPPINGS.keys()))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class LeftRightParameter(MultiParameter):
</span><span class="hit">    NDIM = 1
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="hit">        try:
</span><span class="hit">            MultiParameter.__call__(self, *args, **kwargs)
</span><span class="hit">        except NotImplementedError:
</span><span class="hit">            left = kwargs.get(&#39;left&#39;, kwargs.get(&#39;l&#39;))
</span><span class="hit">            if left is None:
</span><span class="miss">                raise ValueError(&#39;When setting the values of parameter `%s`&#39;
</span><span class="noop">                                 &#39;of element `%s` via keyword arguments, &#39;
</span><span class="noop">                                 &#39;either `left` or `l` for the &#34;left&#34; &#39;
</span><span class="noop">                                 &#39;parameter value must be given, but is not.&#39;
</span><span class="noop">                                 % (self.name, objecttools.devicename(self)))
</span><span class="noop">            else:
</span><span class="hit">                self.left = left
</span><span class="hit">            right = kwargs.get(&#39;right&#39;, kwargs.get(&#39;r&#39;))
</span><span class="hit">            if right is None:
</span><span class="miss">                raise ValueError(&#39;When setting the values of parameter `%s`&#39;
</span><span class="noop">                                 &#39;of element `%s` via keyword arguments, &#39;
</span><span class="noop">                                 &#39;either `right` or `r` for the &#34;right&#34; &#39;
</span><span class="noop">                                 &#39;parameter value must be given, but is not.&#39;
</span><span class="noop">                                 % (self.name, objecttools.devicename(self)))
</span><span class="noop">            else:
</span><span class="hit">                self.right = right
</span><span class="noop">
</span><span class="hit">    def connect(self, subpars):
</span><span class="hit">        MultiParameter.connect(self, subpars)
</span><span class="hit">        self.shape = 2
</span><span class="noop">
</span><span class="hit">    def _getleft(self):
</span><span class="noop">        &#34;&#34;&#34;The &#34;left&#34; value of the actual parameter.&#34;&#34;&#34;
</span><span class="hit">        return self.values[0]
</span><span class="noop">
</span><span class="hit">    def _setleft(self, value):
</span><span class="hit">        self.values[0] = value
</span><span class="noop">
</span><span class="hit">    left = property(_getleft, _setleft)
</span><span class="hit">    l = left
</span><span class="noop">
</span><span class="hit">    def _getright(self):
</span><span class="noop">        &#34;&#34;&#34;The &#34;right&#34; value of the actual parameter.&#34;&#34;&#34;
</span><span class="hit">        return self.values[1]
</span><span class="noop">
</span><span class="hit">    def _setright(self, value):
</span><span class="hit">        self.values[1] = value
</span><span class="noop">
</span><span class="hit">    right = property(_getright, _setright)
</span><span class="hit">    r = right
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class IndexParameter(MultiParameter):
</span><span class="noop">
</span><span class="hit">    def setreference(self, indexarray):
</span><span class="hit">        setattr(self.fastaccess, self.name, indexarray)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/selectiontools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/selectiontools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core import devicetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Selections(object):
</span><span class="noop">    &#34;&#34;&#34;Collects :class:`Selection` instances.
</span><span class="noop">
</span><span class="noop">    Attributes:
</span><span class="noop">        * ? (:class:`Selection`): An arbitrary number of :class:`Selection`
</span><span class="noop">          objects, which can be added (and removed) on demand.  Choose
</span><span class="noop">          attribute names that are meaningfull within your specific project.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self, *selections):
</span><span class="miss">        for selection in selections:
</span><span class="miss">            self += selection
</span><span class="noop">
</span><span class="hit">    def _getnames(self):
</span><span class="noop">        &#34;&#34;&#34;Names of the actual selections.&#34;&#34;&#34;
</span><span class="miss">        return vars(self).keys()
</span><span class="noop">
</span><span class="hit">    names = property(_getnames)
</span><span class="noop">
</span><span class="hit">    def _getselections(self):
</span><span class="noop">        &#34;&#34;&#34;The actual selections themselves.&#34;&#34;&#34;
</span><span class="miss">        return vars(self).values()
</span><span class="noop">
</span><span class="hit">    selections = property(_getselections)
</span><span class="noop">
</span><span class="hit">    def __setitem__(self, key, value):
</span><span class="miss">        self.__dict__[key] = value
</span><span class="noop">
</span><span class="hit">    def __getitem__(self, key):
</span><span class="miss">        return self.__dict__[key]
</span><span class="noop">
</span><span class="hit">    def __delitem__(self, key):
</span><span class="miss">        del(self.__dict__[key])
</span><span class="noop">
</span><span class="hit">    def __contains__(self, value):
</span><span class="miss">        if isinstance(value, Selection):
</span><span class="miss">            return value in self.selections
</span><span class="noop">        else:
</span><span class="miss">            return value in self.names
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="miss">        for (name, selection) in vars(self).items():
</span><span class="miss">            yield (name, selection)
</span><span class="noop">
</span><span class="hit">    def __len__(self):
</span><span class="miss">        return len(self.names)
</span><span class="noop">
</span><span class="hit">    @staticmethod
</span><span class="noop">    def _getiterable(value):
</span><span class="noop">        &#34;&#34;&#34;Tries to convert the given argument to a :class:`list` of
</span><span class="noop">        :class:`Selection` objects and returns it.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * value (:class:`Selection`, :class:`Selections` of a simple
</span><span class="noop">            iterable containing :class:`Selection` objects): The second
</span><span class="noop">            operand applied in an arithmetic operation.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        if isinstance(value, Selection):
</span><span class="miss">            return [value]
</span><span class="miss">        elif isinstance(value, Selections):
</span><span class="miss">            return value.selections
</span><span class="noop">        else:
</span><span class="miss">            try:
</span><span class="miss">                for selection in value:
</span><span class="miss">                    selection.name
</span><span class="miss">                    break
</span><span class="miss">                return list(value)
</span><span class="miss">            except (KeyError, AttributeError):
</span><span class="miss">                raise TypeError(&#39;Arithmetic operations on `Selections` &#39;
</span><span class="noop">                                &#39;objects are defined for other `Selections` &#39;
</span><span class="noop">                                &#39;objects, single `Selection` objects or &#39;
</span><span class="noop">                                &#39;simple iterables (like `list` objects) &#39;
</span><span class="noop">                                &#39;containing `Selection` objects only.  The &#39;
</span><span class="noop">                                &#39;given arguments type is `%s`.&#39;
</span><span class="noop">                                % type(value))
</span><span class="noop">
</span><span class="hit">    def __add__(self, value):
</span><span class="miss">        selections = self._getiterable(value)
</span><span class="miss">        new = self.copy()
</span><span class="miss">        for selection in selections:
</span><span class="miss">            new[selection.name] = selection
</span><span class="miss">        return new
</span><span class="noop">
</span><span class="hit">    def __iadd__(self, value):
</span><span class="miss">        selections = self._getiterable(value)
</span><span class="miss">        for selection in selections:
</span><span class="miss">            self[selection.name] = selection
</span><span class="miss">        return self
</span><span class="noop">
</span><span class="hit">    def __sub__(self, value):
</span><span class="miss">        selections = self._getiterable(value)
</span><span class="miss">        new = self.copy()
</span><span class="miss">        for selection in selections:
</span><span class="miss">            try:
</span><span class="miss">                del(new[selection.name])
</span><span class="miss">            except KeyError:
</span><span class="miss">                pass
</span><span class="miss">        return new
</span><span class="noop">
</span><span class="hit">    def __isub__(self, value):
</span><span class="miss">        selections = self._getiterable(value)
</span><span class="miss">        for selection in selections:
</span><span class="miss">            try:
</span><span class="miss">                del(self[selection.name])
</span><span class="miss">            except KeyError:
</span><span class="miss">                pass
</span><span class="miss">        return self
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="miss">        return self.assignrepr(&#39;&#39;)
</span><span class="noop">
</span><span class="hit">    def assignrepr(self, prefix):
</span><span class="noop">        &#34;&#34;&#34;Return a :func:`repr` string with an prefixed assignement.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * prefix(:class:`str`): Usually something like &#39;x = &#39;.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        prefix += &#39;Selections(&#39;
</span><span class="miss">        blanks = &#39; &#39; * len(prefix)
</span><span class="miss">        selections = sorted(self.selections)
</span><span class="miss">        if selections:
</span><span class="miss">            lines = [&#39;%s,&#39; % selections[0].assignrepr(prefix)]
</span><span class="miss">            for selection in selections:
</span><span class="miss">                lines.append(&#39;%s,&#39; % selection.assignrepr(blanks))
</span><span class="miss">            lines[-1] = lines[-1][:-1] + &#39;)&#39;
</span><span class="noop">        else:
</span><span class="miss">            lines = [&#39;%s)&#39; % prefix]
</span><span class="miss">        return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return [&#39;names&#39;, &#39;selections&#39;, &#39;assignrepr&#39;] + list(self.names)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Selection(object):
</span><span class="noop">    &#34;&#34;&#34;Defines a combination of :class:`~hydpy.core.node.Node` and
</span><span class="noop">    :class:`~hydpy.core.element.Element` objects suitable for a
</span><span class="noop">    specific task.
</span><span class="noop">
</span><span class="noop">    Attributes:
</span><span class="noop">        * name (:class:`str`): Name of the selection.
</span><span class="noop">        * nodes (:class:`~hydpy.core.node.Nodes`):
</span><span class="noop">          Currently selected nodes.
</span><span class="noop">        * elements (:class:`~hydpy.core.element.Elements`):
</span><span class="noop">          Currently selected elements.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self, name, nodes=None, elements=None):
</span><span class="hit">        self.name = name
</span><span class="hit">        self.nodes = devicetools.Nodes(nodes)
</span><span class="hit">        self.elements = devicetools.Elements(elements)
</span><span class="noop">
</span><span class="hit">    def select_upstream(self, device):
</span><span class="noop">        &#34;&#34;&#34;Limit the current selection to the network upstream of the given
</span><span class="noop">        starting point, including the starting point itself.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * device (:class:`~hydpy.core.devicetools.Node` or
</span><span class="noop">              :class:`~hydpy.core.devicetools.Element`): Lowest point
</span><span class="noop">              to be selected.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        self.nodes, self.elements = self.getby_upstream(device)
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def deselect_upstream(self, device):
</span><span class="noop">        &#34;&#34;&#34;Remove the network upstream of the given starting point from the
</span><span class="noop">        current selection, including the starting point itself.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * device (:class:`~hydpy.core.devicetools.Node` or
</span><span class="noop">              :class:`~hydpy.core.devicetools.Element`): Highest point
</span><span class="noop">              to be deselected.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        nodes, elements = self.getby_upstream(device)
</span><span class="hit">        self.nodes -= nodes
</span><span class="hit">        self.elements -= elements
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def getby_upstream(self, device):
</span><span class="noop">        &#34;&#34;&#34;Returns the network upstream of the given starting point, including
</span><span class="noop">        the starting point itself.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * device (:class:`~hydpy.core.devicetools.Node` or
</span><span class="noop">              :class:`~hydpy.core.devicetools.Element`): Lowest point
</span><span class="noop">              to be selected.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        nodes = devicetools.Nodes()
</span><span class="hit">        elements = devicetools.Elements()
</span><span class="hit">        if isinstance(device, devicetools.Node):
</span><span class="hit">            nodes, elements = self._nextnode(device, nodes, elements)
</span><span class="miss">        elif isinstance(device, devicetools.Element):
</span><span class="miss">            nodes, elements = self._nextelement(device, nodes, elements)
</span><span class="noop">        else:
</span><span class="miss">            raise AttributeError(&#39;Pass either a `Node` or an `Element` &#39;
</span><span class="noop">                                 &#39;instance to the function.  The given &#39;
</span><span class="noop">                                 &#39;`device` value `%s` is of type `%s`.&#39;
</span><span class="noop">                                 % (device, type(device)))
</span><span class="hit">        return nodes, elements
</span><span class="noop">
</span><span class="hit">    def _nextnode(self, node, nodes, elements):
</span><span class="noop">        &#34;&#34;&#34;First recursion method for :func:`~Selection.getupstreamnetwork`.
</span><span class="noop">
</span><span class="noop">        Arguments:
</span><span class="noop">            * node (:class:`~hydpy.core.devicetools.Node`): The node which
</span><span class="noop">              is selected currently.
</span><span class="noop">            * nodes (:class:`~hydpy.core.devicetools.Nodes`): All nodes
</span><span class="noop">            which have been selected so far.
</span><span class="noop">            * elements (:class:`~hydpy.core.devicetools.Elements`): All
</span><span class="noop">            elements which have been selected so far.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if (node not in nodes) and (node in self.nodes):
</span><span class="hit">            nodes += node
</span><span class="hit">            for (name, element) in node.entries:
</span><span class="hit">                nodes, elements = self._nextelement(element, nodes, elements)
</span><span class="hit">        return nodes, elements
</span><span class="noop">
</span><span class="hit">    def _nextelement(self, element, nodes, elements):
</span><span class="noop">        &#34;&#34;&#34;Second recursion method for :func:`~Selection.getupstreamnetwork`.
</span><span class="noop">
</span><span class="noop">        Arguments:
</span><span class="noop">            * element (:class:`~hydpy.core.devicetools.Element`): The
</span><span class="noop">              element which is selected currently.
</span><span class="noop">            * nodes (:class:`~hydpy.core.devicetools.Nodes`): All nodes
</span><span class="noop">            which have been selected so far.
</span><span class="noop">            * elements (:class:`~hydpy.core.devicetools.Elements`): All
</span><span class="noop">            elements which have been selected so far.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if (element not in elements) and (element in self.elements):
</span><span class="hit">            elements += element
</span><span class="hit">            for (name, node) in element.inlets:
</span><span class="hit">                nodes, elements = self._nextnode(node, nodes, elements)
</span><span class="hit">        return nodes, elements
</span><span class="noop">
</span><span class="hit">    def select_modelclasses(self, *modelclass):
</span><span class="noop">        &#34;&#34;&#34;Limits the current selection to all elements containing the
</span><span class="noop">        given modelclass(es).  (All nodes are removed.)
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * modelclass (subclass of :class:`~hydpy.core.models.Model`):
</span><span class="noop">              Model type(s) as the selection criterion/criteria.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        self.nodes = devicetools.Nodes()
</span><span class="miss">        self.elements = self.getby_modelclasses(modelclass)
</span><span class="miss">        return self
</span><span class="noop">
</span><span class="hit">    def deselect_modelclasses(self, *modelclasses):
</span><span class="noop">        &#34;&#34;&#34;Limits the current selection to all elements not containing the
</span><span class="noop">        given modelclass(es).  (All nodes are removed.)
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * modelclass (subclass of :class:`~hydpy.core.models.Model`):
</span><span class="noop">              Model type(s) as the selection criterion/criteria.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        self.nodes = devicetools.Nodes()
</span><span class="miss">        self.elements -= self.getby_modelclasses(*modelclasses)
</span><span class="miss">        return self
</span><span class="noop">
</span><span class="hit">    def getby_modelclasses(self, *modelclasses):
</span><span class="noop">        &#34;&#34;&#34;Returns all elements of the current selection containing the given
</span><span class="noop">        modelclass(es).
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * modelclass (subclass of :class:`~hydpy.core.models.Model`):
</span><span class="noop">              Model type(s) as the selection criterion/criteria.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        elements = devicetools.Elements()
</span><span class="miss">        for (name, element) in self.elements:
</span><span class="miss">            if element.model is None:
</span><span class="miss">                raise RuntimeError(&#39;For element `%s` no model object has been &#39;
</span><span class="noop">                                   &#39;initialized so far, which is a necessary &#39;
</span><span class="noop">                                   &#39;condition to perform (de)selections based &#39;
</span><span class="noop">                                   &#39;on model classes.&#39; % name)
</span><span class="miss">            if isinstance(element.model, modelclasses):
</span><span class="miss">                elements += element
</span><span class="miss">        return elements
</span><span class="noop">
</span><span class="hit">    def select_nodenames(self, *substrings):
</span><span class="noop">        &#34;&#34;&#34;Limits the current selection to all nodes with a name
</span><span class="noop">        containing the given substring(s).  (All elements are unaffected.)
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * substrings (:class:`str`): (Possible) Part(s) of the nodes
</span><span class="noop">              name as the selection criterion/criteria.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        self.nodes = self.getby_nodenames(*substrings)
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def deselect_nodenames(self, *substrings):
</span><span class="noop">        &#34;&#34;&#34;Limits the current selection to all nodes with a name
</span><span class="noop">        not containing the given substring(s).  (All elements are unaffected.)
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * substrings (:class:`str`): (Possible) Part(s) of the nodes
</span><span class="noop">              name as the selection criterion/criteria.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        self.nodes -= self.getby_nodenames(*substrings)
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def getby_nodenames(self, *substrings):
</span><span class="noop">        &#34;&#34;&#34;Returns all nodes of the current selection with a name
</span><span class="noop">        containing the given substrings(s).
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * substrings (:class:`str`): (Possible) Part(s) of the nodes
</span><span class="noop">              name as the selection criterion/criteria.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        nodes = devicetools.Nodes()
</span><span class="hit">        for (name, node) in self.nodes:
</span><span class="hit">            for substring in substrings:
</span><span class="hit">                if substring in name:
</span><span class="hit">                    nodes += node
</span><span class="hit">                    break
</span><span class="hit">        return nodes
</span><span class="noop">
</span><span class="hit">    def select_elementnames(self, *substrings):
</span><span class="noop">        &#34;&#34;&#34;Limits the current selection to all elements with a name
</span><span class="noop">        containing the given substring(s).  (All nodes are unaffected.)
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * substrings (:class:`str`): (Possible) Part(s) of the elements
</span><span class="noop">              name as the selection criterion/criteria.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        self.elements = self.getby_elementnames(*substrings)
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def deselect_elementnames(self, *substrings):
</span><span class="noop">        &#34;&#34;&#34;Limits the current selection to all elements with a name
</span><span class="noop">        not containing the given substring(s).  (All nodes are unaffected.)
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * substrings (:class:`str`): (Possible) Part(s) of the elements
</span><span class="noop">              name as the selection criterion/criteria.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        self.elements -= self.getby_elementnames(*substrings)
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def getby_elementnames(self, *substrings):
</span><span class="noop">        &#34;&#34;&#34;Returns all elements of the current selection with a name
</span><span class="noop">        containing the given substrings(s).
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * substrings (:class:`str`): (Possible) Part(s) of the elements
</span><span class="noop">              name as the selection criterion/criteria.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        elements = devicetools.Elements()
</span><span class="hit">        for (name, element) in self.elements:
</span><span class="hit">            for substring in substrings:
</span><span class="hit">                if substring in name:
</span><span class="hit">                    elements += element
</span><span class="hit">                    break
</span><span class="hit">        return elements
</span><span class="noop">
</span><span class="hit">    def copy(self, name):
</span><span class="noop">        &#34;&#34;&#34;Returns a semi-deep copy of the current selection.
</span><span class="noop">
</span><span class="noop">        Arguments:
</span><span class="noop">            * name (:class:`str`): Name of the new :class:`Selection` instance.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return Selection(name, self.nodes.copy(), self.elements.copy())
</span><span class="noop">
</span><span class="hit">    def __len__(self):
</span><span class="hit">        return len(self.nodes) + len(self.elements)
</span><span class="noop">
</span><span class="hit">    def __iadd__(self, other):
</span><span class="hit">        self.nodes += other.nodes
</span><span class="hit">        self.elements += other.elements
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def __isub__(self, other):
</span><span class="hit">        self.nodes -= other.nodes
</span><span class="hit">        self.elements -= other.elements
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def __lt__(self, other):
</span><span class="miss">        return ((self.nodes &lt; other.nodes) and
</span><span class="noop">                (self.elements &lt; other.elements))
</span><span class="noop">
</span><span class="hit">    def __le__(self, other):
</span><span class="miss">        return ((self.nodes &lt;= other.nodes) and
</span><span class="noop">                (self.elements &lt;= other.elements))
</span><span class="noop">
</span><span class="hit">    def __eq__(self, other):
</span><span class="miss">        return ((self.nodes == other.nodes) and
</span><span class="noop">                (self.elements == other.elements))
</span><span class="noop">
</span><span class="hit">    def __ne__(self, other):
</span><span class="miss">        return ((self.nodes != other.nodes) or
</span><span class="noop">                (self.elements != other.elements))
</span><span class="noop">
</span><span class="hit">    def __ge__(self, other):
</span><span class="miss">        return ((self.nodes &gt;= other.nodes) and
</span><span class="noop">                (self.elements &gt;= other.elements))
</span><span class="noop">
</span><span class="hit">    def __gt__(self, other):
</span><span class="miss">        return ((self.nodes &gt; other.nodes) and
</span><span class="noop">                (self.elements &gt;= other.elements))
</span><span class="noop">
</span><span class="hit">    def __str__(self):
</span><span class="miss">        return self.name
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="miss">        return self.assignrepr(&#39;&#39;)
</span><span class="noop">
</span><span class="hit">    def assignrepr(self, prefix):
</span><span class="noop">        &#34;&#34;&#34;Return a :func:`repr` string with an prefixed assignement.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * prefix(:class:`str`): Usually something like &#39;x = &#39;.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        prefixblanks = &#39; &#39; * len(prefix)
</span><span class="miss">        lines = [&#39;%sSelection(&#34;%s&#34;,&#39; % (prefix, self.name)]
</span><span class="miss">        blanks = &#39; &#39; * (len(prefix) + 22)
</span><span class="miss">        names = sorted(self.nodes.names)
</span><span class="miss">        if names:
</span><span class="miss">            lines.append(&#39;%s          nodes=Nodes(&#34;%s&#34;,&#39;
</span><span class="noop">                         % (prefixblanks, names[0]))
</span><span class="miss">            for name in names[1:]:
</span><span class="miss">                lines.append(&#39;%s&#34;%s&#34;,&#39; % (blanks, name))
</span><span class="miss">            lines[-1] = lines[-1][:-1] + &#39;),&#39;
</span><span class="noop">        else:
</span><span class="miss">            lines.append(&#39;%sSelection(nodes=Nodes(),&#39;
</span><span class="noop">                         % prefixblanks)
</span><span class="miss">        blanks = &#39; &#39; * (len(prefix) + 28)
</span><span class="miss">        names = sorted(self.elements.names)
</span><span class="miss">        if names:
</span><span class="miss">            lines.append(&#39;%s          elements=Elements(&#34;%s&#34;,&#39;
</span><span class="noop">                         % (prefixblanks, names[0]))
</span><span class="miss">            for name in names[1:]:
</span><span class="miss">                lines.append(&#39;%s&#34;%s&#34;,&#39; % (blanks, name))
</span><span class="miss">            lines[-1] = lines[-1][:-1] + &#39;))&#39;
</span><span class="noop">        else:
</span><span class="miss">            lines.append(&#39;%s          elements=Elements())&#39;
</span><span class="noop">                         % prefixblanks)
</span><span class="miss">        return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return [&#39;copy&#39;, &#39;deselect_elementnames&#39;, &#39;deselect_modelclasses&#39;,
</span><span class="noop">                &#39;deselect_nodenames&#39;, &#39;deselect_upstream&#39;, &#39;elements&#39;,
</span><span class="noop">                &#39;getby_elementnames&#39;, &#39;getby_modelclasses&#39;, &#39;getby_nodenames&#39;,
</span><span class="noop">                &#39;getby_upstream&#39;, &#39;nodes&#39;, &#39;select_elementnames&#39;,
</span><span class="noop">                &#39;select_modelclasses&#39;, &#39;select_nodenames&#39;, &#39;select_upstream&#39;,
</span><span class="noop">                &#39;assignrepr&#39;]
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/sequencetools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/sequencetools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
677 &nbsp;
678 &nbsp;
679 &nbsp;
680 &nbsp;
681 &nbsp;
682 &nbsp;
683 &nbsp;
684 &nbsp;
685 &nbsp;
686 &nbsp;
687 &nbsp;
688 &nbsp;
689 &nbsp;
690 &nbsp;
691 &nbsp;
692 &nbsp;
693 &nbsp;
694 &nbsp;
695 &nbsp;
696 &nbsp;
697 &nbsp;
698 &nbsp;
699 &nbsp;
700 &nbsp;
701 &nbsp;
702 &nbsp;
703 &nbsp;
704 &nbsp;
705 &nbsp;
706 &nbsp;
707 &nbsp;
708 &nbsp;
709 &nbsp;
710 &nbsp;
711 &nbsp;
712 &nbsp;
713 &nbsp;
714 &nbsp;
715 &nbsp;
716 &nbsp;
717 &nbsp;
718 &nbsp;
719 &nbsp;
720 &nbsp;
721 &nbsp;
722 &nbsp;
723 &nbsp;
724 &nbsp;
725 &nbsp;
726 &nbsp;
727 &nbsp;
728 &nbsp;
729 &nbsp;
730 &nbsp;
731 &nbsp;
732 &nbsp;
733 &nbsp;
734 &nbsp;
735 &nbsp;
736 &nbsp;
737 &nbsp;
738 &nbsp;
739 &nbsp;
740 &nbsp;
741 &nbsp;
742 &nbsp;
743 &nbsp;
744 &nbsp;
745 &nbsp;
746 &nbsp;
747 &nbsp;
748 &nbsp;
749 &nbsp;
750 &nbsp;
751 &nbsp;
752 &nbsp;
753 &nbsp;
754 &nbsp;
755 &nbsp;
756 &nbsp;
757 &nbsp;
758 &nbsp;
759 &nbsp;
760 &nbsp;
761 &nbsp;
762 &nbsp;
763 &nbsp;
764 &nbsp;
765 &nbsp;
766 &nbsp;
767 &nbsp;
768 &nbsp;
769 &nbsp;
770 &nbsp;
771 &nbsp;
772 &nbsp;
773 &nbsp;
774 &nbsp;
775 &nbsp;
776 &nbsp;
777 &nbsp;
778 &nbsp;
779 &nbsp;
780 &nbsp;
781 &nbsp;
782 &nbsp;
783 &nbsp;
784 &nbsp;
785 &nbsp;
786 &nbsp;
787 &nbsp;
788 &nbsp;
789 &nbsp;
790 &nbsp;
791 &nbsp;
792 &nbsp;
793 &nbsp;
794 &nbsp;
795 &nbsp;
796 &nbsp;
797 &nbsp;
798 &nbsp;
799 &nbsp;
800 &nbsp;
801 &nbsp;
802 &nbsp;
803 &nbsp;
804 &nbsp;
805 &nbsp;
806 &nbsp;
807 &nbsp;
808 &nbsp;
809 &nbsp;
810 &nbsp;
811 &nbsp;
812 &nbsp;
813 &nbsp;
814 &nbsp;
815 &nbsp;
816 &nbsp;
817 &nbsp;
818 &nbsp;
819 &nbsp;
820 &nbsp;
821 &nbsp;
822 &nbsp;
823 &nbsp;
824 &nbsp;
825 &nbsp;
826 &nbsp;
827 &nbsp;
828 &nbsp;
829 &nbsp;
830 &nbsp;
831 &nbsp;
832 &nbsp;
833 &nbsp;
834 &nbsp;
835 &nbsp;
836 &nbsp;
837 &nbsp;
838 &nbsp;
839 &nbsp;
840 &nbsp;
841 &nbsp;
842 &nbsp;
843 &nbsp;
844 &nbsp;
845 &nbsp;
846 &nbsp;
847 &nbsp;
848 &nbsp;
849 &nbsp;
850 &nbsp;
851 &nbsp;
852 &nbsp;
853 &nbsp;
854 &nbsp;
855 &nbsp;
856 &nbsp;
857 &nbsp;
858 &nbsp;
859 &nbsp;
860 &nbsp;
861 &nbsp;
862 &nbsp;
863 &nbsp;
864 &nbsp;
865 &nbsp;
866 &nbsp;
867 &nbsp;
868 &nbsp;
869 &nbsp;
870 &nbsp;
871 &nbsp;
872 &nbsp;
873 &nbsp;
874 &nbsp;
875 &nbsp;
876 &nbsp;
877 &nbsp;
878 &nbsp;
879 &nbsp;
880 &nbsp;
881 &nbsp;
882 &nbsp;
883 &nbsp;
884 &nbsp;
885 &nbsp;
886 &nbsp;
887 &nbsp;
888 &nbsp;
889 &nbsp;
890 &nbsp;
891 &nbsp;
892 &nbsp;
893 &nbsp;
894 &nbsp;
895 &nbsp;
896 &nbsp;
897 &nbsp;
898 &nbsp;
899 &nbsp;
900 &nbsp;
901 &nbsp;
902 &nbsp;
903 &nbsp;
904 &nbsp;
905 &nbsp;
906 &nbsp;
907 &nbsp;
908 &nbsp;
909 &nbsp;
910 &nbsp;
911 &nbsp;
912 &nbsp;
913 &nbsp;
914 &nbsp;
915 &nbsp;
916 &nbsp;
917 &nbsp;
918 &nbsp;
919 &nbsp;
920 &nbsp;
921 &nbsp;
922 &nbsp;
923 &nbsp;
924 &nbsp;
925 &nbsp;
926 &nbsp;
927 &nbsp;
928 &nbsp;
929 &nbsp;
930 &nbsp;
931 &nbsp;
932 &nbsp;
933 &nbsp;
934 &nbsp;
935 &nbsp;
936 &nbsp;
937 &nbsp;
938 &nbsp;
939 &nbsp;
940 &nbsp;
941 &nbsp;
942 &nbsp;
943 &nbsp;
944 &nbsp;
945 &nbsp;
946 &nbsp;
947 &nbsp;
948 &nbsp;
949 &nbsp;
950 &nbsp;
951 &nbsp;
952 &nbsp;
953 &nbsp;
954 &nbsp;
955 &nbsp;
956 &nbsp;
957 &nbsp;
958 &nbsp;
959 &nbsp;
960 &nbsp;
961 &nbsp;
962 &nbsp;
963 &nbsp;
964 &nbsp;
965 &nbsp;
966 &nbsp;
967 &nbsp;
968 &nbsp;
969 &nbsp;
970 &nbsp;
971 &nbsp;
972 &nbsp;
973 &nbsp;
974 &nbsp;
975 &nbsp;
976 &nbsp;
977 &nbsp;
978 &nbsp;
979 &nbsp;
980 &nbsp;
981 &nbsp;
982 &nbsp;
983 &nbsp;
984 &nbsp;
985 &nbsp;
986 &nbsp;
987 &nbsp;
988 &nbsp;
989 &nbsp;
990 &nbsp;
991 &nbsp;
992 &nbsp;
993 &nbsp;
994 &nbsp;
995 &nbsp;
996 &nbsp;
997 &nbsp;
998 &nbsp;
999 &nbsp;
1000 &nbsp;
1001 &nbsp;
1002 &nbsp;
1003 &nbsp;
1004 &nbsp;
1005 &nbsp;
1006 &nbsp;
1007 &nbsp;
1008 &nbsp;
1009 &nbsp;
1010 &nbsp;
1011 &nbsp;
1012 &nbsp;
1013 &nbsp;
1014 &nbsp;
1015 &nbsp;
1016 &nbsp;
1017 &nbsp;
1018 &nbsp;
1019 &nbsp;
1020 &nbsp;
1021 &nbsp;
1022 &nbsp;
1023 &nbsp;
1024 &nbsp;
1025 &nbsp;
1026 &nbsp;
1027 &nbsp;
1028 &nbsp;
1029 &nbsp;
1030 &nbsp;
1031 &nbsp;
1032 &nbsp;
1033 &nbsp;
1034 &nbsp;
1035 &nbsp;
1036 &nbsp;
1037 &nbsp;
1038 &nbsp;
1039 &nbsp;
1040 &nbsp;
1041 &nbsp;
1042 &nbsp;
1043 &nbsp;
1044 &nbsp;
1045 &nbsp;
1046 &nbsp;
1047 &nbsp;
1048 &nbsp;
1049 &nbsp;
1050 &nbsp;
1051 &nbsp;
1052 &nbsp;
1053 &nbsp;
1054 &nbsp;
1055 &nbsp;
1056 &nbsp;
1057 &nbsp;
1058 &nbsp;
1059 &nbsp;
1060 &nbsp;
1061 &nbsp;
1062 &nbsp;
1063 &nbsp;
1064 &nbsp;
1065 &nbsp;
1066 &nbsp;
1067 &nbsp;
1068 &nbsp;
1069 &nbsp;
1070 &nbsp;
1071 &nbsp;
1072 &nbsp;
1073 &nbsp;
1074 &nbsp;
1075 &nbsp;
1076 &nbsp;
1077 &nbsp;
1078 &nbsp;
1079 &nbsp;
1080 &nbsp;
1081 &nbsp;
1082 &nbsp;
1083 &nbsp;
1084 &nbsp;
1085 &nbsp;
1086 &nbsp;
1087 &nbsp;
1088 &nbsp;
1089 &nbsp;
1090 &nbsp;
1091 &nbsp;
1092 &nbsp;
1093 &nbsp;
1094 &nbsp;
1095 &nbsp;
1096 &nbsp;
1097 &nbsp;
1098 &nbsp;
1099 &nbsp;
1100 &nbsp;
1101 &nbsp;
1102 &nbsp;
1103 &nbsp;
1104 &nbsp;
1105 &nbsp;
1106 &nbsp;
1107 &nbsp;
1108 &nbsp;
1109 &nbsp;
1110 &nbsp;
1111 &nbsp;
1112 &nbsp;
1113 &nbsp;
1114 &nbsp;
1115 &nbsp;
1116 &nbsp;
1117 &nbsp;
1118 &nbsp;
1119 &nbsp;
1120 &nbsp;
1121 &nbsp;
1122 &nbsp;
1123 &nbsp;
1124 &nbsp;
1125 &nbsp;
1126 &nbsp;
1127 &nbsp;
1128 &nbsp;
1129 &nbsp;
1130 &nbsp;
1131 &nbsp;
1132 &nbsp;
1133 &nbsp;
1134 &nbsp;
1135 &nbsp;
1136 &nbsp;
1137 &nbsp;
1138 &nbsp;
1139 &nbsp;
1140 &nbsp;
1141 &nbsp;
1142 &nbsp;
1143 &nbsp;
1144 &nbsp;
1145 &nbsp;
1146 &nbsp;
1147 &nbsp;
1148 &nbsp;
1149 &nbsp;
1150 &nbsp;
1151 &nbsp;
1152 &nbsp;
1153 &nbsp;
1154 &nbsp;
1155 &nbsp;
1156 &nbsp;
1157 &nbsp;
1158 &nbsp;
1159 &nbsp;
1160 &nbsp;
1161 &nbsp;
1162 &nbsp;
1163 &nbsp;
1164 &nbsp;
1165 &nbsp;
1166 &nbsp;
1167 &nbsp;
1168 &nbsp;
1169 &nbsp;
1170 &nbsp;
1171 &nbsp;
1172 &nbsp;
1173 &nbsp;
1174 &nbsp;
1175 &nbsp;
1176 &nbsp;
1177 &nbsp;
1178 &nbsp;
1179 &nbsp;
1180 &nbsp;
1181 &nbsp;
1182 &nbsp;
1183 &nbsp;
1184 &nbsp;
1185 &nbsp;
1186 &nbsp;
1187 &nbsp;
1188 &nbsp;
1189 &nbsp;
1190 &nbsp;
1191 &nbsp;
1192 &nbsp;
1193 &nbsp;
1194 &nbsp;
1195 &nbsp;
1196 &nbsp;
1197 &nbsp;
1198 &nbsp;
1199 &nbsp;
1200 &nbsp;
1201 &nbsp;
1202 &nbsp;
1203 &nbsp;
1204 &nbsp;
1205 &nbsp;
1206 &nbsp;
1207 &nbsp;
1208 &nbsp;
1209 &nbsp;
1210 &nbsp;
1211 &nbsp;
1212 &nbsp;
1213 &nbsp;
1214 &nbsp;
1215 &nbsp;
1216 &nbsp;
1217 &nbsp;
1218 &nbsp;
1219 &nbsp;
1220 &nbsp;
1221 &nbsp;
1222 &nbsp;
1223 &nbsp;
1224 &nbsp;
1225 &nbsp;
1226 &nbsp;
1227 &nbsp;
1228 &nbsp;
1229 &nbsp;
1230 &nbsp;
1231 &nbsp;
1232 &nbsp;
1233 &nbsp;
1234 &nbsp;
1235 &nbsp;
1236 &nbsp;
1237 &nbsp;
1238 &nbsp;
1239 &nbsp;
1240 &nbsp;
1241 &nbsp;
1242 &nbsp;
1243 &nbsp;
1244 &nbsp;
1245 &nbsp;
1246 &nbsp;
1247 &nbsp;
1248 &nbsp;
1249 &nbsp;
1250 &nbsp;
1251 &nbsp;
1252 &nbsp;
1253 &nbsp;
1254 &nbsp;
1255 &nbsp;
1256 &nbsp;
1257 &nbsp;
1258 &nbsp;
1259 &nbsp;
1260 &nbsp;
1261 &nbsp;
1262 &nbsp;
1263 &nbsp;
1264 &nbsp;
1265 &nbsp;
1266 &nbsp;
1267 &nbsp;
1268 &nbsp;
1269 &nbsp;
1270 &nbsp;
1271 &nbsp;
1272 &nbsp;
1273 &nbsp;
1274 &nbsp;
1275 &nbsp;
1276 &nbsp;
1277 &nbsp;
1278 &nbsp;
1279 &nbsp;
1280 &nbsp;
1281 &nbsp;
1282 &nbsp;
1283 &nbsp;
1284 &nbsp;
1285 &nbsp;
1286 &nbsp;
1287 &nbsp;
1288 &nbsp;
1289 &nbsp;
1290 &nbsp;
1291 &nbsp;
1292 &nbsp;
1293 &nbsp;
1294 &nbsp;
1295 &nbsp;
1296 &nbsp;
1297 &nbsp;
1298 &nbsp;
1299 &nbsp;
1300 &nbsp;
1301 &nbsp;
1302 &nbsp;
1303 &nbsp;
1304 &nbsp;
1305 &nbsp;
1306 &nbsp;
1307 &nbsp;
1308 &nbsp;
1309 &nbsp;
1310 &nbsp;
1311 &nbsp;
1312 &nbsp;
1313 &nbsp;
1314 &nbsp;
1315 &nbsp;
1316 &nbsp;
1317 &nbsp;
1318 &nbsp;
1319 &nbsp;
1320 &nbsp;
1321 &nbsp;
1322 &nbsp;
1323 &nbsp;
1324 &nbsp;
1325 &nbsp;
1326 &nbsp;
1327 &nbsp;
1328 &nbsp;
1329 &nbsp;
1330 &nbsp;
1331 &nbsp;
1332 &nbsp;
1333 &nbsp;
1334 &nbsp;
1335 &nbsp;
1336 &nbsp;
1337 &nbsp;
1338 &nbsp;
1339 &nbsp;
1340 &nbsp;
1341 &nbsp;
1342 &nbsp;
1343 &nbsp;
1344 &nbsp;
1345 &nbsp;
1346 &nbsp;
1347 &nbsp;
1348 &nbsp;
1349 &nbsp;
1350 &nbsp;
1351 &nbsp;
1352 &nbsp;
1353 &nbsp;
1354 &nbsp;
1355 &nbsp;
1356 &nbsp;
1357 &nbsp;
1358 &nbsp;
1359 &nbsp;
1360 &nbsp;
1361 &nbsp;
1362 &nbsp;
1363 &nbsp;
1364 &nbsp;
1365 &nbsp;
1366 &nbsp;
1367 &nbsp;
1368 &nbsp;
1369 &nbsp;
1370 &nbsp;
1371 &nbsp;
1372 &nbsp;
1373 &nbsp;
1374 &nbsp;
1375 &nbsp;
1376 &nbsp;
1377 &nbsp;
1378 &nbsp;
1379 &nbsp;
1380 &nbsp;
1381 &nbsp;
1382 &nbsp;
1383 &nbsp;
1384 &nbsp;
1385 &nbsp;
1386 &nbsp;
1387 &nbsp;
1388 &nbsp;
1389 &nbsp;
1390 &nbsp;
1391 &nbsp;
1392 &nbsp;
1393 &nbsp;
1394 &nbsp;
1395 &nbsp;
1396 &nbsp;
1397 &nbsp;
1398 &nbsp;
1399 &nbsp;
1400 &nbsp;
1401 &nbsp;
1402 &nbsp;
1403 &nbsp;
1404 &nbsp;
1405 &nbsp;
1406 &nbsp;
1407 &nbsp;
1408 &nbsp;
1409 &nbsp;
1410 &nbsp;
1411 &nbsp;
1412 &nbsp;
1413 &nbsp;
1414 &nbsp;
1415 &nbsp;
1416 &nbsp;
1417 &nbsp;
1418 &nbsp;
1419 &nbsp;
1420 &nbsp;
1421 &nbsp;
1422 &nbsp;
1423 &nbsp;
1424 &nbsp;
1425 &nbsp;
1426 &nbsp;
1427 &nbsp;
1428 &nbsp;
1429 &nbsp;
1430 &nbsp;
1431 &nbsp;
1432 &nbsp;
1433 &nbsp;
1434 &nbsp;
1435 &nbsp;
1436 &nbsp;
1437 &nbsp;
1438 &nbsp;
1439 &nbsp;
1440 &nbsp;
1441 &nbsp;
1442 &nbsp;
1443 &nbsp;
1444 &nbsp;
1445 &nbsp;
1446 &nbsp;
1447 &nbsp;
1448 &nbsp;
1449 &nbsp;
1450 &nbsp;
1451 &nbsp;
1452 &nbsp;
1453 &nbsp;
1454 &nbsp;
1455 &nbsp;
1456 &nbsp;
1457 &nbsp;
1458 &nbsp;
1459 &nbsp;
1460 &nbsp;
1461 &nbsp;
1462 &nbsp;
1463 &nbsp;
1464 &nbsp;
1465 &nbsp;
1466 &nbsp;
1467 &nbsp;
1468 &nbsp;
1469 &nbsp;
1470 &nbsp;
1471 &nbsp;
1472 &nbsp;
1473 &nbsp;
1474 &nbsp;
1475 &nbsp;
1476 &nbsp;
1477 &nbsp;
1478 &nbsp;
1479 &nbsp;
1480 &nbsp;
1481 &nbsp;
1482 &nbsp;
1483 &nbsp;
1484 &nbsp;
1485 &nbsp;
1486 &nbsp;
1487 &nbsp;
1488 &nbsp;
1489 &nbsp;
1490 &nbsp;
1491 &nbsp;
1492 &nbsp;
1493 &nbsp;
1494 &nbsp;
1495 &nbsp;
1496 &nbsp;
1497 &nbsp;
1498 &nbsp;
1499 &nbsp;
1500 &nbsp;
1501 &nbsp;
1502 &nbsp;
1503 &nbsp;
1504 &nbsp;
1505 &nbsp;
1506 &nbsp;
1507 &nbsp;
1508 &nbsp;
1509 &nbsp;
1510 &nbsp;
1511 &nbsp;
1512 &nbsp;
1513 &nbsp;
1514 &nbsp;
1515 &nbsp;
1516 &nbsp;
1517 &nbsp;
1518 &nbsp;
1519 &nbsp;
1520 &nbsp;
1521 &nbsp;
1522 &nbsp;
1523 &nbsp;
1524 &nbsp;
1525 &nbsp;
1526 &nbsp;
1527 &nbsp;
1528 &nbsp;
1529 &nbsp;
1530 &nbsp;
1531 &nbsp;
1532 &nbsp;
1533 &nbsp;
1534 &nbsp;
1535 &nbsp;
1536 &nbsp;
1537 &nbsp;
1538 &nbsp;
1539 &nbsp;
1540 &nbsp;
1541 &nbsp;
1542 &nbsp;
1543 &nbsp;
1544 &nbsp;
1545 &nbsp;
1546 &nbsp;
1547 &nbsp;
1548 &nbsp;
1549 &nbsp;
1550 &nbsp;
1551 &nbsp;
1552 &nbsp;
1553 &nbsp;
1554 &nbsp;
1555 &nbsp;
1556 &nbsp;
1557 &nbsp;
1558 &nbsp;
1559 &nbsp;
1560 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;
</span><span class="noop">Created on Tue Dec 27 23:23:53 2016
</span><span class="noop">
</span><span class="noop">@author: tyralla
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import os
</span><span class="hit">import sys
</span><span class="hit">import copy
</span><span class="hit">import struct
</span><span class="hit">import textwrap
</span><span class="hit">import warnings
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy.core import timetools
</span><span class="hit">from hydpy.core import objecttools
</span><span class="hit">from hydpy.cythons import pointer
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Sequences(object):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling all sequences of a specific model.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self, kwargs):
</span><span class="hit">        self.model = kwargs.get(&#39;model&#39;)
</span><span class="hit">        cythonmodule = kwargs.get(&#39;cythonmodule&#39;)
</span><span class="hit">        cymodel = kwargs.get(&#39;cymodel&#39;)
</span><span class="hit">        for (name, cls) in kwargs.items():
</span><span class="hit">            if name.endswith(&#39;Sequences&#39;) and issubclass(cls, SubSequences):
</span><span class="hit">                if cythonmodule:
</span><span class="hit">                    cls_fastaccess = getattr(cythonmodule, name)
</span><span class="hit">                    subseqs = cls(self, cls_fastaccess, cymodel)
</span><span class="noop">                else:
</span><span class="hit">                    subseqs = cls(self, None, None)
</span><span class="hit">                setattr(self, subseqs.name, subseqs)
</span><span class="noop">
</span><span class="hit">    def set_initvals(self, info, idx_date):
</span><span class="miss">        self.states.set_initvals(info, idx_date)
</span><span class="noop">
</span><span class="hit">    def activate_disk(self, names=None):
</span><span class="miss">        for (name, subseqs) in self:
</span><span class="miss">            if hasattr(subseqs, &#39;activate_disk&#39;):
</span><span class="miss">                subseqs.activate_disk(names)
</span><span class="noop">
</span><span class="hit">    def deactivate_disk(self, names=None):
</span><span class="miss">        for (name, subseqs) in self:
</span><span class="miss">            if hasattr(subseqs, &#39;deactivate_disk&#39;):
</span><span class="miss">                subseqs.deactivate_disk(names)
</span><span class="noop">
</span><span class="hit">    def activate_ram(self, names=None):
</span><span class="miss">        for (name, subseqs) in self:
</span><span class="miss">            if hasattr(subseqs, &#39;activate_ram&#39;):
</span><span class="miss">                subseqs.activate_ram(names)
</span><span class="noop">
</span><span class="hit">    def deactivate_ram(self, names=None):
</span><span class="miss">        for (name, subseqs) in self:
</span><span class="miss">            if hasattr(subseqs, &#39;deactivate_ram&#39;):
</span><span class="miss">                subseqs.deactivate_ram(names)
</span><span class="noop">
</span><span class="hit">    def openfiles(self, idx=0):
</span><span class="hit">        for (name, subseqs) in self:
</span><span class="hit">            if hasattr(subseqs, &#39;openfiles&#39;):
</span><span class="hit">                subseqs.openfiles(idx)
</span><span class="noop">
</span><span class="hit">    def closefiles(self):
</span><span class="hit">        for (name, subseqs) in self:
</span><span class="hit">            if hasattr(subseqs, &#39;closefiles&#39;):
</span><span class="hit">                subseqs.closefiles()
</span><span class="noop">
</span><span class="hit">    def loaddata(self, idx):
</span><span class="hit">        for (name, subseqs) in self:
</span><span class="hit">            if hasattr(subseqs, &#39;loaddata&#39;):
</span><span class="hit">                subseqs.loaddata(idx)
</span><span class="noop">
</span><span class="hit">    def savedata(self, idx):
</span><span class="hit">        for (name, subseqs) in self:
</span><span class="hit">            if hasattr(subseqs, &#39;savedata&#39;):
</span><span class="hit">                subseqs.savedata(idx)
</span><span class="noop">
</span><span class="hit">    def reset(self):
</span><span class="miss">        for (name, subseqs) in self:
</span><span class="miss">            if hasattr(subseqs, &#39;reset&#39;):
</span><span class="miss">                subseqs.reset()
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="hit">        for (key, value) in vars(self).items():
</span><span class="hit">            if isinstance(value, SubSequences):
</span><span class="hit">                yield key, value
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def conditions(self):
</span><span class="noop">        &#34;&#34;&#34;Generator object yielding all conditions (class:`StateSequence` and
</span><span class="noop">        :class:`LogSequence` objects).
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        for subseqs in (&#39;states&#39;, &#39;logs&#39;):
</span><span class="miss">            for tuple_ in getattr(self, subseqs, ()):
</span><span class="miss">                yield tuple_
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def hasconditions(self):
</span><span class="noop">        &#34;&#34;&#34;True or False, whether the :class:`Sequences` object handles at
</span><span class="noop">        conditions (at least one :class:`StateSequence` or :class:`LogSequence`
</span><span class="noop">        object)  or not.&#34;&#34;&#34;
</span><span class="miss">        for tuple_ in self.conditions:
</span><span class="miss">            return True
</span><span class="miss">        return False
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def _conditiondefaultfilename(self):
</span><span class="miss">        filename = objecttools.devicename(self)
</span><span class="miss">        if filename == &#39;?&#39;:
</span><span class="miss">            raise RuntimeError(
</span><span class="noop">                &#39;To load or save the conditions of a model from or to a file, &#39;
</span><span class="noop">                &#39;its filename must be known.  This can be done, by passing &#39;
</span><span class="noop">                &#39;filename to function `loadconditions` or `saveconditions` &#39;
</span><span class="noop">                &#39;directly.  But in complete HydPy applications, it is usally &#39;
</span><span class="noop">                &#39;assumed to be consistent with the name of the element &#39;
</span><span class="noop">                &#39;handling the model.  Actually, neither a filename is given &#39;
</span><span class="noop">                &#39;nor does the model know its master element.&#39;)
</span><span class="noop">        else:
</span><span class="miss">            return filename + &#39;.py&#39;
</span><span class="noop">
</span><span class="hit">    def loadconditions(self, filename=None, dirname=None):
</span><span class="noop">        &#34;&#34;&#34;Load initial conditions from a file and assign them to the
</span><span class="noop">        respective sequences.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        if self.hasconditions:
</span><span class="miss">            if filename is None:
</span><span class="miss">                filename = self._conditiondefaultfilename
</span><span class="miss">            namespace = locals()
</span><span class="miss">            for (name, seq) in self.conditions:
</span><span class="miss">                namespace[name] = seq
</span><span class="miss">            namespace[&#39;model&#39;] = self
</span><span class="miss">            code = pub.conditionmanager.loadfile(filename, dirname)
</span><span class="miss">            try:
</span><span class="miss">                exec(code)
</span><span class="miss">            except BaseException:
</span><span class="miss">                objecttools.augmentexcmessage(&#39;While trying to gather initial &#39;
</span><span class="noop">                                              &#39;conditions of element %s&#39;
</span><span class="noop">                                              % objecttools.devicename(self))
</span><span class="noop">
</span><span class="hit">    def saveconditions(self, filename=None, dirname=None):
</span><span class="miss">        if self.hasconditions:
</span><span class="miss">            if filename is None:
</span><span class="miss">                filename = self._conditiondefaultfilename
</span><span class="miss">            if not filename.endswith(&#39;.py&#39;):
</span><span class="miss">                filename += &#39;.py&#39;
</span><span class="miss">            if dirname is None:
</span><span class="miss">                dirname = pub.conditionmanager.savepath
</span><span class="miss">            filepath = os.path.join(dirname, filename)
</span><span class="miss">            with open(filepath, &#39;w&#39;) as file_:
</span><span class="miss">                file_.write(&#39;from hydpy.models.%s import *\n\n&#39;
</span><span class="noop">                            % self.model.__module__.split(&#39;.&#39;)[2])
</span><span class="miss">                try:
</span><span class="miss">                    line = (&#39;controlcheck(projectdir=&#34;%s&#34;, controldir=&#34;%s&#34;)&#39;
</span><span class="noop">                            % (pub.controlmanager.projectdirectory,
</span><span class="noop">                               pub.controlmanager.controldirectory))
</span><span class="miss">                    file_.write(line + &#39;\n\n&#39;)
</span><span class="miss">                except BaseException:
</span><span class="miss">                    pass
</span><span class="miss">                for (name, seq) in self.conditions:
</span><span class="miss">                    file_.write(repr(seq) + &#39;\n&#39;)
</span><span class="noop">
</span><span class="hit">    def trimconditions(self):
</span><span class="miss">        for (name, seq) in self.conditions:
</span><span class="miss">            seq.trim()
</span><span class="noop">
</span><span class="hit">    def __len__(self):
</span><span class="miss">        return len(dict(self))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MetaSubSequencesType(type):
</span><span class="hit">    def __new__(cls, name, parents, dict_):
</span><span class="hit">        seqclasses = dict_.get(&#39;_SEQCLASSES&#39;)
</span><span class="hit">        if seqclasses is None:
</span><span class="hit">            raise NotImplementedError(
</span><span class="noop">                &#39;For class `%s`, the required tuple `_SEQCLASSES` is not &#39;
</span><span class="noop">                &#39;defined.  Please see the documentation of class &#39;
</span><span class="noop">                &#39;`SubSequences` of module `sequencetools` for further &#39;
</span><span class="noop">                &#39;information.&#39; % name)
</span><span class="hit">        if seqclasses:
</span><span class="hit">            lst = [&#39;\n\n\n    The following sequence classes are selected:&#39;]
</span><span class="hit">            for seqclass in seqclasses:
</span><span class="hit">                    lst.append(&#39;      * :class:`~%s` `%s`&#39;
</span><span class="noop">                               % (&#39;.&#39;.join((seqclass.__module__,
</span><span class="noop">                                            seqclass.__name__)),
</span><span class="noop">                                  objecttools.description(seqclass)))
</span><span class="hit">            doc = dict_.get(&#39;__doc__&#39;, None)
</span><span class="hit">            if doc is None:
</span><span class="hit">                doc = &#39;&#39;
</span><span class="hit">            dict_[&#39;__doc__&#39;] = doc + &#39;\n&#39;.join(l for l in lst)
</span><span class="hit">        return type.__new__(cls, name, parents, dict_)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">MetaSubSequencesClass = MetaSubSequencesType(&#39;MetaSubSequencesClass&#39;,
</span><span class="noop">                                             (), {&#39;_SEQCLASSES&#39;: ()})
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class SubSequences(MetaSubSequencesClass):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling subgroups of sequences.
</span><span class="noop">
</span><span class="noop">    Attributes:
</span><span class="noop">      * seqs: The parent :class:`Sequences` object.
</span><span class="noop">      * fastaccess: The  :class:`FastAccess` object allowing fast access to
</span><span class="noop">        the sequence values. In `Cython` mode, model specific cdef
</span><span class="noop">        classes are applied.
</span><span class="noop">
</span><span class="noop">    Additional attributes are the actual :class:`Sequence` instances,
</span><span class="noop">    representing the individual time series.  These need to be defined in
</span><span class="noop">    :class:`SubSequences` subclass.  Therefore, one needs to collect the
</span><span class="noop">    appropriate :class:`Sequence` subclasses in the (hidden) class attribute
</span><span class="noop">    :attr:`~SubSequences._SEQCLASSES`, as shown in the following example:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.sequencetools import *
</span><span class="noop">    &gt;&gt;&gt; class Temperature(Sequence):
</span><span class="noop">    ...    NDIM, NUMERIC = 0, False
</span><span class="noop">    &gt;&gt;&gt; class Precipitation(Sequence):
</span><span class="noop">    ...    NDIM, NUMERIC = 0, True
</span><span class="noop">    &gt;&gt;&gt; class InputSequences(SubSequences):
</span><span class="noop">    ...     _SEQCLASSES = (Temperature, Precipitation)
</span><span class="noop">    &gt;&gt;&gt; inputs = InputSequences(None) # Assign `None` for brevity.
</span><span class="noop">    &gt;&gt;&gt; inputs
</span><span class="noop">    temperature(nan)
</span><span class="noop">    precipitation(nan)
</span><span class="noop">
</span><span class="noop">    The order within the tuple determines the order of iteration, hence:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; for (name, sequence) in inputs:
</span><span class="noop">    ...     print(sequence)
</span><span class="noop">    temperature(nan)
</span><span class="noop">    precipitation(nan)
</span><span class="noop">
</span><span class="noop">    If one forgets to define a `_SEQCLASSES` tuple so (and maybe tries to add
</span><span class="noop">    the sequences in the constructor of the subclass of
</span><span class="noop">    :class:`SubSequences`, the following error is raised:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; class InputSequences(SubSequences):
</span><span class="noop">    ...     pass
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    NotImplementedError: For class `InputSequences`, the required tuple `_SEQCLASSES` is not defined.  Please see the documentation of class `SubSequences` of module `sequencetools` for further information.
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = ()
</span><span class="noop">
</span><span class="hit">    def __init__(self, seqs, cls_fastaccess=None, cymodel=None):
</span><span class="hit">        self.seqs = seqs
</span><span class="hit">        self._initfastaccess(cls_fastaccess, cymodel)
</span><span class="hit">        self._initsequences()
</span><span class="noop">
</span><span class="hit">    def _initfastaccess(self, cls_fastaccess, cymodel):
</span><span class="hit">        if cls_fastaccess is None:
</span><span class="hit">            self.fastaccess = FastAccess()
</span><span class="noop">        else:
</span><span class="hit">            self.fastaccess = cls_fastaccess()
</span><span class="hit">            setattr(cymodel, self.name, self.fastaccess)
</span><span class="noop">
</span><span class="hit">    def _initsequences(self):
</span><span class="hit">        for cls_seq in self._SEQCLASSES:
</span><span class="hit">            setattr(self, objecttools.instancename(cls_seq), cls_seq())
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def getname(cls):
</span><span class="hit">        return objecttools.instancename(cls)[:-8]
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def name(self):
</span><span class="hit">        return self.getname()
</span><span class="noop">
</span><span class="hit">    def __setattr__(self, name, value):
</span><span class="noop">        &#34;&#34;&#34;Attributes and methods should usually not be replaced.  Existing
</span><span class="noop">        :class:`Sequence` attributes are protected in a way, that only their
</span><span class="noop">        values are changed through assignements.  For new :class:`Sequence`
</span><span class="noop">        attributes, additional `fastaccess` references are defined.  If you
</span><span class="noop">        actually want to replace a sequence, you have to delete it first.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            attr = getattr(self, name)
</span><span class="hit">        except AttributeError:
</span><span class="hit">            object.__setattr__(self, name, value)
</span><span class="hit">            if isinstance(value, Sequence):
</span><span class="hit">                value.connect(self)
</span><span class="noop">        else:
</span><span class="hit">            try:
</span><span class="hit">                attr.values = value
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise RuntimeError(&#39;`%s` instances do not allow the direct&#39;
</span><span class="noop">                                   &#39;replacement of their members.  After &#39;
</span><span class="noop">                                   &#39;initialization you should usually only &#39;
</span><span class="noop">                                   &#39;change parameter values through &#39;
</span><span class="noop">                                   &#39;assignements.  If you really need to &#39;
</span><span class="noop">                                   &#39;replace a object member, delete it &#39;
</span><span class="noop">                                   &#39;beforehand.&#39; % objecttools.classname(self))
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="hit">        for seqclass in self._SEQCLASSES:
</span><span class="hit">            name = objecttools.instancename(seqclass)
</span><span class="hit">            yield name, getattr(self, name)
</span><span class="noop">
</span><span class="hit">    def __getitem__(self, key):
</span><span class="miss">        return self.__dict__[key]
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        lines = []
</span><span class="hit">        if pub.options.reprcomments:
</span><span class="miss">            lines.append(&#39;#%s object defined in module %s.&#39;
</span><span class="noop">                         % (objecttools.classname(self),
</span><span class="noop">                            objecttools.modulename(self)))
</span><span class="miss">            lines.append(&#39;#The implemented sequences with their actual &#39;
</span><span class="noop">                         &#39;values are:&#39;)
</span><span class="hit">        for (name, sequence) in self:
</span><span class="hit">            try:
</span><span class="hit">                lines.append(&#39;%s&#39; % repr(sequence))
</span><span class="miss">            except BaseException:
</span><span class="miss">                lines.append(&#39;%s(?)&#39; % name)
</span><span class="hit">        return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class IOSubSequences(SubSequences):
</span><span class="hit">    _SEQCLASSES = ()
</span><span class="noop">
</span><span class="hit">    def openfiles(self, idx=0):
</span><span class="hit">        self.fastaccess.openfiles(idx)
</span><span class="noop">
</span><span class="hit">    def closefiles(self):
</span><span class="hit">        self.fastaccess.closefiles()
</span><span class="noop">
</span><span class="hit">    def activate_ram(self):
</span><span class="hit">        for (name, seq) in self:
</span><span class="hit">            seq.activate_ram()
</span><span class="noop">
</span><span class="hit">    def deactivate_ram(self):
</span><span class="miss">        for (name, seq) in self:
</span><span class="miss">            seq.deactivate_ram()
</span><span class="noop">
</span><span class="hit">    def activate_disk(self):
</span><span class="miss">        for (name, seq) in self:
</span><span class="miss">            seq.activate_disk()
</span><span class="noop">
</span><span class="hit">    def deactivate_disk(self):
</span><span class="miss">        for (name, seq) in self:
</span><span class="miss">            seq.deactivate_disk()
</span><span class="noop">
</span><span class="hit">    def ram2disk(self):
</span><span class="miss">        for (name, seq) in self:
</span><span class="miss">            seq.ram2disk()
</span><span class="noop">
</span><span class="hit">    def disk2ram(self):
</span><span class="miss">        for (name, seq) in self:
</span><span class="miss">            seq.disk2ram()
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class InputSequences(IOSubSequences):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling input sequences.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = ()
</span><span class="noop">
</span><span class="hit">    def loaddata(self, idx):
</span><span class="hit">        self.fastaccess.loaddata(idx)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FluxSequences(IOSubSequences):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling flux sequences.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = ()
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def getname(cls):
</span><span class="hit">        return &#39;fluxes&#39;
</span><span class="noop">
</span><span class="hit">    def savedata(self, idx):
</span><span class="hit">        self.fastaccess.savedata(idx)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class StateSequences(IOSubSequences):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling state sequences.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = ()
</span><span class="noop">
</span><span class="hit">    def _initfastaccess(self, cls_fastaccess, cymodel):
</span><span class="hit">        SubSequences._initfastaccess(self, cls_fastaccess, cymodel)
</span><span class="hit">        self.fastaccess_new = self.fastaccess
</span><span class="hit">        if cls_fastaccess is None:
</span><span class="hit">            self.fastaccess_old = FastAccess()
</span><span class="noop">        else:
</span><span class="hit">            setattr(cymodel, &#39;new_states&#39;, self.fastaccess)
</span><span class="hit">            self.fastaccess_old = cls_fastaccess()
</span><span class="hit">            setattr(cymodel, &#39;old_states&#39;, self.fastaccess_old)
</span><span class="noop">
</span><span class="hit">    def new2old(self):
</span><span class="noop">        &#34;&#34;&#34;Assign the new/final state values of the actual time step to the
</span><span class="noop">        new/initial state values of the next time step.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        for (name, seq) in self:
</span><span class="hit">            seq.new2old()
</span><span class="noop">
</span><span class="hit">    def savedata(self, idx):
</span><span class="hit">        self.fastaccess.savedata(idx)
</span><span class="noop">
</span><span class="hit">    def reset(self):
</span><span class="miss">        for (name, seq) in self:
</span><span class="miss">            seq.reset()
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class LogSequences(SubSequences):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling log sequences.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = ()
</span><span class="noop">
</span><span class="hit">    def reset(self):
</span><span class="miss">        for (name, seq) in self:
</span><span class="miss">            seq.reset()
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class AideSequences(SubSequences):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling aide sequences.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = ()
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class LinkSequences(SubSequences):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling link sequences.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = ()
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Sequence(objecttools.ValueMath):
</span><span class="noop">    &#34;&#34;&#34;Only for inheritance.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        self.subseqs = None
</span><span class="hit">        self.fastaccess = None
</span><span class="noop">
</span><span class="hit">    def connect(self, subseqs):
</span><span class="hit">        self.subseqs = subseqs
</span><span class="hit">        self.fastaccess = subseqs.fastaccess
</span><span class="hit">        setattr(self.fastaccess, &#39;_%s_ndim&#39; % self.name, self.NDIM)
</span><span class="hit">        setattr(self.fastaccess, &#39;_%s_length&#39; % self.name, 0)
</span><span class="hit">        for idx in range(self.NDIM):
</span><span class="hit">            setattr(self.fastaccess, &#39;_%s_length_%d&#39; % (self.name, idx), 0)
</span><span class="hit">        self.diskflag = False
</span><span class="hit">        self.ramflag = False
</span><span class="hit">        try:
</span><span class="hit">            setattr(self.fastaccess, &#39;_%s_file&#39; % self.name, &#39;&#39;)
</span><span class="hit">        except AttributeError:
</span><span class="hit">            pass
</span><span class="hit">        self._initvalues()
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args):
</span><span class="noop">        &#34;&#34;&#34;The prefered way to pass values to :class:`Sequence` instances
</span><span class="noop">        within initial condition files.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        self.values = args
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def initvalue(self):
</span><span class="hit">        if pub.options.usedefaultvalues:
</span><span class="miss">            initvalue = getattr(self, &#39;INIT&#39;, None)
</span><span class="miss">            if initvalue is None:
</span><span class="miss">                initvalue = 0.
</span><span class="noop">        else:
</span><span class="hit">            initvalue = numpy.nan
</span><span class="hit">        return initvalue
</span><span class="noop">
</span><span class="hit">    def _initvalues(self):
</span><span class="noop">
</span><span class="hit">        if self.NDIM == 0:
</span><span class="hit">            setattr(self.fastaccess, self.name, self.initvalue)
</span><span class="noop">        else:
</span><span class="hit">            setattr(self.fastaccess, self.name, None)
</span><span class="noop">
</span><span class="hit">    def _getname(self):
</span><span class="noop">        &#34;&#34;&#34;Name of the sequence, which is the name if the instantiating
</span><span class="noop">        subclass of :class:`Sequence` in lower case letters.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return objecttools.classname(self).lower()
</span><span class="hit">    name = property(_getname)
</span><span class="noop">
</span><span class="hit">    def _getvalue(self):
</span><span class="noop">        &#34;&#34;&#34;The actual time series value(s) handled by the respective
</span><span class="noop">        :class:`Sequence` instance.  For consistency, `value` and `values`
</span><span class="noop">        can always be used interchangeably.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        value = getattr(self.fastaccess, self.name, None)
</span><span class="hit">        if value is None:
</span><span class="miss">            raise RuntimeError(&#39;No value/values of sequence %s of element &#39;
</span><span class="noop">                               &#39;%s has/have been defined so far.&#39;
</span><span class="noop">                               % (self.name, objecttools.devicename(self)))
</span><span class="noop">        else:
</span><span class="hit">            if self.NDIM:
</span><span class="hit">                value = numpy.asarray(value)
</span><span class="hit">            return value
</span><span class="noop">
</span><span class="hit">    def _setvalue(self, value):
</span><span class="hit">        if self.NDIM == 0:
</span><span class="hit">            try:
</span><span class="hit">                temp = value[0]
</span><span class="hit">                if len(value) &gt; 1:
</span><span class="miss">                    raise ValueError(&#39;%d values are assigned to the scalar &#39;
</span><span class="noop">                                     &#39;sequence %s of element %s, which is &#39;
</span><span class="noop">                                     &#39;ambiguous.&#39;
</span><span class="noop">                                     % (len(value),
</span><span class="noop">                                        objecttools.devicename(self),
</span><span class="noop">                                        self.name))
</span><span class="hit">                value = temp
</span><span class="hit">            except (TypeError, IndexError):
</span><span class="hit">                pass
</span><span class="hit">            try:
</span><span class="hit">                value = float(value)
</span><span class="miss">            except (ValueError, TypeError):
</span><span class="miss">                raise TypeError(&#39;When trying to set the value of sequence &#39;
</span><span class="noop">                                &#39;%s of element %s, it was not possible to &#39;
</span><span class="noop">                                &#39;convert value `%s` to float .&#39;
</span><span class="noop">                                % (self.name, objecttools.devicename(self),
</span><span class="noop">                                   value))
</span><span class="noop">        else:
</span><span class="hit">            try:
</span><span class="hit">                value = value.value
</span><span class="hit">            except AttributeError:
</span><span class="hit">                pass
</span><span class="hit">            try:
</span><span class="hit">                value = numpy.full(self.shape, value, dtype=float)
</span><span class="miss">            except ValueError:
</span><span class="miss">                raise ValueError(&#39;For sequence %s of element %s setting new &#39;
</span><span class="noop">                                 &#39;values failed.  The values `%s` cannot be &#39;
</span><span class="noop">                                 &#39;converted to a numpy ndarray with shape %s &#39;
</span><span class="noop">                                 &#39;containing entries of type float.&#39;
</span><span class="noop">                                 % (self.name, objecttools.devicename(self),
</span><span class="noop">                                    value, self.shape))
</span><span class="hit">        setattr(self.fastaccess, self.name, value)
</span><span class="noop">
</span><span class="hit">    value = property(_getvalue, _setvalue)
</span><span class="hit">    values = value
</span><span class="noop">
</span><span class="hit">    def _getshape(self):
</span><span class="noop">        &#34;&#34;&#34;A tuple containing the lengths in all dimensions of the sequence
</span><span class="noop">        values at a specific time point.  Note that setting a new shape
</span><span class="noop">        results in a loss of the actual values of the respective sequence.
</span><span class="noop">        For 0-dimensional sequences :attr:`shape` is always an empty tuple.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if self.NDIM:
</span><span class="hit">            try:
</span><span class="hit">                return self.values.shape
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise RuntimeError(&#39;Shape information for sequence %s of &#39;
</span><span class="noop">                                   &#39;element %s can only be retrieved after &#39;
</span><span class="noop">                                   &#39;it has been defined.&#39;
</span><span class="noop">                                   % (self.name,
</span><span class="noop">                                      objecttools.devicename(self)))
</span><span class="noop">        else:
</span><span class="hit">            return ()
</span><span class="noop">
</span><span class="hit">    def _setshape(self, shape):
</span><span class="hit">        if self.NDIM:
</span><span class="hit">            try:
</span><span class="hit">                array = numpy.full(shape, self.initvalue, dtype=float)
</span><span class="miss">            except Exception:
</span><span class="miss">                prefix = (&#39;While trying create a new numpy ndarray` for &#39;
</span><span class="noop">                          &#39;sequence %s of element %s&#39;
</span><span class="noop">                          % (self.name, objecttools.devicename(self)))
</span><span class="miss">                objecttools.augmentexcmessage(prefix)
</span><span class="hit">            if array.ndim == self.NDIM:
</span><span class="hit">                setattr(self.fastaccess, self.name, array)
</span><span class="noop">            else:
</span><span class="miss">                raise ValueError(&#39;Sequence %s of element %s is %d-dimensional &#39;
</span><span class="noop">                                 &#39;but the given shape indicates %d dimensions.&#39;
</span><span class="noop">                                 % (self.name, objecttools.devicename(self),
</span><span class="noop">                                    self.NDIM, array.ndim))
</span><span class="noop">        else:
</span><span class="miss">            if shape:
</span><span class="miss">                raise ValueError(&#39;The shape information of 0-dimensional &#39;
</span><span class="noop">                                 &#39;sequences as %s of element %s can only be &#39;
</span><span class="noop">                                 &#39;`()`, but `%s` is given.&#39;
</span><span class="noop">                                 % (self.name, objecttools.devicename(self),
</span><span class="noop">                                    shape))
</span><span class="noop">            else:
</span><span class="miss">                self.value = 0.
</span><span class="noop">
</span><span class="hit">    shape = property(_getshape, _setshape)
</span><span class="noop">
</span><span class="hit">    def __getitem__(self, key):
</span><span class="hit">        try:
</span><span class="hit">            return self.values[key]
</span><span class="hit">        except Exception:
</span><span class="hit">            self._raiseitemexception()
</span><span class="noop">
</span><span class="hit">    def __setitem__(self, key, values):
</span><span class="hit">        try:
</span><span class="hit">            self.values[key] = values
</span><span class="miss">        except Exception:
</span><span class="miss">            self._raiseitemexception()
</span><span class="noop">
</span><span class="hit">    def _raiseitemexception(self):
</span><span class="hit">        if self.values is None:
</span><span class="miss">            raise RuntimeError(&#39;Sequence `%s` has no values so far.&#39;
</span><span class="noop">                               % self.name)
</span><span class="noop">        else:
</span><span class="hit">            objecttools.augmentexcmessage(&#39;While trying to item access the &#39;
</span><span class="noop">                                          &#39;values of sequence `%s`&#39;
</span><span class="noop">                                          % self.name)
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        if self.NDIM == 0:
</span><span class="hit">            return &#39;%s(%s)&#39; % (self.name, objecttools.repr_(self.value))
</span><span class="hit">        elif self.NDIM == 1:
</span><span class="hit">            lines = []
</span><span class="hit">            cols = &#39;, &#39;.join(objecttools.repr_(value) for value in self.values)
</span><span class="hit">            wrappedlines = textwrap.wrap(cols, 80-len(self.name)-2)
</span><span class="hit">            for (idx, line) in enumerate(wrappedlines):
</span><span class="hit">                if not idx:
</span><span class="hit">                    lines.append(&#39;%s(%s&#39; % (self.name, line))
</span><span class="noop">                else:
</span><span class="miss">                    lines.append((len(self.name)+1)*&#39; &#39; + line)
</span><span class="hit">            lines[-1] += &#39;)&#39;
</span><span class="hit">            return &#39;\n&#39;.join(lines)
</span><span class="miss">        elif self.NDIM == 2:
</span><span class="miss">            lines = []
</span><span class="miss">            skip = (1+len(self.name)) * &#39; &#39;
</span><span class="miss">            for (idx, row) in enumerate(self.values):
</span><span class="miss">                cols = &#39;, &#39;.join(objecttools.repr_(value) for value in row)
</span><span class="miss">                if not idx:
</span><span class="miss">                    lines.append(&#39;%s(%s,&#39; % (self.name, cols))
</span><span class="noop">                else:
</span><span class="miss">                    lines.append(&#39;%s%s,&#39; % (skip, cols))
</span><span class="miss">            lines[-1] = lines[-1][:-1] + &#39;)&#39;
</span><span class="miss">            return &#39;\n&#39;.join(lines)
</span><span class="noop">        else:
</span><span class="miss">            raise NotImplementedError(&#39;`repr` does not yet support &#39;
</span><span class="noop">                                      &#39;sequences, which handle %d-&#39;
</span><span class="noop">                                      &#39;dimensional matrices.&#39; % self.NDIM)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class IOSequence(Sequence):
</span><span class="noop">    &#34;&#34;&#34;Only for inheritance.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        Sequence.__init__(self)
</span><span class="hit">        self._rawfilename = None
</span><span class="hit">        self._filetype_ext = None
</span><span class="hit">        self._filename_ext = None
</span><span class="hit">        self._dirpath_ext = None
</span><span class="hit">        self._dirpath_int = None
</span><span class="hit">        self._filepath_ext = None
</span><span class="hit">        self._filepath_int = None
</span><span class="noop">
</span><span class="hit">    def _getfiletype_ext(self):
</span><span class="noop">        &#34;&#34;&#34;Ending of the external data file.&#34;&#34;&#34;
</span><span class="miss">        if self._filetype_ext:
</span><span class="miss">            return self._filetype_ext
</span><span class="noop">        else:
</span><span class="miss">            try:
</span><span class="miss">                if isinstance(self, InputSequence):
</span><span class="miss">                    return pub.sequencemanager.inputfiletype
</span><span class="miss">                elif isinstance(self, NodeSequence):
</span><span class="miss">                    return pub.sequencemanager.nodefiletype
</span><span class="noop">                else:
</span><span class="miss">                    return pub.sequencemanager.outputfiletype
</span><span class="noop">
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise RuntimeError(&#39;For sequence %s of element %s the type &#39;
</span><span class="noop">                                   &#39;of the external data file cannot be &#39;
</span><span class="noop">                                   &#39;determined.  Either set it manually or &#39;
</span><span class="noop">                                   &#39;embed the sequence object into the HydPy &#39;
</span><span class="noop">                                   &#39;framework in the common manner to allow &#39;
</span><span class="noop">                                   &#39;for an automatic determination.&#39;
</span><span class="noop">                                   % (self.name,
</span><span class="noop">                                      objecttools.devicename(self)))
</span><span class="noop">
</span><span class="hit">    def _setfiletype_ext(self, name):
</span><span class="miss">        self._filetype_ext = name
</span><span class="noop">
</span><span class="hit">    def _delfiletype_ext(self, name):
</span><span class="miss">        self._filetype_ext = None
</span><span class="noop">
</span><span class="hit">    filetype_ext = property(_getfiletype_ext, _setfiletype_ext,
</span><span class="noop">                            _delfiletype_ext)
</span><span class="noop">
</span><span class="hit">    def _getfilename_ext(self):
</span><span class="noop">        &#34;&#34;&#34;Complete filename of the external data file.&#34;&#34;&#34;
</span><span class="miss">        if self._filename_ext:
</span><span class="miss">            return self._filename_ext
</span><span class="noop">        else:
</span><span class="miss">            return &#39;.&#39;.join((self.rawfilename, self.filetype_ext))
</span><span class="noop">
</span><span class="hit">    def _setfilename_ext(self, name):
</span><span class="miss">        self._filename_ext = name
</span><span class="noop">
</span><span class="hit">    def _delfilename_ext(self):
</span><span class="miss">        self._filename_ext = None
</span><span class="noop">
</span><span class="hit">    filename_ext = property(_getfilename_ext, _setfilename_ext,
</span><span class="noop">                            _delfilename_ext)
</span><span class="noop">
</span><span class="hit">    def _getfilename_int(self):
</span><span class="noop">        &#34;&#34;&#34;Complete filename of the internal data file.&#34;&#34;&#34;
</span><span class="miss">        return self.rawfilename + &#39;.bin&#39;
</span><span class="noop">
</span><span class="hit">    filename_int = property(_getfilename_int)
</span><span class="noop">
</span><span class="hit">    def _getdirpath_ext(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path of the directory of the external data file.&#34;&#34;&#34;
</span><span class="miss">        if self._dirpath_ext:
</span><span class="miss">            return self._dirpath_ext
</span><span class="noop">        else:
</span><span class="miss">            try:
</span><span class="miss">                if isinstance(self, InputSequence):
</span><span class="miss">                    return pub.sequencemanager.inputpath
</span><span class="miss">                elif isinstance(self, NodeSequence):
</span><span class="miss">                    return pub.sequencemanager.nodepath
</span><span class="noop">                else:
</span><span class="miss">                    return pub.sequencemanager.outputpath
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise RuntimeError(&#39;For sequence `%s` the directory of &#39;
</span><span class="noop">                                   &#39;the external data file cannot be &#39;
</span><span class="noop">                                   &#39;determined.  Either set it manually or &#39;
</span><span class="noop">                                   &#39;embed the sequence object into the HydPy &#39;
</span><span class="noop">                                   &#39;framework in the common manner to allow &#39;
</span><span class="noop">                                   &#39;for an automatic determination.&#39;
</span><span class="noop">                                   % self.name)
</span><span class="noop">
</span><span class="hit">    def _setdirpath_ext(self, name):
</span><span class="miss">        self._dirpath_ext = name
</span><span class="noop">
</span><span class="hit">    def _deldirpath_ext(self, name):
</span><span class="miss">        self._dirpath_ext = None
</span><span class="noop">
</span><span class="hit">    dirpath_ext = property(_getdirpath_ext, _setdirpath_ext, _deldirpath_ext)
</span><span class="noop">
</span><span class="hit">    def _getdirpath_int(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path of the directory of the internal data file.&#34;&#34;&#34;
</span><span class="miss">        if self._dirpath_int:
</span><span class="miss">            return self._dirpath_int
</span><span class="noop">        else:
</span><span class="miss">            try:
</span><span class="miss">                return pub.sequencemanager.temppath
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise RuntimeError(&#39;For sequence `%s` the directory of &#39;
</span><span class="noop">                                   &#39;the internal data file cannot be &#39;
</span><span class="noop">                                   &#39;determined.  Either set it manually or &#39;
</span><span class="noop">                                   &#39;embed the sequence object into the HydPy &#39;
</span><span class="noop">                                   &#39;framework in the common manner to allow &#39;
</span><span class="noop">                                   &#39;for an automatic determination.&#39;
</span><span class="noop">                                   % self.name)
</span><span class="noop">
</span><span class="hit">    def _setdirpath_int(self, name):
</span><span class="miss">        self._dirpath_int = name
</span><span class="noop">
</span><span class="hit">    def _deldirpath_int(self, name):
</span><span class="miss">        self._dirpath_int = None
</span><span class="hit">    dirpath_int = property(_getdirpath_int, _setdirpath_int, _deldirpath_int)
</span><span class="noop">
</span><span class="hit">    def _getfilepath_ext(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path to the external data file.&#34;&#34;&#34;
</span><span class="miss">        if self._filepath_ext:
</span><span class="miss">            return self._filepath_ext
</span><span class="noop">        else:
</span><span class="miss">            return os.path.join(self.dirpath_ext, self.filename_ext)
</span><span class="noop">
</span><span class="hit">    def _setfilepath_ext(self, name):
</span><span class="miss">        self._filepath_ext = name
</span><span class="noop">
</span><span class="hit">    def _delfilepath_ext(self):
</span><span class="miss">        self._filepath_ext = None
</span><span class="hit">    filepath_ext = property(_getfilepath_ext, _setfilepath_ext,
</span><span class="noop">                            _delfilepath_ext)
</span><span class="noop">
</span><span class="hit">    def _getfilepath_int(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path to the internal data file.&#34;&#34;&#34;
</span><span class="miss">        if self._filepath_int:
</span><span class="miss">            return self._filepath_int
</span><span class="noop">        else:
</span><span class="miss">            return os.path.join(self.dirpath_int, self.filename_int)
</span><span class="noop">
</span><span class="hit">    def _setfilepath_int(self, name):
</span><span class="miss">        self._filepath_int = name
</span><span class="noop">
</span><span class="hit">    def _delfilepath_int(self):
</span><span class="miss">        self._filepath_int = None
</span><span class="noop">
</span><span class="hit">    filepath_int = property(_getfilepath_int, _setfilepath_int,
</span><span class="noop">                            _delfilepath_int)
</span><span class="noop">
</span><span class="hit">    def update_fastaccess(self):
</span><span class="noop">        &#34;&#34;&#34;&#34;&#34;&#34;
</span><span class="hit">        if self.diskflag:
</span><span class="miss">            path = self.filepath_int
</span><span class="noop">        else:
</span><span class="hit">            path = None
</span><span class="hit">        setattr(self.fastaccess, &#39;_%s_path&#39; % self.name, path)
</span><span class="hit">        length = 1
</span><span class="hit">        for idx in range(self.NDIM):
</span><span class="hit">            length *= self.shape[idx]
</span><span class="hit">            setattr(self.fastaccess, &#39;_%s_length_%d&#39; % (self.name, idx),
</span><span class="noop">                    self.shape[idx])
</span><span class="hit">        setattr(self.fastaccess, &#39;_%s_length&#39; % self.name, length)
</span><span class="noop">
</span><span class="hit">    def _getdiskflag(self):
</span><span class="hit">        diskflag = getattr(self.fastaccess, &#39;_%s_diskflag&#39; % self.name, None)
</span><span class="hit">        if diskflag is not None:
</span><span class="hit">            return diskflag
</span><span class="noop">        else:
</span><span class="miss">            raise RuntimeError(&#39;The `diskflag` of sequence `%s` has &#39;
</span><span class="noop">                               &#39;not been set yet.&#39; % self.name)
</span><span class="noop">
</span><span class="hit">    def _setdiskflag(self, value):
</span><span class="hit">        setattr(self.fastaccess, &#39;_%s_diskflag&#39; % self.name,  bool(value))
</span><span class="noop">
</span><span class="hit">    diskflag = property(_getdiskflag, _setdiskflag)
</span><span class="noop">
</span><span class="hit">    def _getramflag(self):
</span><span class="hit">        ramflag = getattr(self.fastaccess, &#39;_%s_ramflag&#39; % self.name, None)
</span><span class="hit">        if ramflag is not None:
</span><span class="hit">            return ramflag
</span><span class="noop">        else:
</span><span class="miss">            raise RuntimeError(&#39;The `ramflag` of sequence `%s` has &#39;
</span><span class="noop">                               &#39;not been set yet.&#39; % self.name)
</span><span class="noop">
</span><span class="hit">    def _setramflag(self, value):
</span><span class="hit">        setattr(self.fastaccess, &#39;_%s_ramflag&#39; % self.name,  bool(value))
</span><span class="noop">
</span><span class="hit">    ramflag = property(_getramflag, _setramflag)
</span><span class="noop">
</span><span class="hit">    def _getmemoryflag(self):
</span><span class="miss">        return self.ramflag or self.diskflag
</span><span class="noop">
</span><span class="hit">    memoryflag = property(_getmemoryflag)
</span><span class="noop">
</span><span class="hit">    def _getarray(self):
</span><span class="hit">        array = getattr(self.fastaccess, &#39;_%s_array&#39; % self.name, None)
</span><span class="hit">        if array is not None:
</span><span class="hit">            return numpy.asarray(array)
</span><span class="noop">        else:
</span><span class="miss">            raise RuntimeError(&#39;The `ram array` of sequence `%s` has &#39;
</span><span class="noop">                               &#39;not been set yet.&#39; % self.name)
</span><span class="noop">
</span><span class="hit">    def _setarray(self, values):
</span><span class="hit">        values = numpy.array(values, dtype=float)
</span><span class="hit">        setattr(self.fastaccess, &#39;_%s_array&#39; % self.name,  values)
</span><span class="noop">
</span><span class="hit">    def _getseriesshape(self):
</span><span class="noop">        &#34;&#34;&#34;Shape of the whole time series (time beeing the first dimension).&#34;&#34;&#34;
</span><span class="hit">        seriesshape = [len(pub.timegrids.init)]
</span><span class="hit">        seriesshape.extend(self.shape)
</span><span class="hit">        return tuple(seriesshape)
</span><span class="noop">
</span><span class="hit">    seriesshape = property(_getseriesshape)
</span><span class="noop">
</span><span class="hit">    def _getseries(self):
</span><span class="hit">        if self.diskflag:
</span><span class="miss">            return self._load_int()
</span><span class="hit">        elif self.ramflag:
</span><span class="hit">            return self._getarray()
</span><span class="noop">        else:
</span><span class="miss">            raise RuntimeError(
</span><span class="noop">                &#39;Sequence `%s` of device `%s`is not requested &#39;
</span><span class="noop">                &#39;to make any internal data available to the user.&#39;
</span><span class="noop">                % (self.name, objecttools.devicename(self)))
</span><span class="noop">
</span><span class="hit">    def _setseries(self, values):
</span><span class="hit">        series = self.series
</span><span class="hit">        series[:] = values
</span><span class="hit">        if self.diskflag:
</span><span class="miss">            self._save_int(series)
</span><span class="hit">        elif self.ramflag:
</span><span class="hit">            self._setarray(series)
</span><span class="noop">        else:
</span><span class="miss">            raise RuntimeError(&#39;Sequence `%s` is not requested to make any &#39;
</span><span class="noop">                               &#39;internal data available to the user.&#39;
</span><span class="noop">                               % self.name)
</span><span class="noop">
</span><span class="hit">    def _delseries(self):
</span><span class="miss">        if self.diskflag:
</span><span class="miss">            os.remove(self.filepath_int)
</span><span class="miss">        elif self.ramflag:
</span><span class="miss">            setattr(self.fastaccess, &#39;_%s_array&#39; % self.name, None)
</span><span class="noop">
</span><span class="hit">    series = property(_getseries, _setseries, _delseries)
</span><span class="noop">
</span><span class="hit">    def load_ext(self):
</span><span class="noop">        &#34;&#34;&#34;Load the external data series in accordance with
</span><span class="noop">        :attr:`~IOSequence.timegrid_init` and store it as internal data.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        if self.filetype_ext == &#39;npy&#39;:
</span><span class="miss">            timegrid_data, values = self._load_npy()
</span><span class="noop">        else:
</span><span class="miss">            timegrid_data, values = self._load_asc()
</span><span class="miss">        if self.shape != values.shape[1:]:
</span><span class="miss">            raise RuntimeError(
</span><span class="noop">                &#39;The shape of sequence `%s` of element `%s` is `%s`, but &#39;
</span><span class="noop">                &#39;according to the external data file `%s` it should be `%s`.&#39;
</span><span class="noop">                % (self.name, objecttools.devicename(self), self.shape,
</span><span class="noop">                   self.filepath_ext, values.shape[1:]))
</span><span class="miss">        idx1 = timegrid_data[pub.timegrids.init.firstdate]
</span><span class="miss">        idx2 = timegrid_data[pub.timegrids.init.lastdate]
</span><span class="miss">        if pub.timegrids.init.stepsize != timegrid_data.stepsize:
</span><span class="miss">            raise RuntimeError(
</span><span class="noop">                &#39;According to external data file `%s`, the date time step &#39;
</span><span class="noop">                &#39;of sequence `%s` of element `%s` is `%s`, but the actual &#39;
</span><span class="noop">                &#39;simulation time step is `%s`.&#39;
</span><span class="noop">                % (self.filepath_ext, self.name, objecttools.devicename(self),
</span><span class="noop">                   timegrid_data.stepsize, pub.timegrids.init.stepsize))
</span><span class="miss">        elif pub.timegrids.init not in timegrid_data:
</span><span class="miss">            if pub.options.checkseries:
</span><span class="miss">                raise RuntimeError(
</span><span class="noop">                    &#39;For sequence `%s` of element `%s` the initialization &#39;
</span><span class="noop">                    &#39;time grid (%s) does not define a subset of the time &#39;
</span><span class="noop">                    &#39;grid of the external data file %s (%s).&#39;
</span><span class="noop">                    % (self.name, objecttools.devicename(self),
</span><span class="noop">                       pub.timegrids.init, self.filepath_ext, timegrid_data))
</span><span class="noop">            else:
</span><span class="miss">                valcopy = values
</span><span class="miss">                shape = list(values.shape)
</span><span class="miss">                shape[0] = len(pub.timegrids.init)
</span><span class="miss">                values = numpy.zeros(shape)
</span><span class="miss">                valcopy = valcopy[max(idx1, 0):min(idx2, len(valcopy))]
</span><span class="miss">                idx1 = max(-idx1, 0)
</span><span class="miss">                idx2 = idx1+len(valcopy)
</span><span class="miss">                values[idx1:idx2] = valcopy
</span><span class="noop">        else:
</span><span class="miss">            values = values[idx1:idx2]
</span><span class="miss">        if self.diskflag:
</span><span class="miss">            self._save_int(values)
</span><span class="miss">        elif self.ramflag:
</span><span class="miss">            self._setarray(values)
</span><span class="noop">        else:
</span><span class="miss">            raise RuntimeError(
</span><span class="noop">                &#39;Sequence `%s` of element `%s`is not requested to make &#39;
</span><span class="noop">                &#39;any internal data available the the user.&#39;
</span><span class="noop">                % (self.name, objecttools.devicename(self)))
</span><span class="noop">
</span><span class="hit">    def save_ext(self):
</span><span class="noop">        &#34;&#34;&#34;Write the internal data into an external data file.&#34;&#34;&#34;
</span><span class="miss">        if self.filetype_ext == &#39;npy&#39;:
</span><span class="miss">            values = pub.timegrids.init.toarray()
</span><span class="miss">            for idx in range(self.NDIM):
</span><span class="miss">                values = numpy.expand_dims(values, idx+1)
</span><span class="miss">            values = values + numpy.zeros(self.shape)
</span><span class="miss">            values = numpy.concatenate((values, self.series))
</span><span class="miss">            numpy.save(self.filepath_ext, values)
</span><span class="noop">        else:
</span><span class="miss">            with open(self.filepath_ext, &#39;w&#39;) as file_:
</span><span class="miss">                file_.write(repr(pub.timegrids.init) + &#39;\n&#39;)
</span><span class="miss">                numpy.savetxt(file_, self.series, delimiter=&#39;\t&#39;)
</span><span class="noop">
</span><span class="hit">    def _load_npy(self):
</span><span class="noop">        &#34;&#34;&#34;Return the data timegrid and the complete external data from a
</span><span class="noop">        binary numpy file.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        try:
</span><span class="miss">            data = numpy.load(self.filepath_ext)
</span><span class="miss">        except BaseException:
</span><span class="miss">            prefix = (&#39;While trying to load the external data of sequence &#39;
</span><span class="noop">                      &#39;`%s` from file `%s`&#39; % (self.name, self.filepath_ext))
</span><span class="miss">            objecttools.augmentexcmessage(prefix)
</span><span class="miss">        try:
</span><span class="miss">            timegrid_data = timetools.Timegrid.fromarray(data)
</span><span class="miss">        except BaseException:
</span><span class="miss">            prefix = (&#39;While trying to retrieve the data timegrid of the &#39;
</span><span class="noop">                      &#39;external data file `%s` of sequence `%s`&#39;
</span><span class="noop">                      % (self.filepath_ext, self.name))
</span><span class="miss">            objecttools.augmentexcmessage(prefix)
</span><span class="miss">        return timegrid_data, data[13:]
</span><span class="noop">
</span><span class="hit">    def _load_asc(self):
</span><span class="miss">        with open(self.filepath_ext) as file_:
</span><span class="miss">            header = &#39;\n&#39;.join([file_.readline() for idx in range(3)])
</span><span class="miss">        timegrid_data = eval(header, {}, {&#39;Timegrid&#39;: timetools.Timegrid})
</span><span class="miss">        values = numpy.loadtxt(self.filepath_ext, skiprows=3,
</span><span class="noop">                               ndmin=self.NDIM+1)
</span><span class="miss">        return timegrid_data, values
</span><span class="noop">
</span><span class="hit">    def _load_int(self):
</span><span class="noop">        &#34;&#34;&#34;Load internal data from file and return it.&#34;&#34;&#34;
</span><span class="miss">        values = numpy.fromfile(self.filepath_int)
</span><span class="miss">        if self.NDIM &gt; 0:
</span><span class="miss">            values = values.reshape(self.seriesshape)
</span><span class="miss">        return values
</span><span class="noop">
</span><span class="hit">    def zero_int(self):
</span><span class="noop">        &#34;&#34;&#34;Initialize the internal data series with zero values.&#34;&#34;&#34;
</span><span class="hit">        values = numpy.zeros(self.seriesshape)
</span><span class="hit">        if self.diskflag:
</span><span class="miss">            self._save_int(values)
</span><span class="hit">        elif self.ramflag:
</span><span class="hit">            self._setarray(values)
</span><span class="noop">        else:
</span><span class="miss">            raise RuntimeError(&#39;Sequence `%s` is not requested to make any &#39;
</span><span class="noop">                               &#39;internal data available to the user.&#39;
</span><span class="noop">                               % self.name)
</span><span class="noop">
</span><span class="hit">    def _save_int(self, values):
</span><span class="miss">        values.tofile(self.filepath_int)
</span><span class="noop">
</span><span class="hit">    def activate_disk(self):
</span><span class="noop">        &#34;&#34;&#34;Demand reading/writing internal data from/to hard disk.&#34;&#34;&#34;
</span><span class="miss">        self.deactivate_ram()
</span><span class="miss">        self.diskflag = True
</span><span class="miss">        if (isinstance(self, InputSequence) or
</span><span class="noop">           (isinstance(self, NodeSequence) and self.use_ext)):
</span><span class="miss">            self.load_ext()
</span><span class="noop">        else:
</span><span class="miss">            self.zero_int()
</span><span class="miss">        self.update_fastaccess()
</span><span class="noop">
</span><span class="hit">    def deactivate_disk(self):
</span><span class="noop">        &#34;&#34;&#34;Prevent from reading/writing internal data from/to hard disk.&#34;&#34;&#34;
</span><span class="hit">        if self.diskflag:
</span><span class="miss">            del self.series
</span><span class="miss">            self.diskflag = False
</span><span class="noop">
</span><span class="hit">    def activate_ram(self):
</span><span class="noop">        &#34;&#34;&#34;Demand reading/writing internal data from/to hard disk.&#34;&#34;&#34;
</span><span class="hit">        self.deactivate_disk()
</span><span class="hit">        self.ramflag = True
</span><span class="hit">        if (isinstance(self, InputSequence) or
</span><span class="noop">                (isinstance(self, NodeSequence) and self.use_ext)):
</span><span class="miss">            self.load_ext()
</span><span class="noop">        else:
</span><span class="hit">            self.zero_int()
</span><span class="hit">        self.update_fastaccess()
</span><span class="noop">
</span><span class="hit">    def deactivate_ram(self):
</span><span class="noop">        &#34;&#34;&#34;Prevent from reading/writing internal data from/to hard disk.&#34;&#34;&#34;
</span><span class="miss">        if self.ramflag:
</span><span class="miss">            del self.series
</span><span class="miss">            self.ramflag = False
</span><span class="noop">
</span><span class="hit">    def disk2ram(self):
</span><span class="noop">        &#34;&#34;&#34;Move internal data from disk to RAM.&#34;&#34;&#34;
</span><span class="miss">        values = self.series
</span><span class="miss">        self.deactivate_disk()
</span><span class="miss">        self.ramflag = True
</span><span class="miss">        self._setarray(values)
</span><span class="miss">        self.update_fastaccess()
</span><span class="noop">
</span><span class="hit">    def ram2disk(self):
</span><span class="noop">        &#34;&#34;&#34;Move internal data from RAM to disk.&#34;&#34;&#34;
</span><span class="miss">        values = self.series
</span><span class="miss">        self.deactivate_ram()
</span><span class="miss">        self.diskflag = True
</span><span class="miss">        self._save_int(values)
</span><span class="miss">        self.update_fastaccess()
</span><span class="noop">
</span><span class="hit">    def _setshape(self, shape):
</span><span class="hit">        Sequence._setshape(self, shape)
</span><span class="hit">        self.update_fastaccess()
</span><span class="noop">
</span><span class="hit">    shape = property(Sequence._getshape, _setshape)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ModelIOSequence(IOSequence):
</span><span class="noop">
</span><span class="hit">    def _getrawfilename(self):
</span><span class="noop">        &#34;&#34;&#34;Filename without ending for external and internal date files.&#34;&#34;&#34;
</span><span class="miss">        if self._rawfilename:
</span><span class="miss">            return self._rawfilename
</span><span class="noop">        else:
</span><span class="miss">            try:
</span><span class="miss">                return &#39;%s_%s_%s&#39; % (
</span><span class="noop">                       self.subseqs.seqs.model.element.name,
</span><span class="noop">                       objecttools.classname(self.subseqs)[:-9].lower(),
</span><span class="noop">                       self.name)
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise RuntimeError(&#39;For sequence `%s` the raw filename cannot &#39;
</span><span class="noop">                                   &#39;determined.  Either set it manually or &#39;
</span><span class="noop">                                   &#39;embed the sequence object into the HydPy &#39;
</span><span class="noop">                                   &#39;framework in the common manner to allow &#39;
</span><span class="noop">                                   &#39;for an automatic determination.&#39;
</span><span class="noop">                                   % self.name)
</span><span class="noop">
</span><span class="hit">    def _setrawfilename(self, name):
</span><span class="miss">        self._rawfilename = str(name)
</span><span class="noop">
</span><span class="hit">    def _delrawfilename(self):
</span><span class="miss">        self._rawfilename = None
</span><span class="noop">
</span><span class="hit">    rawfilename = property(_getrawfilename, _setrawfilename, _delrawfilename)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class InputSequence(ModelIOSequence):
</span><span class="noop">    &#34;&#34;&#34; &#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FluxSequence(ModelIOSequence):
</span><span class="noop">    &#34;&#34;&#34; &#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class LeftRightSequence(ModelIOSequence):
</span><span class="hit">    NDIM = 1
</span><span class="noop">
</span><span class="hit">    def _initvalues(self):
</span><span class="hit">        setattr(self.fastaccess, self.name,
</span><span class="noop">                numpy.full(2, self.initvalue, dtype=float))
</span><span class="noop">
</span><span class="hit">    def _getleft(self):
</span><span class="noop">        &#34;&#34;&#34;The &#34;left&#34; value of the actual parameter.&#34;&#34;&#34;
</span><span class="miss">        return self.values[0]
</span><span class="noop">
</span><span class="hit">    def _setleft(self, value):
</span><span class="miss">        self.values[0] = value
</span><span class="noop">
</span><span class="hit">    left = property(_getleft, _setleft)
</span><span class="hit">    l = left
</span><span class="noop">
</span><span class="hit">    def _getright(self):
</span><span class="noop">        &#34;&#34;&#34;The &#34;right&#34; value of the actual parameter.&#34;&#34;&#34;
</span><span class="miss">        return self.values[1]
</span><span class="noop">
</span><span class="hit">    def _setright(self, value):
</span><span class="miss">        self.values[1] = value
</span><span class="noop">
</span><span class="hit">    right = property(_getright, _setright)
</span><span class="hit">    r = right
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ConditionSequence(object):
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args):
</span><span class="hit">        self.values = args
</span><span class="hit">        self.trim()
</span><span class="hit">        self._oldargs = copy.deepcopy(args)
</span><span class="noop">
</span><span class="hit">    trim = objecttools.trim
</span><span class="noop">
</span><span class="hit">    def warntrim(self):
</span><span class="miss">        warnings.warn(&#39;For sequence %s of element %s at least one value &#39;
</span><span class="noop">                      &#39;needed to be trimmed.  One possible reason could be &#39;
</span><span class="noop">                      &#39;that the related control parameter and initial &#39;
</span><span class="noop">                      &#39;condition files are inconsistent.&#39;
</span><span class="noop">                      % (self.name, objecttools.devicename(self)))
</span><span class="noop">
</span><span class="hit">    def reset(self):
</span><span class="miss">        if self._oldargs:
</span><span class="miss">            self(*self._oldargs)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class StateSequence(ModelIOSequence, ConditionSequence):
</span><span class="noop">    &#34;&#34;&#34;Handler for state time series.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        ModelIOSequence.__init__(self)
</span><span class="hit">        self.fastaccess_old = None
</span><span class="hit">        self.fastaccess_new = None
</span><span class="hit">        self._oldargs = None
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args):
</span><span class="noop">        &#34;&#34;&#34;The prefered way to pass values to :class:`Sequence` instances
</span><span class="noop">        within initial condition files.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        ConditionSequence.__call__(self, *args)
</span><span class="hit">        self.new2old()
</span><span class="noop">
</span><span class="hit">    def connect(self, subseqs):
</span><span class="hit">        ModelIOSequence.connect(self, subseqs)
</span><span class="hit">        self.fastaccess_old = subseqs.fastaccess_old
</span><span class="hit">        self.fastaccess_new = subseqs.fastaccess_new
</span><span class="hit">        if self.NDIM:
</span><span class="hit">            setattr(self.fastaccess_old, self.name, None)
</span><span class="noop">        else:
</span><span class="hit">            setattr(self.fastaccess_old, self.name, 0.)
</span><span class="noop">
</span><span class="hit">    def _setshape(self, shape):
</span><span class="hit">        ModelIOSequence._setshape(self, shape)
</span><span class="hit">        if self.NDIM:
</span><span class="hit">            setattr(self.fastaccess_old, self.name, self.new.copy())
</span><span class="noop">
</span><span class="hit">    shape = property(ModelIOSequence._getshape, _setshape)
</span><span class="noop">
</span><span class="hit">    new = Sequence.values
</span><span class="noop">    &#34;&#34;&#34;Complete access to the state value(s), which will be used in the next
</span><span class="noop">    calculation steps.  Note that :attr:`~StateSequence.new` is a synonym of
</span><span class="noop">    :attr:`~StateSequence.value`.  Use this property to modify the initial
</span><span class="noop">    condition(s) of a single :class:`StateSequence` object.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def _getold(self):
</span><span class="noop">        &#34;&#34;&#34;Assess to the state value(s) at beginning of the time step, which
</span><span class="noop">        has been processed most recently.  When using :ref:`HydPy` in the
</span><span class="noop">        normal manner.  But it can be helpful for demonstration and debugging
</span><span class="noop">        purposes.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        value = getattr(self.fastaccess_old, self.name, None)
</span><span class="hit">        if value is None:
</span><span class="miss">            raise RuntimeError(&#39;No value/values of sequence `%s` has/have &#39;
</span><span class="noop">                               &#39;not been defined so far.&#39; % self.name)
</span><span class="noop">        else:
</span><span class="hit">            if self.NDIM:
</span><span class="hit">                value = numpy.asarray(value)
</span><span class="hit">            return value
</span><span class="noop">
</span><span class="hit">    def _setold(self, value):
</span><span class="hit">        if self.NDIM == 0:
</span><span class="hit">            try:
</span><span class="hit">                temp = value[0]
</span><span class="miss">                if len(value) &gt; 1:
</span><span class="miss">                    raise ValueError(&#39;%d values are assigned to the scalar &#39;
</span><span class="noop">                                     &#39;sequence `%s`, which is ambiguous.&#39;
</span><span class="noop">                                     % (len(value)), self.name)
</span><span class="miss">                value = temp
</span><span class="hit">            except (TypeError, IndexError):
</span><span class="hit">                pass
</span><span class="hit">            try:
</span><span class="hit">                value = float(value)
</span><span class="miss">            except (ValueError, TypeError):
</span><span class="miss">                raise TypeError(&#39;When trying to set the value of sequence &#39;
</span><span class="noop">                                &#39;`%s`, it was not possible to convert `%s` &#39;
</span><span class="noop">                                &#39;to float .&#39; % (self.name, value))
</span><span class="noop">        else:
</span><span class="hit">            try:
</span><span class="hit">                value = value.value
</span><span class="hit">            except AttributeError:
</span><span class="hit">                pass
</span><span class="hit">            try:
</span><span class="hit">                value = numpy.full(self.shape, value, dtype=float)
</span><span class="miss">            except ValueError:
</span><span class="miss">                raise ValueError(&#39;The values `%s` cannot be converted to a &#39;
</span><span class="noop">                                 &#39;numpy ndarray with shape %s containing &#39;
</span><span class="noop">                                 &#39;entries of type float.&#39;
</span><span class="noop">                                 % (value, self.shape))
</span><span class="hit">        setattr(self.fastaccess_old, self.name, value)
</span><span class="noop">
</span><span class="hit">    old = property(_getold, _setold)
</span><span class="noop">
</span><span class="hit">    def new2old(self):
</span><span class="hit">        if self.NDIM:
</span><span class="hit">            self.old[:] = self.new[:]
</span><span class="noop">        else:
</span><span class="hit">            self.old = self.new
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class LogSequence(Sequence, ConditionSequence):
</span><span class="noop">    &#34;&#34;&#34; &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        Sequence.__init__(self)
</span><span class="hit">        self._oldargs = None
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args):
</span><span class="miss">        self.values = args
</span><span class="miss">        self.trim()
</span><span class="miss">        self._oldargs = copy.deepcopy(args)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class AideSequence(Sequence):
</span><span class="noop">    &#34;&#34;&#34; &#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class LinkSequence(Sequence):
</span><span class="noop">    &#34;&#34;&#34;2&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def setpointer(self, double, idx=0):
</span><span class="hit">        pdouble = pointer.PDouble(double)
</span><span class="hit">        if self.NDIM == 0:
</span><span class="hit">            try:
</span><span class="hit">                self.fastaccess.setpointer0d(self.name, pdouble)
</span><span class="hit">            except AttributeError:
</span><span class="hit">                setattr(self.fastaccess, self.name, pdouble)
</span><span class="hit">        elif self.NDIM == 1:
</span><span class="hit">            try:
</span><span class="hit">                self.fastaccess.setpointer1d(self.name, pdouble, idx)
</span><span class="hit">            except AttributeError:
</span><span class="hit">                ppdouble = getattr(self.fastaccess, self.name)
</span><span class="hit">                ppdouble.setpointer(double, idx)
</span><span class="noop">
</span><span class="hit">    def _initvalues(self):
</span><span class="hit">        if self.NDIM == 0:
</span><span class="hit">            try:
</span><span class="hit">                setattr(self.fastaccess, self.name, None)
</span><span class="hit">            except AttributeError:
</span><span class="hit">                pass
</span><span class="noop">        else:
</span><span class="hit">            try:
</span><span class="hit">                setattr(self.fastaccess, self.name, pointer.PPDouble())
</span><span class="hit">            except AttributeError:
</span><span class="hit">                pass
</span><span class="noop">
</span><span class="hit">    def _getvalue(self):
</span><span class="noop">        &#34;&#34;&#34;ToDo&#34;&#34;&#34;
</span><span class="miss">        raise NotImplementedError(&#39;To retrieve a pointer is very likely to &#39;
</span><span class="noop">                                  &#39;result in bugs and is thus not supported &#39;
</span><span class="noop">                                  &#39;at the moment.&#39;)
</span><span class="noop">
</span><span class="hit">    def _setvalue(self, value):
</span><span class="noop">        &#34;&#34;&#34;Could be implemented, but is not important at the moment...&#34;&#34;&#34;
</span><span class="miss">        raise NotImplementedError(&#39;To change a pointer is very likely to &#39;
</span><span class="noop">                                  &#39;result in bugs and is thus not supported &#39;
</span><span class="noop">                                  &#39;at the moment.&#39;)
</span><span class="noop">
</span><span class="hit">    value = property(_getvalue, _setvalue)
</span><span class="hit">    values = value
</span><span class="noop">
</span><span class="hit">    def _getshape(self):
</span><span class="hit">        if self.NDIM == 0:
</span><span class="miss">            return ()
</span><span class="hit">        elif self.NDIM == 1:
</span><span class="hit">            try:
</span><span class="hit">                return getattr(self.fastaccess, self.name).shape
</span><span class="hit">            except AttributeError:
</span><span class="hit">                return (getattr(self.fastaccess, &#39;_%s_length_0&#39; % self.name), )
</span><span class="noop">
</span><span class="hit">    def _setshape(self, shape):
</span><span class="hit">        if self.NDIM == 1:
</span><span class="hit">            try:
</span><span class="hit">                getattr(self.fastaccess, self.name).shape = shape
</span><span class="hit">            except AttributeError:
</span><span class="hit">                self.fastaccess.dealloc()
</span><span class="hit">                self.fastaccess.alloc(self.name, shape)
</span><span class="hit">            setattr(self.fastaccess, &#39;len_&#39;+self.name, self.shape[0])
</span><span class="noop">
</span><span class="hit">    shape = property(_getshape, _setshape)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class NodeSequence(IOSequence):
</span><span class="noop">
</span><span class="hit">    def _getrawfilename(self):
</span><span class="noop">        &#34;&#34;&#34;Filename without ending for external and internal date files.&#34;&#34;&#34;
</span><span class="miss">        if self._rawfilename:
</span><span class="miss">            return self._rawfilename
</span><span class="noop">        else:
</span><span class="miss">            try:
</span><span class="miss">                return &#39;%s_%s_%s&#39; % (
</span><span class="noop">                       self.subseqs.node.name,
</span><span class="noop">                       self.name,
</span><span class="noop">                       self.subseqs.node.variable.lower())
</span><span class="miss">            except AttributeError:
</span><span class="miss">                raise RuntimeError(&#39;For sequence `%s` the raw filename cannot &#39;
</span><span class="noop">                                   &#39;determined.  Either set it manually or &#39;
</span><span class="noop">                                   &#39;embed the sequence object into the HydPy &#39;
</span><span class="noop">                                   &#39;framework in the common manner to allow &#39;
</span><span class="noop">                                   &#39;for an automatic determination.&#39;
</span><span class="noop">                                   % self.name)
</span><span class="noop">
</span><span class="hit">    def _setrawfilename(self, name):
</span><span class="miss">        self._rawfilename = str(name)
</span><span class="noop">
</span><span class="hit">    def _delrawfilename(self):
</span><span class="miss">        self._rawfilename = None
</span><span class="noop">
</span><span class="hit">    rawfilename = property(_getrawfilename, _setrawfilename, _delrawfilename)
</span><span class="noop">
</span><span class="hit">    def _initvalues(self):
</span><span class="hit">        setattr(self.fastaccess, self.name, pointer.Double(0.))
</span><span class="noop">
</span><span class="hit">    def _getvalues(self):
</span><span class="noop">        &#34;&#34;&#34;Actual value(s) handled by the sequence.  For consistency,
</span><span class="noop">        `value` and `values` can always be used interchangeably.&#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            return getattr(self.fastaccess, self.name)
</span><span class="miss">        except AttributeError:
</span><span class="miss">            if self.NDIM == 0:
</span><span class="miss">                return self.fastaccess.getpointer0d(self.name)
</span><span class="miss">            elif self.NDIM == 1:
</span><span class="miss">                return self.fastaccess.getpointer1d(self.name)
</span><span class="noop">
</span><span class="hit">    def _setvalues(self, values):
</span><span class="hit">        getattr(self.fastaccess, self.name)[0] = values
</span><span class="noop">
</span><span class="hit">    values = property(_getvalues, _setvalues)
</span><span class="hit">    value = values
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Sim(NodeSequence):
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        NodeSequence.__init__(self)
</span><span class="hit">        self.use_ext = False
</span><span class="noop">
</span><span class="hit">    def activate_disk(self):
</span><span class="miss">        try:
</span><span class="miss">            NodeSequence.activate_disk(self)
</span><span class="miss">        except IOError:
</span><span class="miss">            message = sys.exc_info()[1]
</span><span class="miss">            self.diskflag = False
</span><span class="miss">            if pub.options.warnmissingimfile:
</span><span class="miss">                warnings.warn(&#39;The option `diskflag` of the simulation &#39;
</span><span class="noop">                              &#39;sequence `%s`had to be set to `False` due &#39;
</span><span class="noop">                              &#39;to the following problem: %s.&#39;
</span><span class="noop">                              % (objecttools.devicename(self), message))
</span><span class="noop">
</span><span class="hit">    def activate_ram(self):
</span><span class="miss">        try:
</span><span class="miss">            NodeSequence.activate_ram(self)
</span><span class="miss">        except IOError:
</span><span class="miss">            message = sys.exc_info()[1]
</span><span class="miss">            self.ramflag = False
</span><span class="miss">            if pub.options.warnmissingimfile:
</span><span class="miss">                warnings.warn(&#39;The option `ramflag` of the simulation &#39;
</span><span class="noop">                              &#39;sequence `%s`had to be set to `False` due &#39;
</span><span class="noop">                              &#39;to the following problem: %s.&#39;
</span><span class="noop">                              % (objecttools.devicename(self), message))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Obs(NodeSequence):
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        NodeSequence.__init__(self)
</span><span class="hit">        self.use_ext = True
</span><span class="noop">
</span><span class="hit">    def activate_disk(self):
</span><span class="miss">        try:
</span><span class="miss">            NodeSequence.activate_disk(self)
</span><span class="miss">        except IOError:
</span><span class="miss">            message = sys.exc_info()[1]
</span><span class="miss">            self.diskflag = False
</span><span class="miss">            if pub.options.warnmissingobsfile:
</span><span class="miss">                warnings.warn(&#39;The option `diskflag` of the observation &#39;
</span><span class="noop">                              &#39;sequence `%s`had to be set to `False` due &#39;
</span><span class="noop">                              &#39;to the following problem: %s.&#39;
</span><span class="noop">                              % (objecttools.devicename(self), message))
</span><span class="noop">
</span><span class="hit">    def activate_ram(self):
</span><span class="miss">        try:
</span><span class="miss">            NodeSequence.activate_ram(self)
</span><span class="miss">        except IOError:
</span><span class="miss">            message = sys.exc_info()[1]
</span><span class="miss">            self.ramflag = False
</span><span class="miss">            if pub.options.warnmissingobsfile:
</span><span class="miss">                warnings.warn(&#39;The option `ramflag` of the observation &#39;
</span><span class="noop">                              &#39;sequence `%s`had to be set to `False` due &#39;
</span><span class="noop">                              &#39;to the following problem: %s.&#39;
</span><span class="noop">                              % (objecttools.devicename(self), message))
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def series_complete(self):
</span><span class="miss">        return self.memoryflag and not numpy.any(numpy.isnan(self.series))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class NodeSequences(IOSubSequences):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling node sequences.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Sim, Obs)
</span><span class="noop">
</span><span class="hit">    def __init__(self, seqs, cls_fastaccess=None):
</span><span class="hit">        IOSubSequences.__init__(self, seqs, cls_fastaccess)
</span><span class="hit">        self.node = seqs
</span><span class="noop">
</span><span class="hit">    def loaddata(self, idx):
</span><span class="miss">        self.fastaccess.loaddata(idx)
</span><span class="noop">
</span><span class="hit">    def savedata(self, idx):
</span><span class="miss">        self.fastaccess.savedata(idx)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FastAccess(object):
</span><span class="noop">    &#34;&#34;&#34;Provides fast access to the values of the sequences of a sequence
</span><span class="noop">    subgroup and supports the handling of internal data series during
</span><span class="noop">    simulations.
</span><span class="noop">
</span><span class="noop">    The following details are of relevance for :ref:`HydPy` developers only.
</span><span class="noop">
</span><span class="noop">    :class:`FastAccess` is applied in Python mode only.  In Cython mode,
</span><span class="noop">    specialized and more efficient cdef classes replace it.  For
</span><span class="noop">    compatibility with these cdef classes, :class:`FastAccess` objects
</span><span class="noop">    work with dynamically set instance members.  Suppose there is a
</span><span class="noop">    sequence named `seq1` which is 2-dimensional, then its associated
</span><span class="noop">    attributes are:
</span><span class="noop">
</span><span class="noop">      * seq1 (:class:`~numpy.ndarray`): The actual sequence values.
</span><span class="noop">      * _seq1_ndim (:class:`int`): Number of dimensions.
</span><span class="noop">      * _seq1_length_0 (:class:`int`): Length in the first dimension.
</span><span class="noop">      * _seq1_length_1 (:class:`int`): Length in the second dimension.
</span><span class="noop">      * _seq1_ramflag (:class:`bool`): Handle internal data in RAM?
</span><span class="noop">      * _seq1_diskflag (:class:`bool`): Handle internal data on disk?
</span><span class="noop">      * _seq1_path (:class:`str`): Path of the internal data file.
</span><span class="noop">      * _seq1_file (:class:`file`): Object handling the internal data file.
</span><span class="noop">
</span><span class="noop">    Note that all these dynamical attributes and the following methods are
</span><span class="noop">    initialised, changed or applied by the respective :class:`SubSequences`
</span><span class="noop">    and :class:`Sequence` objects.  Handling them directly is error prone
</span><span class="noop">    and thus not recommended.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def openfiles(self, idx):
</span><span class="noop">        &#34;&#34;&#34;Open all files with an activated disk flag.&#34;&#34;&#34;
</span><span class="hit">        for name in self:
</span><span class="hit">            if getattr(self, &#39;_%s_diskflag&#39; % name):
</span><span class="miss">                path = getattr(self, &#39;_%s_path&#39; % name)
</span><span class="miss">                file_ = open(path, &#39;rb+&#39;)
</span><span class="miss">                ndim = getattr(self, &#39;_%s_ndim&#39; % name)
</span><span class="miss">                position = 8*idx
</span><span class="miss">                for idim in range(ndim):
</span><span class="miss">                    length = getattr(self, &#39;_%s_length_%d&#39; % (name, idim))
</span><span class="miss">                    position *= length
</span><span class="miss">                file_.seek(position)
</span><span class="miss">                setattr(self, &#39;_%s_file&#39; % name, file_)
</span><span class="noop">
</span><span class="hit">    def closefiles(self):
</span><span class="noop">        &#34;&#34;&#34;Close all files with an activated disk flag.&#34;&#34;&#34;
</span><span class="hit">        for name in self:
</span><span class="hit">            if getattr(self, &#39;_%s_diskflag&#39; % name):
</span><span class="miss">                file_ = getattr(self, &#39;_%s_file&#39; % name)
</span><span class="miss">                file_.close()
</span><span class="noop">
</span><span class="hit">    def loaddata(self, idx):
</span><span class="noop">        &#34;&#34;&#34;Load the internal data of all sequences.  Load from file if the
</span><span class="noop">        corresponding disk flag is activated, otherwise load from RAM.&#34;&#34;&#34;
</span><span class="hit">        for name in self:
</span><span class="hit">            ndim = getattr(self, &#39;_%s_ndim&#39; % name)
</span><span class="hit">            diskflag = getattr(self, &#39;_%s_diskflag&#39; % name)
</span><span class="hit">            ramflag = getattr(self, &#39;_%s_ramflag&#39; % name)
</span><span class="hit">            if diskflag:
</span><span class="miss">                file_ = getattr(self, &#39;_%s_file&#39; % name)
</span><span class="miss">                length_tot = 1
</span><span class="miss">                shape = []
</span><span class="miss">                for idx in range(ndim):
</span><span class="miss">                    length = getattr(self, &#39;_%s_length_%s&#39; % (name, idx))
</span><span class="miss">                    length_tot *= length
</span><span class="miss">                    shape.append(length)
</span><span class="miss">                raw = file_.read(length_tot*8)
</span><span class="miss">                values = struct.unpack(length_tot*&#39;d&#39;, raw)
</span><span class="miss">                if ndim:
</span><span class="miss">                    values = numpy.array(values).reshape(shape)
</span><span class="noop">                else:
</span><span class="miss">                    values = values[0]
</span><span class="hit">            elif ramflag:
</span><span class="hit">                array = getattr(self, &#39;_%s_array&#39; % name)
</span><span class="hit">                values = array[idx]
</span><span class="hit">            if (diskflag or ramflag):
</span><span class="hit">                if ndim == 0:
</span><span class="hit">                    setattr(self, name, values)
</span><span class="noop">                else:
</span><span class="miss">                    getattr(self, name)[:] = values
</span><span class="noop">
</span><span class="hit">    def savedata(self, idx):
</span><span class="noop">        &#34;&#34;&#34;Save the internal data of all sequences with an activated flag.
</span><span class="noop">        Write to file if the corresponding disk flag is activated; store
</span><span class="noop">        in working memory if the corresponding ram flag is activated.&#34;&#34;&#34;
</span><span class="hit">        for name in self:
</span><span class="hit">            actual = getattr(self, name)
</span><span class="hit">            diskflag = getattr(self, &#39;_%s_diskflag&#39; % name)
</span><span class="hit">            ramflag = getattr(self, &#39;_%s_ramflag&#39; % name)
</span><span class="hit">            if diskflag:
</span><span class="miss">                file_ = getattr(self, &#39;_%s_file&#39; % name)
</span><span class="miss">                ndim = getattr(self, &#39;_%s_ndim&#39; % name)
</span><span class="miss">                length_tot = 1
</span><span class="miss">                for idx in range(ndim):
</span><span class="miss">                    length = getattr(self, &#39;_%s_length_%s&#39; % (name, idx))
</span><span class="miss">                    length_tot *= length
</span><span class="miss">                if ndim:
</span><span class="miss">                    raw = struct.pack(length_tot*&#39;d&#39;, *actual.flatten())
</span><span class="noop">                else:
</span><span class="miss">                    raw = struct.pack(&#39;d&#39;, actual)
</span><span class="miss">                file_.write(raw)
</span><span class="hit">            elif ramflag:
</span><span class="hit">                array = getattr(self, &#39;_%s_array&#39; % name)
</span><span class="hit">                array[idx] = actual
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="noop">        &#34;&#34;&#34;Iterate over all sequence names.&#34;&#34;&#34;
</span><span class="hit">        for key in vars(self).keys():
</span><span class="hit">            if not key.startswith(&#39;_&#39;):
</span><span class="hit">                yield key
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/testtools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/testtools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;This module implements tools for making doctests more legible.
</span><span class="noop">
</span><span class="noop">At the moment only class :class:`Test` is implemented.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import datetime
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy.core import hydpytools
</span><span class="hit">from hydpy.core import devicetools
</span><span class="hit">from hydpy.core import selectiontools
</span><span class="hit">from hydpy.core import objecttools
</span><span class="hit">from hydpy.core import timetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Test(object):
</span><span class="noop">    &#34;&#34;&#34;Defines model integration doctests.
</span><span class="noop">
</span><span class="noop">    The functionality of :class:`Test` is easiest to understand by inspecting
</span><span class="noop">    doctests like the one of module :mod:`~hydpy.models.llake_v1`.
</span><span class="noop">
</span><span class="noop">    Note that all condition sequences (state and logging sequences) are
</span><span class="noop">    initialized in accordance with the values are given in the `inits`
</span><span class="noop">    dictionary.  The values of the simulation sequences of outlet and
</span><span class="noop">    sender nodes are always set to zero before each test run.  All other
</span><span class="noop">    parameter and sequence values can be changed between different test
</span><span class="noop">    runs.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    _dateformat = None
</span><span class="noop">
</span><span class="hit">    def __init__(self, element, seqs=None, inits=None):
</span><span class="hit">        nodes = devicetools.Nodes()
</span><span class="hit">        for connection in (element.inlets, element.outlets,
</span><span class="noop">                           element.receivers, element.senders):
</span><span class="hit">            nodes += connection.slaves
</span><span class="hit">        for (name, node) in nodes:
</span><span class="hit">            if (node in element.inlets) or (node in element.receivers):
</span><span class="hit">                node.routingmode = &#39;oldsim&#39;
</span><span class="hit">            sim = node.sequences.sim
</span><span class="hit">            sim.ramflag = True
</span><span class="hit">            sim._setarray(numpy.zeros(len(pub.timegrids.init), dtype=float))
</span><span class="hit">        for (name, seq) in getattr(element.model.sequences, &#39;inputs&#39;, ()):
</span><span class="hit">            seq.ramflag = True
</span><span class="hit">            seq._setarray(numpy.zeros(len(pub.timegrids.init), dtype=float))
</span><span class="hit">        if seqs is None:
</span><span class="hit">            seqs = []
</span><span class="hit">            for subseqs in (&#39;inputs&#39;, &#39;fluxes&#39;, &#39;states&#39;):
</span><span class="hit">                for (name, seq) in getattr(element.model.sequences,
</span><span class="noop">                                           subseqs, ()):
</span><span class="hit">                    seqs.append(seq)
</span><span class="hit">            for (name, node) in nodes:
</span><span class="hit">                seqs.append(node.sequences.sim)
</span><span class="hit">        element.prepare_fluxseries()
</span><span class="hit">        element.prepare_stateseries()
</span><span class="hit">        self.element = element
</span><span class="hit">        self.nodes = nodes
</span><span class="hit">        self.seqs = seqs
</span><span class="hit">        self.inits = {} if inits is None else inits
</span><span class="hit">        self.model = element.model
</span><span class="hit">        hydpytools.HydPy.nmb_instances = 0
</span><span class="hit">        self.hp = hydpytools.HydPy()
</span><span class="hit">        self.hp.updatedevices(selectiontools.Selection(&#39;test&#39;, nodes, element))
</span><span class="noop">
</span><span class="hit">    def __call__(self):
</span><span class="hit">        self._prepare_model()
</span><span class="hit">        self.hp.doit()
</span><span class="hit">        self._print_results()
</span><span class="noop">
</span><span class="hit">    def _prepare_model(self):
</span><span class="hit">        self.model.parameters.update()
</span><span class="hit">        for (name, node) in self.nodes:
</span><span class="hit">            if ((node in self.element.outlets) or
</span><span class="noop">                    (node in self.element.senders)):
</span><span class="hit">                node.sequences.sim[:] = 0.
</span><span class="hit">        for (name, seq) in getattr(self.model.sequences, &#39;states&#39;, ()):
</span><span class="hit">            seq(self.inits[name])
</span><span class="hit">        for (name, seq) in getattr(self.model.sequences, &#39;logs&#39;, ()):
</span><span class="miss">            seq(self.inits[name])
</span><span class="noop">
</span><span class="hit">    def _print_results(self):
</span><span class="hit">        strings = [[&#39;date&#39;] + [seq.subseqs.node.name if
</span><span class="noop">                               seq.name == &#39;sim&#39; else seq.name
</span><span class="noop">                               for seq in self.seqs]]
</span><span class="hit">        lengths = numpy.zeros((len(pub.timegrids.sim)+1, len(self.seqs)+1),
</span><span class="noop">                              dtype=int)
</span><span class="hit">        lengths[0, :] = [len(string) for string in strings[0]]
</span><span class="hit">        for (idx, date) in enumerate(pub.timegrids.sim):
</span><span class="hit">            strings.append([date.datetime.strftime(self.dateformat)])
</span><span class="hit">            for seq in self.seqs:
</span><span class="hit">                if seq.NDIM == 0:
</span><span class="hit">                    strings[-1].append(objecttools.repr_(seq.series[idx]))
</span><span class="hit">                elif seq.NDIM == 1 and seq.shape == (1,):
</span><span class="hit">                    strings[-1].append(objecttools.repr_(seq.series[idx, 0]))
</span><span class="noop">                else:
</span><span class="miss">                    raise RuntimeError(
</span><span class="noop">                        &#39;An instance of class `Test` of module `testtools` &#39;
</span><span class="noop">                        &#39;is requested to print the results of sequence `%s`. &#39;
</span><span class="noop">                        &#39;Unfortunately, for %d-dimensional sequences with &#39;
</span><span class="noop">                        &#39;shape `%s` this feature is not supported yet.&#39;
</span><span class="noop">                        % (seq.name, seq.NDIM, seq.shape))
</span><span class="hit">            lengths[idx+1, :] = [len(string) for string in strings[-1]]
</span><span class="hit">        maxlengths = numpy.max(lengths, axis=0)
</span><span class="hit">        for (idx, linestrings) in enumerate(strings):
</span><span class="hit">            print(&#39;|&#39;,
</span><span class="noop">                  &#39; | &#39;.join(string.rjust(maxlengths[jdx]) for (jdx, string)
</span><span class="noop">                             in enumerate(linestrings)),
</span><span class="noop">                  &#39;|&#39;)
</span><span class="hit">            if idx == 0:
</span><span class="hit">                print(&#39;-&#39;*(numpy.sum(maxlengths)+3*(len(self.seqs))+4))
</span><span class="noop">
</span><span class="hit">    def _getdateformat(self):
</span><span class="hit">        if self._dateformat is None:
</span><span class="miss">            return timetools.Date._formatstrings[&#39;iso&#39;]
</span><span class="noop">        else:
</span><span class="hit">            return self._dateformat
</span><span class="noop">
</span><span class="hit">    def _setdateformat(self, dateformat):
</span><span class="hit">        try:
</span><span class="hit">            dateformat = str(dateformat)
</span><span class="miss">        except BaseException:
</span><span class="miss">            raise TypeError(
</span><span class="noop">                &#39;The given `dateformat` of type `%s` could not be converted &#39;
</span><span class="noop">                &#39;to a `str` instance.&#39; % objecttools.classname(dateformat))
</span><span class="hit">        try:
</span><span class="hit">            datetime.datetime(2000, 1, 1).strftime(dateformat)
</span><span class="miss">        except BaseException:
</span><span class="miss">            raise ValueError(
</span><span class="noop">                &#34;The given `dateformat` `%s` is not a valid format string &#34;
</span><span class="noop">                &#34;for `datetime` objects.  Please read the documentation &#34;
</span><span class="noop">                &#34;on module `datetime` of Python&#39;s the standard library &#34;
</span><span class="noop">                &#34;for further information.&#34; % dateformat)
</span><span class="hit">        self._dateformat = dateformat
</span><span class="noop">
</span><span class="hit">    dateformat = property(_getdateformat, _setdateformat)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/timetools.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/core/timetools.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
677 &nbsp;
678 &nbsp;
679 &nbsp;
680 &nbsp;
681 &nbsp;
682 &nbsp;
683 &nbsp;
684 &nbsp;
685 &nbsp;
686 &nbsp;
687 &nbsp;
688 &nbsp;
689 &nbsp;
690 &nbsp;
691 &nbsp;
692 &nbsp;
693 &nbsp;
694 &nbsp;
695 &nbsp;
696 &nbsp;
697 &nbsp;
698 &nbsp;
699 &nbsp;
700 &nbsp;
701 &nbsp;
702 &nbsp;
703 &nbsp;
704 &nbsp;
705 &nbsp;
706 &nbsp;
707 &nbsp;
708 &nbsp;
709 &nbsp;
710 &nbsp;
711 &nbsp;
712 &nbsp;
713 &nbsp;
714 &nbsp;
715 &nbsp;
716 &nbsp;
717 &nbsp;
718 &nbsp;
719 &nbsp;
720 &nbsp;
721 &nbsp;
722 &nbsp;
723 &nbsp;
724 &nbsp;
725 &nbsp;
726 &nbsp;
727 &nbsp;
728 &nbsp;
729 &nbsp;
730 &nbsp;
731 &nbsp;
732 &nbsp;
733 &nbsp;
734 &nbsp;
735 &nbsp;
736 &nbsp;
737 &nbsp;
738 &nbsp;
739 &nbsp;
740 &nbsp;
741 &nbsp;
742 &nbsp;
743 &nbsp;
744 &nbsp;
745 &nbsp;
746 &nbsp;
747 &nbsp;
748 &nbsp;
749 &nbsp;
750 &nbsp;
751 &nbsp;
752 &nbsp;
753 &nbsp;
754 &nbsp;
755 &nbsp;
756 &nbsp;
757 &nbsp;
758 &nbsp;
759 &nbsp;
760 &nbsp;
761 &nbsp;
762 &nbsp;
763 &nbsp;
764 &nbsp;
765 &nbsp;
766 &nbsp;
767 &nbsp;
768 &nbsp;
769 &nbsp;
770 &nbsp;
771 &nbsp;
772 &nbsp;
773 &nbsp;
774 &nbsp;
775 &nbsp;
776 &nbsp;
777 &nbsp;
778 &nbsp;
779 &nbsp;
780 &nbsp;
781 &nbsp;
782 &nbsp;
783 &nbsp;
784 &nbsp;
785 &nbsp;
786 &nbsp;
787 &nbsp;
788 &nbsp;
789 &nbsp;
790 &nbsp;
791 &nbsp;
792 &nbsp;
793 &nbsp;
794 &nbsp;
795 &nbsp;
796 &nbsp;
797 &nbsp;
798 &nbsp;
799 &nbsp;
800 &nbsp;
801 &nbsp;
802 &nbsp;
803 &nbsp;
804 &nbsp;
805 &nbsp;
806 &nbsp;
807 &nbsp;
808 &nbsp;
809 &nbsp;
810 &nbsp;
811 &nbsp;
812 &nbsp;
813 &nbsp;
814 &nbsp;
815 &nbsp;
816 &nbsp;
817 &nbsp;
818 &nbsp;
819 &nbsp;
820 &nbsp;
821 &nbsp;
822 &nbsp;
823 &nbsp;
824 &nbsp;
825 &nbsp;
826 &nbsp;
827 &nbsp;
828 &nbsp;
829 &nbsp;
830 &nbsp;
831 &nbsp;
832 &nbsp;
833 &nbsp;
834 &nbsp;
835 &nbsp;
836 &nbsp;
837 &nbsp;
838 &nbsp;
839 &nbsp;
840 &nbsp;
841 &nbsp;
842 &nbsp;
843 &nbsp;
844 &nbsp;
845 &nbsp;
846 &nbsp;
847 &nbsp;
848 &nbsp;
849 &nbsp;
850 &nbsp;
851 &nbsp;
852 &nbsp;
853 &nbsp;
854 &nbsp;
855 &nbsp;
856 &nbsp;
857 &nbsp;
858 &nbsp;
859 &nbsp;
860 &nbsp;
861 &nbsp;
862 &nbsp;
863 &nbsp;
864 &nbsp;
865 &nbsp;
866 &nbsp;
867 &nbsp;
868 &nbsp;
869 &nbsp;
870 &nbsp;
871 &nbsp;
872 &nbsp;
873 &nbsp;
874 &nbsp;
875 &nbsp;
876 &nbsp;
877 &nbsp;
878 &nbsp;
879 &nbsp;
880 &nbsp;
881 &nbsp;
882 &nbsp;
883 &nbsp;
884 &nbsp;
885 &nbsp;
886 &nbsp;
887 &nbsp;
888 &nbsp;
889 &nbsp;
890 &nbsp;
891 &nbsp;
892 &nbsp;
893 &nbsp;
894 &nbsp;
895 &nbsp;
896 &nbsp;
897 &nbsp;
898 &nbsp;
899 &nbsp;
900 &nbsp;
901 &nbsp;
902 &nbsp;
903 &nbsp;
904 &nbsp;
905 &nbsp;
906 &nbsp;
907 &nbsp;
908 &nbsp;
909 &nbsp;
910 &nbsp;
911 &nbsp;
912 &nbsp;
913 &nbsp;
914 &nbsp;
915 &nbsp;
916 &nbsp;
917 &nbsp;
918 &nbsp;
919 &nbsp;
920 &nbsp;
921 &nbsp;
922 &nbsp;
923 &nbsp;
924 &nbsp;
925 &nbsp;
926 &nbsp;
927 &nbsp;
928 &nbsp;
929 &nbsp;
930 &nbsp;
931 &nbsp;
932 &nbsp;
933 &nbsp;
934 &nbsp;
935 &nbsp;
936 &nbsp;
937 &nbsp;
938 &nbsp;
939 &nbsp;
940 &nbsp;
941 &nbsp;
942 &nbsp;
943 &nbsp;
944 &nbsp;
945 &nbsp;
946 &nbsp;
947 &nbsp;
948 &nbsp;
949 &nbsp;
950 &nbsp;
951 &nbsp;
952 &nbsp;
953 &nbsp;
954 &nbsp;
955 &nbsp;
956 &nbsp;
957 &nbsp;
958 &nbsp;
959 &nbsp;
960 &nbsp;
961 &nbsp;
962 &nbsp;
963 &nbsp;
964 &nbsp;
965 &nbsp;
966 &nbsp;
967 &nbsp;
968 &nbsp;
969 &nbsp;
970 &nbsp;
971 &nbsp;
972 &nbsp;
973 &nbsp;
974 &nbsp;
975 &nbsp;
976 &nbsp;
977 &nbsp;
978 &nbsp;
979 &nbsp;
980 &nbsp;
981 &nbsp;
982 &nbsp;
983 &nbsp;
984 &nbsp;
985 &nbsp;
986 &nbsp;
987 &nbsp;
988 &nbsp;
989 &nbsp;
990 &nbsp;
991 &nbsp;
992 &nbsp;
993 &nbsp;
994 &nbsp;
995 &nbsp;
996 &nbsp;
997 &nbsp;
998 &nbsp;
999 &nbsp;
1000 &nbsp;
1001 &nbsp;
1002 &nbsp;
1003 &nbsp;
1004 &nbsp;
1005 &nbsp;
1006 &nbsp;
1007 &nbsp;
1008 &nbsp;
1009 &nbsp;
1010 &nbsp;
1011 &nbsp;
1012 &nbsp;
1013 &nbsp;
1014 &nbsp;
1015 &nbsp;
1016 &nbsp;
1017 &nbsp;
1018 &nbsp;
1019 &nbsp;
1020 &nbsp;
1021 &nbsp;
1022 &nbsp;
1023 &nbsp;
1024 &nbsp;
1025 &nbsp;
1026 &nbsp;
1027 &nbsp;
1028 &nbsp;
1029 &nbsp;
1030 &nbsp;
1031 &nbsp;
1032 &nbsp;
1033 &nbsp;
1034 &nbsp;
1035 &nbsp;
1036 &nbsp;
1037 &nbsp;
1038 &nbsp;
1039 &nbsp;
1040 &nbsp;
1041 &nbsp;
1042 &nbsp;
1043 &nbsp;
1044 &nbsp;
1045 &nbsp;
1046 &nbsp;
1047 &nbsp;
1048 &nbsp;
1049 &nbsp;
1050 &nbsp;
1051 &nbsp;
1052 &nbsp;
1053 &nbsp;
1054 &nbsp;
1055 &nbsp;
1056 &nbsp;
1057 &nbsp;
1058 &nbsp;
1059 &nbsp;
1060 &nbsp;
1061 &nbsp;
1062 &nbsp;
1063 &nbsp;
1064 &nbsp;
1065 &nbsp;
1066 &nbsp;
1067 &nbsp;
1068 &nbsp;
1069 &nbsp;
1070 &nbsp;
1071 &nbsp;
1072 &nbsp;
1073 &nbsp;
1074 &nbsp;
1075 &nbsp;
1076 &nbsp;
1077 &nbsp;
1078 &nbsp;
1079 &nbsp;
1080 &nbsp;
1081 &nbsp;
1082 &nbsp;
1083 &nbsp;
1084 &nbsp;
1085 &nbsp;
1086 &nbsp;
1087 &nbsp;
1088 &nbsp;
1089 &nbsp;
1090 &nbsp;
1091 &nbsp;
1092 &nbsp;
1093 &nbsp;
1094 &nbsp;
1095 &nbsp;
1096 &nbsp;
1097 &nbsp;
1098 &nbsp;
1099 &nbsp;
1100 &nbsp;
1101 &nbsp;
1102 &nbsp;
1103 &nbsp;
1104 &nbsp;
1105 &nbsp;
1106 &nbsp;
1107 &nbsp;
1108 &nbsp;
1109 &nbsp;
1110 &nbsp;
1111 &nbsp;
1112 &nbsp;
1113 &nbsp;
1114 &nbsp;
1115 &nbsp;
1116 &nbsp;
1117 &nbsp;
1118 &nbsp;
1119 &nbsp;
1120 &nbsp;
1121 &nbsp;
1122 &nbsp;
1123 &nbsp;
1124 &nbsp;
1125 &nbsp;
1126 &nbsp;
1127 &nbsp;
1128 &nbsp;
1129 &nbsp;
1130 &nbsp;
1131 &nbsp;
1132 &nbsp;
1133 &nbsp;
1134 &nbsp;
1135 &nbsp;
1136 &nbsp;
1137 &nbsp;
1138 &nbsp;
1139 &nbsp;
1140 &nbsp;
1141 &nbsp;
1142 &nbsp;
1143 &nbsp;
1144 &nbsp;
1145 &nbsp;
1146 &nbsp;
1147 &nbsp;
1148 &nbsp;
1149 &nbsp;
1150 &nbsp;
1151 &nbsp;
1152 &nbsp;
1153 &nbsp;
1154 &nbsp;
1155 &nbsp;
1156 &nbsp;
1157 &nbsp;
1158 &nbsp;
1159 &nbsp;
1160 &nbsp;
1161 &nbsp;
1162 &nbsp;
1163 &nbsp;
1164 &nbsp;
1165 &nbsp;
1166 &nbsp;
1167 &nbsp;
1168 &nbsp;
1169 &nbsp;
1170 &nbsp;
1171 &nbsp;
1172 &nbsp;
1173 &nbsp;
1174 &nbsp;
1175 &nbsp;
1176 &nbsp;
1177 &nbsp;
1178 &nbsp;
1179 &nbsp;
1180 &nbsp;
1181 &nbsp;
1182 &nbsp;
1183 &nbsp;
1184 &nbsp;
1185 &nbsp;
1186 &nbsp;
1187 &nbsp;
1188 &nbsp;
1189 &nbsp;
1190 &nbsp;
1191 &nbsp;
1192 &nbsp;
1193 &nbsp;
1194 &nbsp;
1195 &nbsp;
1196 &nbsp;
1197 &nbsp;
1198 &nbsp;
1199 &nbsp;
1200 &nbsp;
1201 &nbsp;
1202 &nbsp;
1203 &nbsp;
1204 &nbsp;
1205 &nbsp;
1206 &nbsp;
1207 &nbsp;
1208 &nbsp;
1209 &nbsp;
1210 &nbsp;
1211 &nbsp;
1212 &nbsp;
1213 &nbsp;
1214 &nbsp;
1215 &nbsp;
1216 &nbsp;
1217 &nbsp;
1218 &nbsp;
1219 &nbsp;
1220 &nbsp;
1221 &nbsp;
1222 &nbsp;
1223 &nbsp;
1224 &nbsp;
1225 &nbsp;
1226 &nbsp;
1227 &nbsp;
1228 &nbsp;
1229 &nbsp;
1230 &nbsp;
1231 &nbsp;
1232 &nbsp;
1233 &nbsp;
1234 &nbsp;
1235 &nbsp;
1236 &nbsp;
1237 &nbsp;
1238 &nbsp;
1239 &nbsp;
1240 &nbsp;
1241 &nbsp;
1242 &nbsp;
1243 &nbsp;
1244 &nbsp;
1245 &nbsp;
1246 &nbsp;
1247 &nbsp;
1248 &nbsp;
1249 &nbsp;
1250 &nbsp;
1251 &nbsp;
1252 &nbsp;
1253 &nbsp;
1254 &nbsp;
1255 &nbsp;
1256 &nbsp;
1257 &nbsp;
1258 &nbsp;
1259 &nbsp;
1260 &nbsp;
1261 &nbsp;
1262 &nbsp;
1263 &nbsp;
1264 &nbsp;
1265 &nbsp;
1266 &nbsp;
1267 &nbsp;
1268 &nbsp;
1269 &nbsp;
1270 &nbsp;
1271 &nbsp;
1272 &nbsp;
1273 &nbsp;
1274 &nbsp;
1275 &nbsp;
1276 &nbsp;
1277 &nbsp;
1278 &nbsp;
1279 &nbsp;
1280 &nbsp;
1281 &nbsp;
1282 &nbsp;
1283 &nbsp;
1284 &nbsp;
1285 &nbsp;
1286 &nbsp;
1287 &nbsp;
1288 &nbsp;
1289 &nbsp;
1290 &nbsp;
1291 &nbsp;
1292 &nbsp;
1293 &nbsp;
1294 &nbsp;
1295 &nbsp;
1296 &nbsp;
1297 &nbsp;
1298 &nbsp;
1299 &nbsp;
1300 &nbsp;
1301 &nbsp;
1302 &nbsp;
1303 &nbsp;
1304 &nbsp;
1305 &nbsp;
1306 &nbsp;
1307 &nbsp;
1308 &nbsp;
1309 &nbsp;
1310 &nbsp;
1311 &nbsp;
1312 &nbsp;
1313 &nbsp;
1314 &nbsp;
1315 &nbsp;
1316 &nbsp;
1317 &nbsp;
1318 &nbsp;
1319 &nbsp;
1320 &nbsp;
1321 &nbsp;
1322 &nbsp;
1323 &nbsp;
1324 &nbsp;
1325 &nbsp;
1326 &nbsp;
1327 &nbsp;
1328 &nbsp;
1329 &nbsp;
1330 &nbsp;
1331 &nbsp;
1332 &nbsp;
1333 &nbsp;
1334 &nbsp;
1335 &nbsp;
1336 &nbsp;
1337 &nbsp;
1338 &nbsp;
1339 &nbsp;
1340 &nbsp;
1341 &nbsp;
1342 &nbsp;
1343 &nbsp;
1344 &nbsp;
1345 &nbsp;
1346 &nbsp;
1347 &nbsp;
1348 &nbsp;
1349 &nbsp;
1350 &nbsp;
1351 &nbsp;
1352 &nbsp;
1353 &nbsp;
1354 &nbsp;
1355 &nbsp;
1356 &nbsp;
1357 &nbsp;
1358 &nbsp;
1359 &nbsp;
1360 &nbsp;
1361 &nbsp;
1362 &nbsp;
1363 &nbsp;
1364 &nbsp;
1365 &nbsp;
1366 &nbsp;
1367 &nbsp;
1368 &nbsp;
1369 &nbsp;
1370 &nbsp;
1371 &nbsp;
1372 &nbsp;
1373 &nbsp;
1374 &nbsp;
1375 &nbsp;
1376 &nbsp;
1377 &nbsp;
1378 &nbsp;
1379 &nbsp;
1380 &nbsp;
1381 &nbsp;
1382 &nbsp;
1383 &nbsp;
1384 &nbsp;
1385 &nbsp;
1386 &nbsp;
1387 &nbsp;
1388 &nbsp;
1389 &nbsp;
1390 &nbsp;
1391 &nbsp;
1392 &nbsp;
1393 &nbsp;
1394 &nbsp;
1395 &nbsp;
1396 &nbsp;
1397 &nbsp;
1398 &nbsp;
1399 &nbsp;
1400 &nbsp;
1401 &nbsp;
1402 &nbsp;
1403 &nbsp;
1404 &nbsp;
1405 &nbsp;
1406 &nbsp;
1407 &nbsp;
1408 &nbsp;
1409 &nbsp;
1410 &nbsp;
1411 &nbsp;
1412 &nbsp;
1413 &nbsp;
1414 &nbsp;
1415 &nbsp;
1416 &nbsp;
1417 &nbsp;
1418 &nbsp;
1419 &nbsp;
1420 &nbsp;
1421 &nbsp;
1422 &nbsp;
1423 &nbsp;
1424 &nbsp;
1425 &nbsp;
1426 &nbsp;
1427 &nbsp;
1428 &nbsp;
1429 &nbsp;
1430 &nbsp;
1431 &nbsp;
1432 &nbsp;
1433 &nbsp;
1434 &nbsp;
1435 &nbsp;
1436 &nbsp;
1437 &nbsp;
1438 &nbsp;
1439 &nbsp;
1440 &nbsp;
1441 &nbsp;
1442 &nbsp;
1443 &nbsp;
1444 &nbsp;
1445 &nbsp;
1446 &nbsp;
1447 &nbsp;
1448 &nbsp;
1449 &nbsp;
1450 &nbsp;
1451 &nbsp;
1452 &nbsp;
1453 &nbsp;
1454 &nbsp;
1455 &nbsp;
1456 &nbsp;
1457 &nbsp;
1458 &nbsp;
1459 &nbsp;
1460 &nbsp;
1461 &nbsp;
1462 &nbsp;
1463 &nbsp;
1464 &nbsp;
1465 &nbsp;
1466 &nbsp;
1467 &nbsp;
1468 &nbsp;
1469 &nbsp;
1470 &nbsp;
1471 &nbsp;
1472 &nbsp;
1473 &nbsp;
1474 &nbsp;
1475 &nbsp;
1476 &nbsp;
1477 &nbsp;
1478 &nbsp;
1479 &nbsp;
1480 &nbsp;
1481 &nbsp;
1482 &nbsp;
1483 &nbsp;
1484 &nbsp;
1485 &nbsp;
1486 &nbsp;
1487 &nbsp;
1488 &nbsp;
1489 &nbsp;
1490 &nbsp;
1491 &nbsp;
1492 &nbsp;
1493 &nbsp;
1494 &nbsp;
1495 &nbsp;
1496 &nbsp;
1497 &nbsp;
1498 &nbsp;
1499 &nbsp;
1500 &nbsp;
1501 &nbsp;
1502 &nbsp;
1503 &nbsp;
1504 &nbsp;
1505 &nbsp;
1506 &nbsp;
1507 &nbsp;
1508 &nbsp;
1509 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">
</span><span class="hit">&#34;&#34;&#34;This module specifies how  dates and periods are handled in HydPy.
</span><span class="noop">
</span><span class="noop">The following classes are implemented:
</span><span class="noop">    * :class:`Date`: Defines a single time point.
</span><span class="noop">    * :class:`Period`: Defines a single time duration.
</span><span class="noop">    * :class:`Timegrid`: Defines an equidistant sequence of time points.
</span><span class="noop">    * :class:`Timegrids`: Handles all :class:`Timegrid` instances of a
</span><span class="noop">      HydPy project.
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">Date and Period
</span><span class="noop">===============
</span><span class="noop">
</span><span class="noop">Both classes :class:`Date` and :class:`Period` are build on top of the Python
</span><span class="noop">module :mod:`datetime`. In essence, they wrap the :mod:`datetime` classes
</span><span class="noop">:class:`~datetime.datetime` and :class:`~datetime.timedelta`, and are supposed
</span><span class="noop">to specialise these general classes on the needs of HydPy users.
</span><span class="noop">
</span><span class="noop">Be aware of the different minimum time resolution of module :mod:`datetime`
</span><span class="noop">(microseconds) and module :mod:`~hydpy.core.timetools` (seconds).
</span><span class="noop">
</span><span class="noop">:class:`Date` objects can be initialized via :class:`~datetime.datetime`
</span><span class="noop">objects directly, e.g.::
</span><span class="noop">
</span><span class="noop">    from datetime import datetime
</span><span class="noop">    from hydpy.core.timetools import Date
</span><span class="noop">
</span><span class="noop">    # Initialize a `datetime` object...
</span><span class="noop">    datetime_object = datetime(1996, 11, 1, 0, 0, 0)
</span><span class="noop">    # ...and use it to initialise a `Date` object.
</span><span class="noop">    date1 = Date(datetime_object)
</span><span class="noop">
</span><span class="noop">Alternatively, one can use :class:`str` objects as initialization arguments,
</span><span class="noop">which need to match one of the following format styles::
</span><span class="noop">
</span><span class="noop">    # The `os` style without empty space and colon, which is applied in
</span><span class="noop">    # text files and folder names:
</span><span class="noop">    date2 = Date(&#39;1997_11_01_00_00_00&#39;)
</span><span class="noop">    # The `iso` style, which is more legible and in accordance with the
</span><span class="noop">    # international ISO norm:
</span><span class="noop">    date2 = Date(&#39;1997.11.01 00:00:00&#39;)
</span><span class="noop">    # The `din` style, which is more legible for users in countries where the
</span><span class="noop">    # position of day and year are interchanged (DIN refers to a german norm):
</span><span class="noop">    date2 = Date(&#39;01.11.1997 00:00:00&#39;)
</span><span class="noop">
</span><span class="noop">:class:`Date` keeps the chosen style in mind and uses it for printing.  But
</span><span class="noop">the user is also allowed to change it::
</span><span class="noop">
</span><span class="noop">    # Print in accordance with the `iso` style...
</span><span class="noop">    print(date2.string(&#39;iso&#39;))
</span><span class="noop">    # ...without changing the memorized `din` style:
</span><span class="noop">    print(date2.style)
</span><span class="noop">    # Alternatively, the style property can be set permanentely:
</span><span class="noop">    date2.style = &#39;iso&#39;
</span><span class="noop">    print(date2)
</span><span class="noop">
</span><span class="noop">It is allowed to abbreviate the input strings. Using the `iso` style as an
</span><span class="noop">example::
</span><span class="noop">
</span><span class="noop">    # The following three input arguments...
</span><span class="noop">    test1 = Date(&#39;1996.11.01 00:00:00&#39;)
</span><span class="noop">    test2 = Date(&#39;1996.11.01 00:00&#39;)
</span><span class="noop">    test3 = Date(&#39;1996.11.01 00&#39;)
</span><span class="noop">    test4 = Date(&#39;1996.11.01&#39;)
</span><span class="noop">    # ...all lead to identical `Date` instances.
</span><span class="noop">    print(test1, test2, test3, test4)
</span><span class="noop">
</span><span class="noop">If :class:`Date` has not been initialized via a :class:`str` object and the
</span><span class="noop">style property has not been set manually, the default style `iso` is selected.
</span><span class="noop">
</span><span class="noop">One can change the year, month... of a :class:`Date` object via numbers::
</span><span class="noop">
</span><span class="noop">    # Assign an integer...
</span><span class="noop">    test4.year = 1997
</span><span class="noop">    # ...or something that can be converted to an integer.
</span><span class="noop">    test4.month = &#39;10&#39;
</span><span class="noop">    print(test4)
</span><span class="noop">
</span><span class="noop">One can ask for the actual water year, which depends on the selected
</span><span class="noop">reference month::
</span><span class="noop">
</span><span class="noop">    oct = Date(&#39;1996.10.01&#39;)
</span><span class="noop">    nov = Date(&#39;1996.11.01&#39;)
</span><span class="noop">    # Under the standard settings, the water year is assumed to start November.
</span><span class="noop">    print(oct.wateryear, nov.wateryear)
</span><span class="noop">    # Changing the reference month via one `Date` object affects all objects.
</span><span class="noop">    test4.refmonth = 10
</span><span class="noop">    print(oct.wateryear, nov.wateryear)
</span><span class="noop">    test4.refmonth = &#39;November&#39;
</span><span class="noop">    print(oct.wateryear, nov.wateryear)
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">:class:`Period` objects can be directly initialized via
</span><span class="noop">:class:`~datetime.timedelta` objects, e.g.::
</span><span class="noop">
</span><span class="noop">    from datetime import timedelta
</span><span class="noop">    from hydpy.core.timetools import Period
</span><span class="noop">
</span><span class="noop">    # Initialize a `timedelta` object...
</span><span class="noop">    timedelta_object = timedelta(1, 0)
</span><span class="noop">    # ...and use it to initialise a `Period` object
</span><span class="noop">    period = Period(timedelta_object)
</span><span class="noop">
</span><span class="noop">Alternatively, one can initialize from :class:`str` objects.  These must
</span><span class="noop">consist of some characters defining an integer value directly followed by
</span><span class="noop">a single character defining the unit::
</span><span class="noop">
</span><span class="noop">    # 30 seconds:
</span><span class="noop">    period = Period(&#39;30s&#39;)
</span><span class="noop">    # 5 minutes:
</span><span class="noop">    period = Period(&#39;5m&#39;)
</span><span class="noop">    # 6 hours:
</span><span class="noop">    period = Period(&#39;6h&#39;)
</span><span class="noop">    # 1 day:
</span><span class="noop">    period = Period(&#39;1d&#39;)
</span><span class="noop">
</span><span class="noop">:class:`Period` always determines the unit leading to the most legigible
</span><span class="noop">print out::
</span><span class="noop">
</span><span class="noop">    # Print using the unit leading to the smallest integer value:
</span><span class="noop">    print(period)
</span><span class="noop">    # Alternatively, the values of all time units are directly available as
</span><span class="noop">    # `float` objects:
</span><span class="noop">    print(period.days)
</span><span class="noop">    print(period.hours)
</span><span class="noop">    print(period.minutes)
</span><span class="noop">    print(period.seconds)
</span><span class="noop">
</span><span class="noop">If considered useful, logic and arithmetic operations are supported.
</span><span class="noop">Some examples::
</span><span class="noop">
</span><span class="noop">    # Determine the period length between two dates.
</span><span class="noop">    wholeperiod = date2 - date1
</span><span class="noop">    print(wholeperiod)
</span><span class="noop">    # Determine, how often one period fits into the other.
</span><span class="noop">    print(wholeperiod / period)
</span><span class="noop">    # Get one sixths of period:
</span><span class="noop">    print(period / 6)
</span><span class="noop">    # But when trying to get one seventh of period:
</span><span class="noop">    print(period / 7)
</span><span class="noop">    # Double a period duration.
</span><span class="noop">    period *= 2
</span><span class="noop">    print(period)
</span><span class="noop">    # Shift a date.
</span><span class="noop">    date1 -= period
</span><span class="noop">    # Note that the modulo operator returns a boolean value, indicating
</span><span class="noop">    # whether the remainder is zero or not:
</span><span class="noop">    # print(Period(&#39;1d&#39;) % Period(&#39;12h&#39;))
</span><span class="noop">    # print(Period(&#39;1d&#39;) % Period(&#39;13h&#39;))
</span><span class="noop">    # Following the same line of thinking, floor division leads to the
</span><span class="noop">    # opposite results:
</span><span class="noop">    # print(Period(&#39;1d&#39;) // Period(&#39;12h&#39;))
</span><span class="noop">    # print(Period(&#39;1d&#39;) // Period(&#39;13h&#39;))
</span><span class="noop">    # Compare dates or periods.
</span><span class="noop">    print(date1 &lt; date2)
</span><span class="noop">    print(min(date1, date2))
</span><span class="noop">    print(period == wholeperiod)
</span><span class="noop">    # Operations on initialisation arguments are supported.
</span><span class="noop">    print(date1 + &#39;5m&#39;)
</span><span class="noop">    print(period != &#39;12h&#39;)
</span><span class="noop">
</span><span class="noop">Note that :class:`Date` and :class:`Period` objects are mutable.  Use their
</span><span class="noop">`copy` methods whenever this might lead to unintentional results::
</span><span class="noop">
</span><span class="noop">    # A date example:
</span><span class="noop">    date1 = Date(&#39;1996.11.01 00:00&#39;)
</span><span class="noop">    date2 = date1
</span><span class="noop">    date3 = date1.copy()
</span><span class="noop">    date1.year = 1997
</span><span class="noop">    print(date1, date2, date3)
</span><span class="noop">    # A period example:
</span><span class="noop">    period1 = Period(&#39;1h&#39;)
</span><span class="noop">    period2 = period1
</span><span class="noop">    period3 = period1.copy()
</span><span class="noop">    period1 -= &#39;2h&#39;
</span><span class="noop">    print(period1, period2, period3)
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">Timegrid and Timegrids
</span><span class="noop">======================
</span><span class="noop">
</span><span class="noop">In hydrological modelling, input (and output) data are usually only available
</span><span class="noop">with a certain resolution, which also determines the possible resolution
</span><span class="noop">of the actual simulation.  This is reflected by the class :class:`Timegrid`,
</span><span class="noop">which represents the first and the last date of e.g. a simulation period as
</span><span class="noop">well as the intermediate dates. A :class:`Timegrid` object is initialized
</span><span class="noop">by defining its first date, its last date and its stepsize::
</span><span class="noop">
</span><span class="noop">    from hydpy.core.timetools import Date, Period, Timegrid
</span><span class="noop">
</span><span class="noop">    # Either pass the proper attributes directly...
</span><span class="noop">    firstdate = Date(&#39;1996.11.01&#39;)
</span><span class="noop">    lastdate = Date(&#39;1997.11.01&#39;)
</span><span class="noop">    stepsize = Period(&#39;1d&#39;)
</span><span class="noop">    timegrid_sim = Timegrid(firstdate, lastdate, stepsize)
</span><span class="noop">    # ...or pass their initialization arguments:
</span><span class="noop">    timegrid_sim = Timegrid(&#39;1996.11.01&#39;, &#39;1997.11.01&#39;, &#39;1d&#39;)
</span><span class="noop">
</span><span class="noop">:class:`Timegrid` provides functionalities to ease and secure the handling
</span><span class="noop">of dates in HydPy. Here some examples::
</span><span class="noop">
</span><span class="noop">    # Retrieve a date via indexing, e.g. the second one:
</span><span class="noop">    date = timegrid_sim[1]
</span><span class="noop">    print(date)
</span><span class="noop">    # Or the other way round, retrieve the index belonging to a date:
</span><span class="noop">    print(timegrid_sim[date])
</span><span class="noop">    # Indexing beyond the ranges of the actual time period is allowed:
</span><span class="noop">    print(timegrid_sim[-366])
</span><span class="noop">    print(timegrid_sim[timegrid_sim[date+&#39;365d&#39;]])
</span><span class="noop">    # Iterate through all time grid points (e.g. to print the first day of
</span><span class="noop">    # each month):
</span><span class="noop">    for date in timegrid_sim:
</span><span class="noop">        if date.day == 1:
</span><span class="noop">            print date
</span><span class="noop">
</span><span class="noop">After doing some changes one should call the :func:`~Timegrid.verify` method::
</span><span class="noop">
</span><span class="noop">    # `verify` keeps silent if everything seems to be alright...
</span><span class="noop">    timegrid_sim.verify()
</span><span class="noop">    # ...but raises an suitable exception otherwise:
</span><span class="noop">    timegrid_sim.firstdate.minute = 30
</span><span class="noop">    timegrid_sim.verify()
</span><span class="noop">
</span><span class="noop">One can check two :class:`Timegrid` instances for equality::
</span><span class="noop">
</span><span class="noop">    # Make a deep copy of the timegrid already existing.
</span><span class="noop">    timegrid_test = timegrid_sim.copy()
</span><span class="noop">    # Test for equality and non-equality.
</span><span class="noop">    print(timegrid_sim == timegrid_test)
</span><span class="noop">    print(timegrid_sim != timegrid_test)
</span><span class="noop">    # Modify one date of the new timegrid.
</span><span class="noop">    timegrid_test.firstdate += &#39;1d&#39;
</span><span class="noop">    # Again, test for equality and non-equality.
</span><span class="noop">    print(timegrid_sim == timegrid_test)
</span><span class="noop">    print(timegrid_sim != timegrid_test)
</span><span class="noop">
</span><span class="noop">Also, one can check if a date or even whole timegrid lies within a span
</span><span class="noop">defined by a :class:`Timegrid` instance::
</span><span class="noop">
</span><span class="noop">    # Define a long timegrid...
</span><span class="noop">    timegrid_long = Timegrid(&#39;1996.11.01&#39;, &#39;2006.11.01&#39;, &#39;1d&#39;)
</span><span class="noop">    # ...and check different dates for lying in the defined time period:
</span><span class="noop">    print(&#39;1996.10.31&#39; in timegrid_long)
</span><span class="noop">    print(&#39;1996.11.01&#39; in timegrid_long)
</span><span class="noop">    print(&#39;1996.11.02&#39; in timegrid_long)
</span><span class="noop">    # For dates not alligned on the grid `False` is returned:
</span><span class="noop">    print(&#39;1996.11.01 12:00&#39; in timegrid_long)
</span><span class="noop">
</span><span class="noop">    # Now define a timegrid containing only the first year of the long one:
</span><span class="noop">    timegrid_short = Timegrid(&#39;1996.11.01&#39;, &#39;1997.11.01&#39;, &#39;1d&#39;)
</span><span class="noop">    # Check which timegrid is contained by the other:
</span><span class="noop">    print(timegrid_short in timegrid_long)
</span><span class="noop">    print(timegrid_long in timegrid_short)
</span><span class="noop">    # For timegrids with different stepsizes `False` is returned:
</span><span class="noop">    timegrid_short.stepsize = Period(&#39;1h&#39;)
</span><span class="noop">    print(timegrid_short in timegrid_long)
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">The HydPy framework distinguishes three `time frames`, one associated with the
</span><span class="noop">input date available on disk (`data`), one associated, with the initialisation
</span><span class="noop">period (`init`) and and one associated with the actual simulation period
</span><span class="noop">(`sim`).  Each time frame is represented by a single :class:`Timegrid` object
</span><span class="noop">and all together are handled by one class :class:`Timegrids` object.
</span><span class="noop">
</span><span class="noop">There is usually only one :class:`Timegrids` object required within each
</span><span class="noop">HydPy project.  It is automatically added to the module
</span><span class="noop">:mod:`~hydpy.core.pub` during the initialization of a
</span><span class="noop">:class:`~hydpy.core.hydpy.HydPy` object::
</span><span class="noop">
</span><span class="noop">    from hydpy import HydPy
</span><span class="noop">    from hydpy.core import pub
</span><span class="noop">
</span><span class="noop">    hydpy = HydPy(&#39;tutorial_1&#39;)
</span><span class="noop">    print(pub.timegrids)
</span><span class="noop">
</span><span class="noop">Some examples on the usage of this :class:`Timegrids` instance::
</span><span class="noop">
</span><span class="noop">    # Get the factor to convert `mm/stepsize` to m^3/s for an area of 36 km^2:
</span><span class="noop">    print(pub.timegrids.qfactor(36.))
</span><span class="noop">    # Get the index of the first values of the `data time frame` which belong
</span><span class="noop">    # to the `initialisation time frame`.
</span><span class="noop">    print(pub.timegrids.data[pub.timegrids.init.firstdate])
</span><span class="noop">    # Or, as a similar example, get the index of the first values of the
</span><span class="noop">    # `initialisation time frame` which belong to the `simulation time frame`.
</span><span class="noop">    print(pub.timegrids.init[pub.timegrids.sim.firstdate])
</span><span class="noop">
</span><span class="noop">Notice, that the latter index is zero.  This is due to the simulation time
</span><span class="noop">frame beeing identical with the initialisation time frame, if not specified
</span><span class="noop">otherwise in the main control file or by manually changing the simulation time
</span><span class="noop">frame.
</span><span class="noop">
</span><span class="noop">Each manual change should be followed by calling the
</span><span class="noop">:func:`~Timegrids.verify` method, which calls the :func:`~Timegrid.verify`
</span><span class="noop">method of the single :class:`Timegrid` instances and performs some additional
</span><span class="noop">tests::
</span><span class="noop">
</span><span class="noop">    # Postponing the `simulation time frame` one stepsize is fine...
</span><span class="noop">    pub.timegrids.sim.firstdate += pub.timegrids.stepsize
</span><span class="noop">    pub.timegrids.verify()
</span><span class="noop">    # ...but shifting it outside the `initialisation time frame` or setting
</span><span class="noop">    # it in  between the time grid points results in an error:
</span><span class="noop">    pub.timegrids.sim.firstdate -= 2*pub.timegrids.stepsize
</span><span class="noop">    pub.timegrids.verify()
</span><span class="noop">    pub.timegrids.sim.firstdate += pub.timegrids.stepsize
</span><span class="noop">    pub.timegrids.sim.firstdate.minute = 1
</span><span class="noop">    pub.timegrids.verify()
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">To facilitate printing to configuration files, both classes :class:`Timegrid`
</span><span class="noop">and :class:`Timegrids` allow for a extended canonical string representations
</span><span class="noop">of their objects::
</span><span class="noop">
</span><span class="noop">    # The string representation is generally formated with indentation.
</span><span class="noop">    print(repr(pub.timegrids.data))
</span><span class="noop">    print(repr(pub.timegrids))
</span><span class="noop">    # The class specific `assignrepr` methods allow for inserting assignements.
</span><span class="noop">    print(pub.timegrids.data.assignrepr(&#39;timegrid_data = &#39;))
</span><span class="noop">    print(pub.timegrids.assignrepr(&#39;timegrids_all = &#39;))
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">Details
</span><span class="noop">=======
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import datetime
</span><span class="hit">import copy
</span><span class="hit">import time
</span><span class="hit">import calendar
</span><span class="hit">import collections
</span><span class="noop"># ...from third party packages
</span><span class="hit">import numpy
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core import objecttools
</span><span class="noop">
</span><span class="noop"># The import of `_strptime` is not thread save.  The following call of
</span><span class="noop"># `strptime` is supposed to prevent possible problems arising from this bug.
</span><span class="hit">time.strptime(&#39;1999&#39;, &#39;%Y&#39;)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Date(object):
</span><span class="noop">    &#34;&#34;&#34;Handles a single date.
</span><span class="noop">
</span><span class="noop">    Argument:
</span><span class="noop">        * date (:class:`~datetime.datetime` or :class:`str`): Initialization
</span><span class="noop">          date.
</span><span class="noop">
</span><span class="noop">    Attribute:
</span><span class="noop">        * datetime (:class:`~datetime.datetime`): The core of :class:`Date`.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="noop">    # These are the so far accepted date format strings.
</span><span class="hit">    _formatstrings = {&#39;os&#39;: &#39;%Y_%m_%d_%H_%M_%S&#39;,
</span><span class="noop">                      &#39;iso&#39;: &#39;%Y.%m.%d %H:%M:%S&#39;,
</span><span class="noop">                      &#39;din&#39;: &#39;%d.%m.%Y %H:%M:%S&#39;}
</span><span class="noop">    # The first month of the hydrological year (e.g. November in Germany)
</span><span class="hit">    _firstmonth_wateryear = 11
</span><span class="noop">
</span><span class="hit">    def __init__(self, date):
</span><span class="hit">        self.datetime = None
</span><span class="hit">        self._style = None
</span><span class="hit">        if isinstance(date, Date):
</span><span class="hit">            self.datetime = date.datetime
</span><span class="hit">        elif isinstance(date, datetime.datetime):
</span><span class="hit">            if date.microsecond:
</span><span class="miss">                raise ValueError(&#39;For `Date` instances, the microsecond must &#39;
</span><span class="noop">                                 &#39;be `0`.  For the given `datetime` object, &#39;
</span><span class="noop">                                 &#39;it is `%d` instead.&#39; % date.microsecond)
</span><span class="hit">            self.datetime = date
</span><span class="hit">        elif isinstance(date, str):
</span><span class="hit">            self._initfromstr(date)
</span><span class="hit">        elif isinstance(date, TOY):
</span><span class="hit">            self.datetime = datetime.datetime(2000,
</span><span class="noop">                                              date.month, date.day, date.hour,
</span><span class="noop">                                              date.minute, date.second)
</span><span class="noop">        else:
</span><span class="hit">            raise TypeError(&#39;The supplied argument must be either an &#39;
</span><span class="noop">                            &#39;instance of `datetime.datetime` or of `str`.  &#39;
</span><span class="noop">                            &#39;The given arguments type is %s.&#39; % type(date))
</span><span class="noop">
</span><span class="hit">    def _initfromstr(self, date):
</span><span class="noop">        &#34;&#34;&#34;Try to initialize `datetime` from the given :class:`str` instance.
</span><span class="noop">
</span><span class="noop">        Arguments:
</span><span class="noop">            * date (:class:`str`): Initialization date.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        for (style, string) in self._formatstrings.items():
</span><span class="hit">            for idx in range(4):
</span><span class="hit">                try:
</span><span class="hit">                    self.datetime = datetime.datetime.strptime(date, string)
</span><span class="hit">                    self._style = style
</span><span class="hit">                except ValueError:
</span><span class="hit">                    string = string[:-3]
</span><span class="hit">        if self.datetime is None:
</span><span class="hit">            raise ValueError(&#39;Date could not be identified out of the given &#39;
</span><span class="noop">                             &#39;string %s.  The available formats are %s.&#39;
</span><span class="noop">                             % (date, self._formatstrings))
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def fromarray(cls, array):
</span><span class="noop">        &#34;&#34;&#34;Returns a :class:`Date` instance based on date information (year,
</span><span class="noop">        month, day, hour, minute, second) stored as the first entries of the
</span><span class="noop">        successive rows of a :class:`~numpy.ndarray` object.&#34;&#34;&#34;
</span><span class="miss">        intarray = numpy.array(array, dtype=int)
</span><span class="miss">        for idx in range(1, array.ndim):
</span><span class="miss">            intarray = intarray[:, 0]
</span><span class="miss">        return cls(datetime.datetime(*intarray))
</span><span class="noop">
</span><span class="hit">    def toarray(self):
</span><span class="noop">        &#34;&#34;&#34;Returns a 1-dimensional :mod:`numpy` :class:`~numpy.ndarray` with
</span><span class="noop">        six entries defining the actual date (year, month, day, hour, minute,
</span><span class="noop">        second).&#34;&#34;&#34;
</span><span class="miss">        return numpy.array([self.year, self.month, self.day, self.hour,
</span><span class="noop">                            self.minute, self.second], dtype=float)
</span><span class="noop">
</span><span class="hit">    def _getrefmonth(self):
</span><span class="noop">        &#34;&#34;&#34;First month of the hydrological year. The default value is 11
</span><span class="noop">        (November which is the german reference month). Setting it e.g. to 10
</span><span class="noop">        (October is another common reference month many different countries)
</span><span class="noop">        affects all :class:`Date` instances.&#34;&#34;&#34;
</span><span class="hit">        return Date._firstmonth_wateryear
</span><span class="noop">
</span><span class="hit">    def _setrefmonth(self, value):
</span><span class="hit">        try:
</span><span class="hit">            Date._firstmonth_wateryear = int(value)
</span><span class="hit">        except ValueError:
</span><span class="hit">            string = str(value)[:3].lower()
</span><span class="hit">            try:
</span><span class="hit">                months = [&#39;jan&#39;, &#39;feb&#39;, &#39;mar&#39;, &#39;apr&#39;, &#39;may&#39;, &#39;jun&#39;,
</span><span class="noop">                          &#39;jul&#39;, &#39;aug&#39;, &#39;sew&#39;, &#39;oct&#39;, &#39;nov&#39;, &#39;dec&#39;]
</span><span class="hit">                Date._firstmonth_wateryear = months.index(string) + 1
</span><span class="hit">            except ValueError:
</span><span class="hit">                raise ValueError(&#39;The given value `%s` cannot be interpreted &#39;
</span><span class="noop">                                 &#39;as a month. Supply e.g. a number between 1 &#39;
</span><span class="noop">                                 &#39;and 12 or a month name instead.&#39; % value)
</span><span class="noop">
</span><span class="hit">    refmonth = property(_getrefmonth, _setrefmonth)
</span><span class="noop">
</span><span class="hit">    def _getstyle(self):
</span><span class="noop">        &#34;&#34;&#34;Date format style to be applied in printing.&#34;&#34;&#34;
</span><span class="hit">        if self._style is None:
</span><span class="hit">            return &#39;iso&#39;
</span><span class="noop">        else:
</span><span class="hit">            return self._style
</span><span class="noop">
</span><span class="hit">    def _setstyle(self, style):
</span><span class="hit">        if style in self._formatstrings:
</span><span class="hit">            self._style = style
</span><span class="noop">        else:
</span><span class="miss">            self._style = None
</span><span class="miss">            raise KeyError(&#39;Date format style `%s` is not available.&#39; % style)
</span><span class="noop">
</span><span class="hit">    style = property(_getstyle, _setstyle)
</span><span class="noop">
</span><span class="hit">    def _setthing(self, thing, value):
</span><span class="noop">        &#34;&#34;&#34;Convenience method for `_setyear`, `_setmonth`...&#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            value = int(value)
</span><span class="hit">        except (TypeError, ValueError):
</span><span class="hit">            raise ValueError(&#39;Changing the %s of a `Date` instance is only &#39;
</span><span class="noop">                             &#39;allowed via numbers, but the given value `%s` &#39;
</span><span class="noop">                             &#39;is of type `%s` instead.&#39;
</span><span class="noop">                             % (thing, value, type(value)))
</span><span class="hit">        kwargs = {}
</span><span class="hit">        for unit in (&#39;year&#39;, &#39;month&#39;, &#39;day&#39;, &#39;hour&#39;, &#39;minute&#39;, &#39;second&#39;):
</span><span class="hit">            kwargs[unit] = getattr(self, unit)
</span><span class="hit">        kwargs[thing] = value
</span><span class="hit">        self.datetime = datetime.datetime(**kwargs)
</span><span class="noop">
</span><span class="hit">    def _getsecond(self):
</span><span class="noop">        &#34;&#34;&#34;The actual second.&#34;&#34;&#34;
</span><span class="hit">        return self.datetime.second
</span><span class="noop">
</span><span class="hit">    def _setsecond(self, second):
</span><span class="hit">        self._setthing(&#39;second&#39;, second)
</span><span class="noop">
</span><span class="hit">    second = property(_getsecond, _setsecond)
</span><span class="noop">
</span><span class="hit">    def _getminute(self):
</span><span class="noop">        &#34;&#34;&#34;The actual minute.&#34;&#34;&#34;
</span><span class="hit">        return self.datetime.minute
</span><span class="noop">
</span><span class="hit">    def _setminute(self, minute):
</span><span class="hit">        self._setthing(&#39;minute&#39;, minute)
</span><span class="noop">
</span><span class="hit">    minute = property(_getminute, _setminute)
</span><span class="noop">
</span><span class="hit">    def _gethour(self):
</span><span class="noop">        &#34;&#34;&#34;The actual hour.&#34;&#34;&#34;
</span><span class="hit">        return self.datetime.hour
</span><span class="noop">
</span><span class="hit">    def _sethour(self, hour):
</span><span class="hit">        self._setthing(&#39;hour&#39;, hour)
</span><span class="noop">
</span><span class="hit">    hour = property(_gethour, _sethour)
</span><span class="noop">
</span><span class="hit">    def _getday(self):
</span><span class="noop">        &#34;&#34;&#34;The actual day.&#34;&#34;&#34;
</span><span class="hit">        return self.datetime.day
</span><span class="noop">
</span><span class="hit">    def _setday(self, day):
</span><span class="hit">        self._setthing(&#39;day&#39;, day)
</span><span class="noop">
</span><span class="hit">    day = property(_getday, _setday)
</span><span class="noop">
</span><span class="hit">    def _getmonth(self):
</span><span class="noop">        &#34;&#34;&#34;The actual month.&#34;&#34;&#34;
</span><span class="hit">        return self.datetime.month
</span><span class="noop">
</span><span class="hit">    def _setmonth(self, month):
</span><span class="hit">        self._setthing(&#39;month&#39;, month)
</span><span class="noop">
</span><span class="hit">    month = property(_getmonth, _setmonth)
</span><span class="noop">
</span><span class="hit">    def _getyear(self):
</span><span class="noop">        &#34;&#34;&#34;The actual year.&#34;&#34;&#34;
</span><span class="hit">        return self.datetime.year
</span><span class="noop">
</span><span class="hit">    def _setyear(self, year):
</span><span class="hit">        self._setthing(&#39;year&#39;, year)
</span><span class="noop">
</span><span class="hit">    year = property(_getyear, _setyear)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def wateryear(self):
</span><span class="noop">        &#34;&#34;&#34;The actual hydrological year according selected reference month.&#34;&#34;&#34;
</span><span class="hit">        if self.month &lt; self._firstmonth_wateryear:
</span><span class="hit">            return self.year
</span><span class="noop">        else:
</span><span class="hit">            return self.year + 1
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def dayofyear(self):
</span><span class="noop">        &#34;&#34;&#34;Day of year as an integer value.&#34;&#34;&#34;
</span><span class="hit">        return self.datetime.timetuple().tm_yday
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def leapyear(self):
</span><span class="noop">        &#34;&#34;&#34;Return whether the actual date falls in a leap year or not.&#34;&#34;&#34;
</span><span class="hit">        year = self.year
</span><span class="hit">        return (((year % 4) == 0) and
</span><span class="noop">                (((year % 100) != 0) or ((year % 400) == 0)))
</span><span class="noop">
</span><span class="hit">    def copy(self):
</span><span class="noop">        &#34;&#34;&#34;Returns a deep copy of the :class:`Date` instance.&#34;&#34;&#34;
</span><span class="hit">        return copy.deepcopy(self)
</span><span class="noop">
</span><span class="hit">    def __add__(self, other):
</span><span class="hit">        new = Date(self.datetime + Period(other).timedelta)
</span><span class="hit">        new.style = self.style
</span><span class="hit">        return new
</span><span class="noop">
</span><span class="hit">    def __iadd__(self, other):
</span><span class="hit">        self.datetime += Period(other).timedelta
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def __sub__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            return Period(self.datetime-Date(other).datetime)
</span><span class="hit">        except (TypeError, ValueError):
</span><span class="hit">            try:
</span><span class="hit">                new = Date(self.datetime-Period(other).timedelta)
</span><span class="hit">                new.style = self.style
</span><span class="hit">                return new
</span><span class="miss">            except (TypeError, ValueError):
</span><span class="miss">                raise Exception(&#39;Object `%s` of type `%s` can not be &#39;
</span><span class="noop">                                &#39;substracted from a `Date` instance.&#39;
</span><span class="noop">                                % (str(other), type(other)))
</span><span class="noop">
</span><span class="hit">    def __isub__(self, other):
</span><span class="hit">        self.datetime -= Period(other).timedelta
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def __lt__(self, other):
</span><span class="hit">        return self.datetime &lt; Date(other).datetime
</span><span class="noop">
</span><span class="hit">    def __le__(self, other):
</span><span class="hit">        return self.datetime &lt;= Date(other).datetime
</span><span class="noop">
</span><span class="hit">    def __eq__(self, other):
</span><span class="hit">        return self.datetime == Date(other).datetime
</span><span class="noop">
</span><span class="hit">    def __ne__(self, other):
</span><span class="hit">        return self.datetime != Date(other).datetime
</span><span class="noop">
</span><span class="hit">    def __gt__(self, other):
</span><span class="hit">        return self.datetime &gt; Date(other).datetime
</span><span class="noop">
</span><span class="hit">    def __ge__(self, other):
</span><span class="hit">        return self.datetime &gt;= Date(other).datetime
</span><span class="noop">
</span><span class="hit">    def string(self, style):
</span><span class="noop">        &#34;&#34;&#34;Returns a :class:`str` object representing the actual date in
</span><span class="noop">        accordance with the given style.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        retain = self.style
</span><span class="hit">        try:
</span><span class="hit">            self.style = style
</span><span class="hit">            return str(self)
</span><span class="noop">        finally:
</span><span class="hit">            self.style = retain
</span><span class="noop">
</span><span class="hit">    def __str__(self):
</span><span class="hit">        return self.datetime.strftime(self._formatstrings[self.style])
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="miss">        return &#39;Date(&#34;%s&#34;)&#39; % str(self)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Period(object):
</span><span class="noop">    &#34;&#34;&#34;Handles the length of a single time period.
</span><span class="noop">
</span><span class="noop">    Argument:
</span><span class="noop">        * period (:class:`~datetime.timedelta` or :class:`str`): Period length.
</span><span class="noop">
</span><span class="noop">    Attribute:
</span><span class="noop">        * datetime (:class:`~datetime.timedelta`): The core of :class:`Period`.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    def __init__(self, period):
</span><span class="hit">        self.timedelta = None
</span><span class="hit">        self._unit = None
</span><span class="hit">        if isinstance(period, Period):
</span><span class="hit">            self.timedelta = period.timedelta
</span><span class="hit">        elif isinstance(period, datetime.timedelta):
</span><span class="hit">            if period.microseconds:
</span><span class="miss">                raise ValueError(&#39;For `Period` instances, microseconds must &#39;
</span><span class="noop">                                 &#39;`0`.  For the given `timedelta` object, it &#39;
</span><span class="noop">                                 &#39;is `%d` instead.&#39; % period.microseconds)
</span><span class="hit">            self.timedelta = period
</span><span class="hit">        elif isinstance(period, str):
</span><span class="hit">            self._initfromstr(period)
</span><span class="noop">        else:
</span><span class="hit">            raise ValueError(&#39;The supplied argument must be either an &#39;
</span><span class="noop">                             &#39;instance of `datetime.timedelta` or `str`.  &#39;
</span><span class="noop">                             &#39;The given arguments type is %s.&#39;
</span><span class="noop">                             % objecttools.classname(period))
</span><span class="noop">
</span><span class="hit">    def _initfromstr(self, period):
</span><span class="noop">        &#34;&#34;&#34;Try to initialize `timedelta` from the given :class:`str` instance.
</span><span class="noop">
</span><span class="noop">        Arguments:
</span><span class="noop">            * period (:class:`str`): Period length.
</span><span class="noop">         &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            number = int(period[:-1])
</span><span class="miss">        except ValueError:
</span><span class="miss">            raise ValueError(&#39;All characters of the given period string, &#39;
</span><span class="noop">                             &#39;except the last one which represents the unit, &#39;
</span><span class="noop">                             &#39;need to define a whole decimal number.  Instead,&#39;
</span><span class="noop">                             &#39; these characters are `%s`.&#39; % period[:-1])
</span><span class="hit">        self._unit = period[-1]
</span><span class="hit">        if self._unit not in (&#39;d&#39;, &#39;h&#39;, &#39;m&#39;, &#39;s&#39;):
</span><span class="miss">            raise ValueError(&#39;The last character of the given period string &#39;
</span><span class="noop">                             &#39;needs to be either `d` (days), `h` (hours) or &#39;
</span><span class="noop">                             &#39;`m` (minutes).  Instead, the last character is &#39;
</span><span class="noop">                             &#39;`%s`.&#39; % self._unit)
</span><span class="hit">        if self._unit == &#39;d&#39;:
</span><span class="hit">            self.timedelta = datetime.timedelta(number, 0)
</span><span class="hit">        elif self._unit == &#39;h&#39;:
</span><span class="hit">            self.timedelta = datetime.timedelta(0, number*3600)
</span><span class="hit">        elif self._unit == &#39;m&#39;:
</span><span class="hit">            self.timedelta = datetime.timedelta(0, number*60)
</span><span class="hit">        elif self._unit == &#39;s&#39;:
</span><span class="hit">            self.timedelta = datetime.timedelta(0, number)
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def fromseconds(cls, seconds):
</span><span class="noop">        &#34;&#34;&#34;Returns a :class:`Period` instance based on a given number of
</span><span class="noop">        seconds.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            seconds = int(seconds)
</span><span class="miss">        except TypeError:
</span><span class="miss">            seconds = int(seconds.flatten()[0])
</span><span class="hit">        return cls(datetime.timedelta(0, int(seconds)))
</span><span class="noop">
</span><span class="hit">    def _guessunit(self):
</span><span class="noop">        &#34;&#34;&#34;Guess the unit of the period as the largest one, which results in
</span><span class="noop">        an integer duration.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if not self.days % 1:
</span><span class="hit">            return &#39;d&#39;
</span><span class="hit">        elif not self.hours % 1:
</span><span class="hit">            return &#39;h&#39;
</span><span class="hit">        elif not self.minutes % 1:
</span><span class="hit">            return &#39;m&#39;
</span><span class="hit">        elif not self.seconds % 1:
</span><span class="hit">            return &#39;s&#39;
</span><span class="noop">        else:
</span><span class="miss">            raise ValueError(&#39;The stepsize is not a multiple of one &#39;
</span><span class="noop">                             &#39;second, which is not allowed.&#39;)
</span><span class="noop">
</span><span class="hit">    unit = property(_guessunit)
</span><span class="noop">
</span><span class="hit">    def _getseconds(self):
</span><span class="noop">        &#34;&#34;&#34;Period length in seconds.&#34;&#34;&#34;
</span><span class="hit">        return self.timedelta.total_seconds()
</span><span class="noop">
</span><span class="hit">    seconds = property(_getseconds)
</span><span class="noop">
</span><span class="hit">    def _getminutes(self):
</span><span class="noop">        &#34;&#34;&#34;Period length in minutes.&#34;&#34;&#34;
</span><span class="hit">        return self.seconds / 60
</span><span class="noop">
</span><span class="hit">    minutes = property(_getminutes)
</span><span class="noop">
</span><span class="hit">    def _gethours(self):
</span><span class="noop">        &#34;&#34;&#34;Period length in hours.&#34;&#34;&#34;
</span><span class="hit">        return self.minutes / 60
</span><span class="noop">
</span><span class="hit">    hours = property(_gethours)
</span><span class="noop">
</span><span class="hit">    def _getdays(self):
</span><span class="noop">        &#34;&#34;&#34;Period length in days.&#34;&#34;&#34;
</span><span class="hit">        return self.hours / 24
</span><span class="noop">
</span><span class="hit">    days = property(_getdays)
</span><span class="noop">
</span><span class="hit">    def copy(self):
</span><span class="noop">        &#34;&#34;&#34;Returns a deep copy of the :class:`Period` instance.&#34;&#34;&#34;
</span><span class="hit">        return copy.deepcopy(self)
</span><span class="noop">
</span><span class="hit">    def __add__(self, other):
</span><span class="hit">        try:
</span><span class="hit">            new = Date(Date(other).datetime + self.timedelta)
</span><span class="hit">            new.style = other.style
</span><span class="hit">            return new
</span><span class="hit">        except (TypeError, ValueError):
</span><span class="hit">            try:
</span><span class="hit">                return Period(self.timedelta + Period(other).timedelta)
</span><span class="miss">            except (TypeError, ValueError):
</span><span class="miss">                raise Exception(&#39;Object `%s` of type `%s` can not be &#39;
</span><span class="noop">                                &#39;added to a `Period` instance.&#39;
</span><span class="noop">                                % (str(other), type(other)))
</span><span class="noop">
</span><span class="hit">    def __iadd__(self, other):
</span><span class="hit">        self.timedelta += Period(other).timedelta
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def __sub__(self, other):
</span><span class="miss">        return Period(self.timedelta - Period(other).timedelta)
</span><span class="noop">
</span><span class="hit">    def __isub__(self, other):
</span><span class="hit">        self.timedelta -= Period(other).timedelta
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def __mul__(self, value):
</span><span class="hit">        return Period(self.timedelta * value)
</span><span class="noop">
</span><span class="hit">    def __rmul__(self, value):
</span><span class="hit">        return self * value
</span><span class="noop">
</span><span class="hit">    def __imul__(self, value):
</span><span class="hit">        self.timedelta *= value
</span><span class="hit">        return self
</span><span class="noop">
</span><span class="hit">    def __truediv__(self, other):
</span><span class="hit">        if isinstance(other, int):
</span><span class="hit">            return Period(self.timedelta // other)
</span><span class="noop">        else:
</span><span class="hit">            return self.seconds / Period(other).seconds
</span><span class="noop">
</span><span class="hit">    def __itruediv__(self, value):
</span><span class="hit">        return self / value
</span><span class="noop">
</span><span class="hit">    def __mod__(self, other):
</span><span class="hit">        return (self.seconds % Period(other).seconds) != 0.
</span><span class="noop">
</span><span class="hit">    def __floordiv__(self, other):
</span><span class="hit">        return (self.seconds % Period(other).seconds) == 0.
</span><span class="noop">
</span><span class="hit">    def __lt__(self, other):
</span><span class="hit">        return self.timedelta &lt; Period(other).timedelta
</span><span class="noop">
</span><span class="hit">    def __le__(self, other):
</span><span class="hit">        return self.timedelta &lt;= Period(other).timedelta
</span><span class="noop">
</span><span class="hit">    def __eq__(self, other):
</span><span class="hit">        return self.timedelta == Period(other).timedelta
</span><span class="noop">
</span><span class="hit">    def __ne__(self, other):
</span><span class="hit">        return self.timedelta != Period(other).timedelta
</span><span class="noop">
</span><span class="hit">    def __gt__(self, other):
</span><span class="hit">        return self.timedelta &gt; Period(other).timedelta
</span><span class="noop">
</span><span class="hit">    def __ge__(self, other):
</span><span class="hit">        return self.timedelta &gt;= Period(other).timedelta
</span><span class="noop">
</span><span class="hit">    def __str__(self):
</span><span class="hit">        if self.unit == &#39;d&#39;:
</span><span class="hit">            return &#39;%dd&#39; % self.days
</span><span class="hit">        elif self.unit == &#39;h&#39;:
</span><span class="hit">            return &#39;%dh&#39; % self.hours
</span><span class="hit">        elif self.unit == &#39;m&#39;:
</span><span class="hit">            return &#39;%dm&#39; % self.minutes
</span><span class="miss">        elif self.unit == &#39;s&#39;:
</span><span class="miss">            return &#39;%ds&#39; % self.seconds
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        return &#39;Period(&#34;%s&#34;)&#39; % str(self)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Timegrid(object):
</span><span class="noop">    &#34;&#34;&#34;Handle a time period defined by to dates and a step size in between.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self, firstdate, lastdate, stepsize):
</span><span class="hit">        self._firstdate = None
</span><span class="hit">        self._lastdate = None
</span><span class="hit">        self._stepsize = None
</span><span class="hit">        self.firstdate = firstdate
</span><span class="hit">        self.lastdate = lastdate
</span><span class="hit">        self.stepsize = stepsize
</span><span class="hit">        self.verify()
</span><span class="noop">
</span><span class="hit">    def _getfirstdate(self):
</span><span class="hit">        return self._firstdate
</span><span class="noop">
</span><span class="hit">    def _setfirstdate(self, firstdate):
</span><span class="hit">        self._firstdate = Date(firstdate)
</span><span class="noop">
</span><span class="hit">    firstdate = property(_getfirstdate, _setfirstdate)
</span><span class="noop">
</span><span class="hit">    def _getlastdate(self):
</span><span class="hit">        return self._lastdate
</span><span class="noop">
</span><span class="hit">    def _setlastdate(self, lastdate):
</span><span class="hit">        self._lastdate = Date(lastdate)
</span><span class="noop">
</span><span class="hit">    lastdate = property(_getlastdate, _setlastdate)
</span><span class="noop">
</span><span class="hit">    def _getstepsize(self):
</span><span class="hit">        return self._stepsize
</span><span class="noop">
</span><span class="hit">    def _setstepsize(self, stepsize):
</span><span class="hit">        self._stepsize = Period(stepsize)
</span><span class="noop">
</span><span class="hit">    stepsize = property(_getstepsize, _setstepsize)
</span><span class="noop">
</span><span class="hit">    @classmethod
</span><span class="noop">    def fromarray(cls, array):
</span><span class="noop">        &#34;&#34;&#34;Returns a :class:`Timegrid` instance based on two date and one
</span><span class="noop">        period information stored in the first 13 rows of a
</span><span class="noop">        :class:`~numpy.ndarray` object.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        try:
</span><span class="miss">            return cls(firstdate=Date.fromarray(array[:6]),
</span><span class="noop">                       lastdate=Date.fromarray(array[6:12]),
</span><span class="noop">                       stepsize=Period.fromseconds(array[12]))
</span><span class="miss">        except IndexError:
</span><span class="miss">            raise IndexError(&#39;To define a Timegrid instance via an array, 13 &#39;
</span><span class="noop">                             &#39;numbers are required.  However, the given array &#39;
</span><span class="noop">                             &#39;consist of %d entries/rows only.&#39; % len(array))
</span><span class="noop">
</span><span class="hit">    def toarray(self):
</span><span class="noop">        &#34;&#34;&#34;Returns a 1-dimensional :mod:`numpy` :class:`~numpy.ndarray` with
</span><span class="noop">        thirteen entries first defining the start date, secondly defining the
</span><span class="noop">        end date and thirdly the step size.&#34;&#34;&#34;
</span><span class="miss">        values = numpy.empty(13, dtype=float)
</span><span class="miss">        values[:6] = self.firstdate.toarray()
</span><span class="miss">        values[6:12] = self.lastdate.toarray()
</span><span class="miss">        values[12] = self.stepsize.seconds
</span><span class="miss">        return values
</span><span class="noop">
</span><span class="hit">    def verify(self):
</span><span class="noop">        &#34;&#34;&#34;Raise an :class:`~exceptions.ValueError` if the dates or the
</span><span class="noop">        step size of the time frame are inconsistent.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if self.firstdate &gt;= self.lastdate:
</span><span class="hit">            raise ValueError(&#39;Unplausible timegrid. The first given &#39;
</span><span class="noop">                             &#39;date %s, the second given date is %s. &#39;
</span><span class="noop">                             % (self.firstdate, self.lastdate))
</span><span class="hit">        if (self.lastdate-self.firstdate) % self.stepsize:
</span><span class="hit">            raise ValueError(&#39;Unplausible timegrid. The period span &#39;
</span><span class="noop">                             &#39;between the given dates %s and %s is not &#39;
</span><span class="noop">                             &#39;a multiple of the given step size %s.&#39; %
</span><span class="noop">                             (self.firstdate, self.lastdate, self.stepsize))
</span><span class="noop">
</span><span class="hit">    def copy(self):
</span><span class="noop">        &#34;&#34;&#34;Returns a deep copy of the :class:`Timegrid` instance.&#34;&#34;&#34;
</span><span class="hit">        return copy.deepcopy(self)
</span><span class="noop">
</span><span class="hit">    def __len__(self):
</span><span class="hit">        return int((self.lastdate-self.firstdate) / self.stepsize)
</span><span class="noop">
</span><span class="hit">    def __getitem__(self, key):
</span><span class="hit">        if isinstance(key, int):
</span><span class="hit">            return Date(self.firstdate + key*self.stepsize)
</span><span class="noop">        else:
</span><span class="hit">            key = Date(key)
</span><span class="hit">            index = (key-self.firstdate) / self.stepsize
</span><span class="hit">            if index % 1.:
</span><span class="hit">                raise ValueError(&#39;The given date `%s` is not properly &#39;
</span><span class="noop">                                 &#39;alligned on the indexed timegrid.&#39; % key)
</span><span class="noop">            else:
</span><span class="hit">                return int(index)
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="hit">        date = self.firstdate.copy()
</span><span class="hit">        while date &lt; self.lastdate:
</span><span class="hit">            yield date
</span><span class="hit">            date = date + self.stepsize
</span><span class="noop">
</span><span class="hit">    def _containsdate(self, date):
</span><span class="hit">        date = Date(date)
</span><span class="hit">        return ((self.firstdate &lt;= date &lt;= self.lastdate) and
</span><span class="noop">                ((date-self.firstdate) // self.stepsize))
</span><span class="noop">
</span><span class="hit">    def _containstimegrid(self, timegrid):
</span><span class="hit">        return (self._containsdate(timegrid.firstdate) and
</span><span class="noop">                self._containsdate(timegrid.lastdate) and
</span><span class="noop">                (timegrid.stepsize == self.stepsize))
</span><span class="noop">
</span><span class="hit">    def __contains__(self, other):
</span><span class="hit">        if isinstance(other, Timegrid):
</span><span class="hit">            return self._containstimegrid(other)
</span><span class="noop">        else:
</span><span class="hit">            return self._containsdate(other)
</span><span class="noop">
</span><span class="hit">    def __eq__(self, other):
</span><span class="hit">        return ((self.firstdate == other.firstdate) and
</span><span class="noop">                (self.lastdate == other.lastdate) and
</span><span class="noop">                (self.stepsize == other.stepsize))
</span><span class="noop">
</span><span class="hit">    def __ne__(self, other):
</span><span class="hit">        return ((self.firstdate != other.firstdate) or
</span><span class="noop">                (self.lastdate != other.lastdate) or
</span><span class="noop">                (self.stepsize != other.stepsize))
</span><span class="noop">
</span><span class="hit">    def __str__(self):
</span><span class="miss">        return (&#39;from %s to %s in %s steps&#39;
</span><span class="noop">                % (self.firstdate, self.lastdate, self.stepsize))
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        return self.assignrepr(&#39;&#39;)
</span><span class="noop">
</span><span class="hit">    def assignrepr(self, prefix):
</span><span class="noop">        &#34;&#34;&#34;Return a :func:`repr` string with an prefixed assignement.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * prefix(:class:`str`): Usually something like &#39;x = &#39;.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        skip = len(prefix) + 9
</span><span class="hit">        blanks = &#39; &#39; * skip
</span><span class="hit">        lines = [&#39;%sTimegrid(&#34;%s&#34;,&#39; % (prefix, str(self.firstdate)),
</span><span class="noop">                 &#39;%s&#34;%s&#34;,&#39; % (blanks, str(self.lastdate)),
</span><span class="noop">                 &#39;%s&#34;%s&#34;)&#39; % (blanks, str(self.stepsize))]
</span><span class="hit">        return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class _Timegrids(object):
</span><span class="noop">    &#34;&#34;&#34;Handle all :class:`Timegrid` instances of a HydPy application.
</span><span class="noop">
</span><span class="noop">    Arguments:
</span><span class="noop">        * info (:class:`dict`): Dictionary containing initialisation
</span><span class="noop">          information, usually defined within the main project file.
</span><span class="noop">
</span><span class="noop">    Attributes:
</span><span class="noop">        * data (:class:`Timegrid`): For the available data stored on disk.
</span><span class="noop">        * init (:class:`Timegrid`): For the initialisation period.
</span><span class="noop">        * sim (:class:`Timegrid`): For the simulation period.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self, info):
</span><span class="miss">        args = []
</span><span class="miss">        for key in (&#39;date_startdata&#39;, &#39;date_enddata&#39;, &#39;timestep&#39;):
</span><span class="miss">            try:
</span><span class="miss">                args.append(info[key])
</span><span class="miss">            except KeyError:
</span><span class="miss">                raise KeyError(&#39;The information `%s` is missing. Usually, &#39;
</span><span class="noop">                               &#39;it is defined within the main project file.&#39;
</span><span class="noop">                               % key)
</span><span class="miss">        self.data = Timegrid(*args)
</span><span class="miss">        self.init = Timegrid(info.get(&#39;date_startinit&#39;,
</span><span class="noop">                                      self.data.firstdate.copy()),
</span><span class="noop">                             info.get(&#39;date_endinit&#39;,
</span><span class="noop">                                      self.data.lastdate.copy()),
</span><span class="noop">                             self.data.stepsize)
</span><span class="miss">        self.sim = Timegrid(info.get(&#39;date_startsim&#39;,
</span><span class="noop">                                     self.init.firstdate.copy()),
</span><span class="noop">                            info.get(&#39;date_endsim&#39;,
</span><span class="noop">                                     self.init.lastdate.copy()),
</span><span class="noop">                            self.init.stepsize)
</span><span class="miss">        self.verify()
</span><span class="noop">
</span><span class="hit">    def _getstepsize(self):
</span><span class="noop">        &#34;&#34;&#34;Stepsize of all handled :class:`Timegrid` objects.&#34;&#34;&#34;
</span><span class="miss">        return self.data.stepsize
</span><span class="noop">
</span><span class="hit">    def _setstepsize(self, stepsize):
</span><span class="miss">        stepsize = Period(stepsize)
</span><span class="miss">        for (name, timegrid) in self:
</span><span class="miss">            timegrid.stepsize = stepsize
</span><span class="noop">
</span><span class="hit">    stepsize = property(_getstepsize, _setstepsize)
</span><span class="noop">
</span><span class="hit">    def verify(self):
</span><span class="noop">        &#34;&#34;&#34;Raise an :class:`~exceptions.RuntimeError` it the different
</span><span class="noop">        time grids are inconsistent.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        if self.data.firstdate &gt; self.init.firstdate:
</span><span class="miss">            raise RuntimeError(&#39;The first date of the data period (%s) must &#39;
</span><span class="noop">                               &#39;not be later than the first date of the &#39;
</span><span class="noop">                               &#39;initialisation period  (%s).&#39;
</span><span class="noop">                               % (self.data.firstdate, self.init.firstdate))
</span><span class="miss">        if self.data.lastdate &lt; self.init.lastdate:
</span><span class="miss">            raise RuntimeError(&#39;The last date of the data period (%s) must &#39;
</span><span class="noop">                               &#39;not be earlier than the last date of the &#39;
</span><span class="noop">                               &#39;initialisation period  (%s).&#39;
</span><span class="noop">                               % (self.data.lastdate, self.init.lastdate))
</span><span class="miss">        if self.init.firstdate &gt; self.sim.firstdate:
</span><span class="miss">            raise RuntimeError(&#39;The first date of the initialisation period &#39;
</span><span class="noop">                               &#39;(%s) must not be later than the first date &#39;
</span><span class="noop">                               &#39;of the simulation period  (%s).&#39;
</span><span class="noop">                               % (self.init.firstdate, self.sim.firstdate))
</span><span class="miss">        if self.init.lastdate &lt; self.sim.lastdate:
</span><span class="miss">            raise RuntimeError(&#39;The last date of the initialisation period &#39;
</span><span class="noop">                               &#39;(%s) must not be earlier than the last date &#39;
</span><span class="noop">                               &#39;of the simulation period  (%s).&#39;
</span><span class="noop">                               % (self.init.lastdate, self.sim.lastdate))
</span><span class="miss">        if self.data.stepsize != self.init.stepsize:
</span><span class="miss">            raise RuntimeError(&#39;The data stepsize (%s) must be identical with &#39;
</span><span class="noop">                               &#39;the initialisation stepsize (%s).&#39;
</span><span class="noop">                               % (self.data.stepsize, self.init.stepsize))
</span><span class="miss">        if self.init.stepsize != self.sim.stepsize:
</span><span class="miss">            raise RuntimeError(&#39;The initialization stepsize (%s) must be &#39;
</span><span class="noop">                               &#39;identical with the simulation stepsize (%s).&#39;
</span><span class="noop">                               % (self.init.stepsize, self.sim.stepsize))
</span><span class="miss">        if self.data[self.init.firstdate] % 1:
</span><span class="miss">            raise RuntimeError(&#39;The initialization time grid is not properly &#39;
</span><span class="noop">                               &#39;alligned on the data time grid.&#39;)
</span><span class="miss">        if self.init[self.sim.firstdate] % 1:
</span><span class="miss">            raise RuntimeError(&#39;The simulation time grid is not properly &#39;
</span><span class="noop">                               &#39;alligned on the initialization time grid.&#39;)
</span><span class="noop">
</span><span class="hit">    def qfactor(self, area):
</span><span class="noop">        &#34;&#34;&#34;Return the factor for converting `mm/stepsize` to `m^3/s`.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * area (:class:`float`): Reference area, which must be given in
</span><span class="noop">              the unit `km^2`.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        return area * 1000. / self.stepsize.seconds
</span><span class="noop">
</span><span class="hit">    def parfactor(self, stepsize):
</span><span class="noop">        &#34;&#34;&#34;Return the factor for converting parameter to simulation step size.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * stepsize (:class:`Period` or an suitable initialization argument
</span><span class="noop">              thereof): Time interval, to which the parameter values refer.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        return self.stepsize / Period(stepsize)
</span><span class="noop">
</span><span class="hit">    def copy(self):
</span><span class="noop">        &#34;&#34;&#34;Returns a deep copy of the :class:`Timegrids` instance.&#34;&#34;&#34;
</span><span class="miss">        return copy.deepcopy(self)
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="miss">        for (name, timegrid) in dict(self).items():
</span><span class="miss">            yield (name, timegrid)
</span><span class="noop">
</span><span class="hit">    def __str__(self):
</span><span class="miss">        return &#39;All timegrids of the current project.&#39;
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="miss">        dic = {&#39;timestep&#39;: self.sim.stepsize,
</span><span class="noop">               &#39;date_startdata&#39;: self.data.firstdate,
</span><span class="noop">               &#39;date_enddata&#39;: self.data.lastdate,
</span><span class="noop">               &#39;date_startinit&#39;: self.init.firstdate,
</span><span class="noop">               &#39;date_endinit&#39;: self.init.lastdate,
</span><span class="noop">               &#39;date_startsim&#39;: self.sim.firstdate,
</span><span class="noop">               &#39;date_endsim&#39;: self.sim.lastdate}
</span><span class="miss">        return &#39;Timegrids(%s)&#39; % dic.__repr__()
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Timegrids(object):
</span><span class="noop">    &#34;&#34;&#34;Handle all :class:`Timegrid` instances of a HydPy application.
</span><span class="noop">
</span><span class="noop">    Arguments and Attributes:
</span><span class="noop">        * data (:class:`Timegrid`): For the available data stored on disk.
</span><span class="noop">        * init (:class:`Timegrid`, optional): For the initialisation
</span><span class="noop">          period.  If not supplied, the specifications of the `data`
</span><span class="noop">          :class:`Timegrid` are applied.
</span><span class="noop">        * sim (:class:`Timegrid`, optional): For the simulation period.
</span><span class="noop">          If not supplied, the specifications of the `init` :class:`Timegrid`
</span><span class="noop">          are applied.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self, data, init=None, sim=None):
</span><span class="hit">        self.data = data
</span><span class="hit">        if init is None:
</span><span class="hit">            self.init = self.data.copy()
</span><span class="noop">        else:
</span><span class="miss">            self.init = init
</span><span class="hit">        if sim is None:
</span><span class="hit">            self.sim = self.init.copy()
</span><span class="noop">        else:
</span><span class="miss">            self.sim = sim
</span><span class="hit">        self.verify()
</span><span class="noop">
</span><span class="hit">    def _getstepsize(self):
</span><span class="noop">        &#34;&#34;&#34;Stepsize of all handled :class:`Timegrid` objects.&#34;&#34;&#34;
</span><span class="hit">        return self.data.stepsize
</span><span class="noop">
</span><span class="hit">    def _setstepsize(self, stepsize):
</span><span class="miss">        stepsize = Period(stepsize)
</span><span class="miss">        for (name, timegrid) in self:
</span><span class="miss">            timegrid.stepsize = stepsize
</span><span class="noop">
</span><span class="hit">    stepsize = property(_getstepsize, _setstepsize)
</span><span class="noop">
</span><span class="hit">    def verify(self):
</span><span class="noop">        &#34;&#34;&#34;Raise an :class:`~exceptions.RuntimeError` it the different
</span><span class="noop">        time grids are inconsistent.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if self.data.firstdate &gt; self.init.firstdate:
</span><span class="miss">            raise RuntimeError(&#39;The first date of the data period (%s) must &#39;
</span><span class="noop">                               &#39;not be later than the first date of the &#39;
</span><span class="noop">                               &#39;initialisation period  (%s).&#39;
</span><span class="noop">                               % (self.data.firstdate,
</span><span class="noop">                                  self.init.firstdate))
</span><span class="hit">        if self.data.lastdate &lt; self.init.lastdate:
</span><span class="miss">            raise RuntimeError(&#39;The last date of the data period (%s) must &#39;
</span><span class="noop">                               &#39;not be earlier than the last date of the &#39;
</span><span class="noop">                               &#39;initialisation period  (%s).&#39;
</span><span class="noop">                               % (self.data.lastdate,
</span><span class="noop">                                  self.init.lastdate))
</span><span class="hit">        if self.init.firstdate &gt; self.sim.firstdate:
</span><span class="miss">            raise RuntimeError(&#39;The first date of the initialisation period &#39;
</span><span class="noop">                               &#39;(%s) must not be later than the first date &#39;
</span><span class="noop">                               &#39;of the simulation period  (%s).&#39;
</span><span class="noop">                               % (self.init.firstdate,
</span><span class="noop">                                  self.sim.firstdate))
</span><span class="hit">        if self.init.lastdate &lt; self.sim.lastdate:
</span><span class="miss">            raise RuntimeError(&#39;The last date of the initialisation period &#39;
</span><span class="noop">                               &#39;(%s) must not be earlier than the last date &#39;
</span><span class="noop">                               &#39;of the simulation period  (%s).&#39;
</span><span class="noop">                               % (self.init.lastdate,
</span><span class="noop">                                  self.sim.lastdate))
</span><span class="hit">        if self.data.stepsize != self.init.stepsize:
</span><span class="miss">            raise RuntimeError(&#39;The data stepsize (%s) must be identical with &#39;
</span><span class="noop">                               &#39;the initialisation stepsize (%s).&#39;
</span><span class="noop">                               % (self.data.stepsize,
</span><span class="noop">                                  self.init.stepsize))
</span><span class="hit">        if self.init.stepsize != self.sim.stepsize:
</span><span class="miss">            raise RuntimeError(&#39;The initialization stepsize (%s) must be &#39;
</span><span class="noop">                               &#39;identical with the simulation stepsize (%s).&#39;
</span><span class="noop">                               % (self.init.stepsize,
</span><span class="noop">                                  self.sim.stepsize))
</span><span class="hit">        if self.data[self.init.firstdate] % 1:
</span><span class="miss">            raise RuntimeError(&#39;The initialization time grid is not properly &#39;
</span><span class="noop">                               &#39;alligned on the data time grid.&#39;)
</span><span class="hit">        if self.init[self.sim.firstdate] % 1:
</span><span class="miss">            raise RuntimeError(&#39;The simulation time grid is not properly &#39;
</span><span class="noop">                               &#39;alligned on the initialization time grid.&#39;)
</span><span class="noop">
</span><span class="hit">    def qfactor(self, area):
</span><span class="noop">        &#34;&#34;&#34;Return the factor for converting `mm/stepsize` to `m^3/s`.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * area (:class:`float`): Reference area, which must be given in
</span><span class="noop">              the unit `km^2`.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        return area * 1000. / self.stepsize.seconds
</span><span class="noop">
</span><span class="hit">    def parfactor(self, stepsize):
</span><span class="noop">        &#34;&#34;&#34;Return the factor for converting parameter to simulation step size.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * stepsize (:class:`Period` or an suitable initialization argument
</span><span class="noop">              thereof): Time interval, to which the parameter values refer.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return self.stepsize / Period(stepsize)
</span><span class="noop">
</span><span class="hit">    def copy(self):
</span><span class="noop">        &#34;&#34;&#34;Returns a deep copy of the :class:`Timegrids` instance.&#34;&#34;&#34;
</span><span class="miss">        return copy.deepcopy(self)
</span><span class="noop">
</span><span class="hit">    def __iter__(self):
</span><span class="miss">        for (name, timegrid) in dict(self).items():
</span><span class="miss">            yield (name, timegrid)
</span><span class="noop">
</span><span class="hit">    def __str__(self):
</span><span class="miss">        return &#39;All timegrids of the actual HydPy project.&#39;
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="miss">        return self.assignrepr(&#39;&#39;)
</span><span class="noop">
</span><span class="hit">    def assignrepr(self, prefix):
</span><span class="noop">        &#34;&#34;&#34;Return a :func:`repr` string with an prefixed assignement.
</span><span class="noop">
</span><span class="noop">        Argument:
</span><span class="noop">            * prefix(:class:`str`): Usually something like &#39;x = &#39;.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        caller = &#39;NewTimegrids(&#39;
</span><span class="miss">        blanks = &#39; &#39; * (len(prefix) + len(caller))
</span><span class="miss">        prefix = &#39;%s%sdata=&#39; % (prefix, caller)
</span><span class="miss">        lines = [&#39;%s,&#39; % self.data.assignrepr(prefix)]
</span><span class="miss">        if self.init != self.data:
</span><span class="miss">            prefix = &#39;%sinit=&#39; % blanks
</span><span class="miss">            lines.append(&#39;%s,&#39; % self.init.assignrepr(prefix))
</span><span class="miss">        if self.sim != self.init:
</span><span class="miss">            prefix = &#39;%ssim=&#39; % blanks
</span><span class="miss">            lines.append(&#39;%s,&#39; % self.init.assignrepr(prefix))
</span><span class="miss">        lines[-1] = lines[-1][:-1] + &#39;)&#39;
</span><span class="miss">        return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TOY(object):
</span><span class="noop">    &#34;&#34;&#34;Time of year handler.
</span><span class="noop">
</span><span class="noop">    :class:`TOY` objects are used to define certain things that are true for
</span><span class="noop">    a certain time point in each year.  The smallest supported time unit is
</span><span class="noop">    seconds.
</span><span class="noop">
</span><span class="noop">    Normally, for initialization a string is passed, defining the month, the
</span><span class="noop">    day, the hour, the minute and the second in the order they are mentioned,
</span><span class="noop">    seperated by a single underscore:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.timetools import TOY
</span><span class="noop">    &gt;&gt;&gt; t = TOY(&#39;3_13_23_33_43&#39;)
</span><span class="noop">    &gt;&gt;&gt; t.month
</span><span class="noop">    3
</span><span class="noop">    &gt;&gt;&gt; t.day
</span><span class="noop">    13
</span><span class="noop">    &gt;&gt;&gt; t.hour
</span><span class="noop">    23
</span><span class="noop">    &gt;&gt;&gt; t.minute
</span><span class="noop">    33
</span><span class="noop">    &gt;&gt;&gt; t.second
</span><span class="noop">    43
</span><span class="noop">
</span><span class="noop">    If a lower precision is required, one can shorten the string, which
</span><span class="noop">    implicitely sets the omitted property to the lowest possible value:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; TOY(&#39;3_13_23_33&#39;)
</span><span class="noop">    TOY(&#39;3_13_23_33_0&#39;)
</span><span class="noop">
</span><span class="noop">    The most extreme example would be, to pass not string at all:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; TOY()
</span><span class="noop">    TOY(&#39;1_1_0_0_0&#39;)
</span><span class="noop">
</span><span class="noop">    One can prefix some information to the string, which is usefull when the
</span><span class="noop">    string is to be used as a valid variable name somewhere else:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; TOY(&#39;something_3_13_23_33_2&#39;)
</span><span class="noop">    TOY(&#39;3_13_23_33_2&#39;)
</span><span class="noop">
</span><span class="noop">    As one can see, the prefixed information is lost in the printed string
</span><span class="noop">    representation.  But a string with a standard prefix is returned through
</span><span class="noop">    applying :class:`str` on :class:`TOY` instances:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; str(TOY(&#39;something_3_13_23_33_2&#39;))
</span><span class="noop">    &#39;toy_3_13_23_33_2&#39;
</span><span class="noop">
</span><span class="noop">    Alternatively, one can use a :class:`Date` object as a initialization
</span><span class="noop">    argument, ommitting the year:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; TOY(Date(&#39;2001.02.03 04:05:06&#39;))
</span><span class="noop">    TOY(&#39;2_3_4_5_6&#39;)
</span><span class="noop">
</span><span class="noop">    It is only allowed to modify the mentioned properties, not to define new
</span><span class="noop">    ones:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; t.microsecond = 53
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    AttributeError: TOY (time of year) objects only allow to set the properties month, day, hour, minute or second, but `microsecond` is given.
</span><span class="noop">
</span><span class="noop">    It is allowed to pass objects that can be converted to integers:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; t.second = &#39;53&#39;
</span><span class="noop">    &gt;&gt;&gt; t.second
</span><span class="noop">    53
</span><span class="noop">
</span><span class="noop">    If the passed object cannot be converted properly, an exception is raised:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; t.second = &#39;fiftythree&#39;
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    ValueError: For TOY (time of year) objects, all properties must be of type `int`, but the value `fiftythree` of type `str` given for property `second` cannot be converted to `int`.
</span><span class="noop">
</span><span class="noop">    Additionally, given values are checked to lie within a suitable range:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; t.second = 60
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    ValueError: The value of property `second` of TOY (time of year) objects must lie within the range `(0, 59)`, but the given value is `60`.
</span><span class="noop">
</span><span class="noop">    Note that the allowed values for `month` and `day` depend on each other,
</span><span class="noop">    which is why the order one defines them might be of importance.  So, if
</span><span class="noop">    January is predefined, one can set day to the 31th:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; t.month = 1
</span><span class="noop">    &gt;&gt;&gt; t.day = 31
</span><span class="noop">
</span><span class="noop">    But afterwards one cannot directly change the month to February:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; t.month = 2
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    ValueError: The value of property `month` of the actual TOY (time of year) object must not be the given value `2`, as the day has already been set to `31`.
</span><span class="noop">
</span><span class="noop">    Hence first set `day` to a smaller value and then change `month`:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; t.day = 28
</span><span class="noop">    &gt;&gt;&gt; t.month = 2
</span><span class="noop">
</span><span class="noop">    For February it is important to note, that the 29th is generally
</span><span class="noop">    disallowed:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; t.day = 29
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    ValueError: The value of property `day` of the actual TOY (time of year) object must lie within the range `(1, 28)`, as the month has already been set to `2`, but the given value is `29`.
</span><span class="noop">
</span><span class="noop">    It is possible to compare two :class:`TOY` instances:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; t1, t2 = TOY(&#39;1&#39;), TOY(&#39;2&#39;)
</span><span class="noop">    &gt;&gt;&gt; (t1 &lt; t1, t1 &lt; t2, t2 &lt; t1)
</span><span class="noop">    (False, True, False)
</span><span class="noop">    &gt;&gt;&gt; (t1 &lt;= t1, t1 &lt;= t2, t2 &lt;= t1)
</span><span class="noop">    (True, True, False)
</span><span class="noop">    &gt;&gt;&gt; (t1 == t1, t1 == t2)
</span><span class="noop">    (True, False)
</span><span class="noop">    &gt;&gt;&gt; (t1 != t1, t1 != t2)
</span><span class="noop">    (False, True)
</span><span class="noop">    &gt;&gt;&gt; (t1 &gt;= t1, t1 &gt;= t2, t2 &gt;= t1)
</span><span class="noop">    (True, False, True)
</span><span class="noop">    &gt;&gt;&gt; (t1 &gt; t1, t1 &gt; t2, t2 &gt; t1)
</span><span class="noop">    (False, False, True)
</span><span class="noop">
</span><span class="noop">    Subtracting two :class:`TOY` object gives their time difference in seconds:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; TOY(&#39;1_1_0_3_0&#39;) - TOY(&#39;1_1_0_1_30&#39;)
</span><span class="noop">    90
</span><span class="noop">
</span><span class="noop">    Instead of negative values, it is always assumed that the first
</span><span class="noop">    :class:`TOY` object lies within the future (eventually within the
</span><span class="noop">    subsequent year):
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; TOY(&#39;1_1_0_1_30&#39;) - TOY(&#39;12_31_23_58_30&#39;)
</span><span class="noop">    180
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    _PROPERTIES = collections.OrderedDict(((&#39;month&#39;, (1, 12)),
</span><span class="noop">                                           (&#39;day&#39;, (1, 31)),
</span><span class="noop">                                           (&#39;hour&#39;, (0, 23)),
</span><span class="noop">                                           (&#39;minute&#39;, (0, 59)),
</span><span class="noop">                                           (&#39;second&#39;, (0, 59))))
</span><span class="hit">    _STARTDATE = Date(&#39;01.01.2000&#39;)
</span><span class="hit">    _ENDDATE = Date(&#39;01.01.2001&#39;)
</span><span class="noop">
</span><span class="hit">    def __init__(self, value=&#39;&#39;):
</span><span class="hit">        if isinstance(value, Date):
</span><span class="hit">            for name in self._PROPERTIES.keys():
</span><span class="hit">                self.__dict__[name] = getattr(value, name)
</span><span class="noop">        else:
</span><span class="hit">            for name in self._PROPERTIES.keys():
</span><span class="hit">                self.__dict__[name] = None
</span><span class="hit">            values = value.split(&#39;_&#39;)
</span><span class="hit">            if not values[0].isdigit():
</span><span class="hit">                del values[0]
</span><span class="hit">            for prop in self._PROPERTIES:
</span><span class="hit">                try:
</span><span class="hit">                    setattr(self, prop, values.pop(0))
</span><span class="hit">                except IndexError:
</span><span class="hit">                    if prop in (&#39;month&#39;, &#39;day&#39;):
</span><span class="hit">                        setattr(self, prop, 1)
</span><span class="noop">                    else:
</span><span class="hit">                        setattr(self, prop, 0)
</span><span class="hit">                except ValueError:
</span><span class="hit">                    objecttools.augmentexcmessage(
</span><span class="noop">                        &#39;While trying to retrieve the %s for TOY (time of &#39;
</span><span class="noop">                        &#39;year) object based on the string `%s`&#39;
</span><span class="noop">                        % (prop, value))
</span><span class="noop">
</span><span class="hit">    def __setattr__(self, name, value):
</span><span class="hit">        if name not in self._PROPERTIES:
</span><span class="hit">            keys = list(self._PROPERTIES.keys())
</span><span class="hit">            props = &#39; or &#39;.join((&#39;, &#39;.join(keys[:-1]), keys[-1]))
</span><span class="hit">            raise AttributeError(&#39;TOY (time of year) objects only allow to &#39;
</span><span class="noop">                                 &#39;set the properties %s, but `%s` is given.&#39;
</span><span class="noop">                                 % (props, name))
</span><span class="hit">        try:
</span><span class="hit">            value = int(value)
</span><span class="hit">        except ValueError:
</span><span class="hit">            raise ValueError(&#39;For TOY (time of year) objects, all properties &#39;
</span><span class="noop">                             &#39;must be of type `int`, but the value `%s` of &#39;
</span><span class="noop">                             &#39;type `%s` given for property `%s` cannot be &#39;
</span><span class="noop">                             &#39;converted to `int`.&#39;
</span><span class="noop">                             % (value, objecttools.classname(value), name))
</span><span class="hit">        if (name == &#39;day&#39;) and (self.month is not None):
</span><span class="hit">            bounds = (1, calendar.monthrange(1999, self.month)[1])
</span><span class="hit">            if not (bounds[0] &lt;= value &lt;= bounds[1]):
</span><span class="hit">                raise ValueError(&#39;The value of property `day` of the actual &#39;
</span><span class="noop">                                 &#39;TOY (time of year) object must lie within &#39;
</span><span class="noop">                                 &#39;the range `%s`, as the month has already &#39;
</span><span class="noop">                                 &#39;been set to `%s`, but the given value is &#39;
</span><span class="noop">                                 &#39;`%s`.&#39; % (bounds, self.month, value))
</span><span class="hit">        elif (name == &#39;month&#39;) and (self.day is not None):
</span><span class="hit">            bounds = (1, calendar.monthrange(2000, value)[1])
</span><span class="hit">            if not (bounds[0] &lt;= self.day &lt;= bounds[1]):
</span><span class="hit">                raise ValueError(&#39;The value of property `month` of the actual &#39;
</span><span class="noop">                                 &#39;TOY (time of year) object must not be the &#39;
</span><span class="noop">                                 &#39;given value `%s`, as the day has already &#39;
</span><span class="noop">                                 &#39;been set to `%s`.&#39; % (value, self.day))
</span><span class="noop">        else:
</span><span class="hit">            bounds = self._PROPERTIES[name]
</span><span class="hit">            if not (bounds[0] &lt;= value &lt;= bounds[1]):
</span><span class="hit">                raise ValueError(&#39;The value of property `%s` of TOY (time of &#39;
</span><span class="noop">                                 &#39;year) objects must lie within the range &#39;
</span><span class="noop">                                 &#39;`%s`, but the given value is `%s`.&#39;
</span><span class="noop">                                 % (name, bounds, value))
</span><span class="hit">        object.__setattr__(self, name, value)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def passed_seconds(self):
</span><span class="noop">        &#34;&#34;&#34;Amount of time passed in seconds since the beginning of the year.
</span><span class="noop">
</span><span class="noop">        In the first example, the year is only one minute and thirty seconds
</span><span class="noop">        old:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.timetools import TOY
</span><span class="noop">        &gt;&gt;&gt; TOY(&#39;1_1_0_1_30&#39;).passed_seconds
</span><span class="noop">        90
</span><span class="noop">
</span><span class="noop">        The second example shows that the 29th February is generally included:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; TOY(&#39;3&#39;).passed_seconds
</span><span class="noop">        5184000
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return int((Date(self).datetime -
</span><span class="noop">                    self._STARTDATE.datetime).total_seconds())
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def left_seconds(self):
</span><span class="noop">        &#34;&#34;&#34;Remaining part of the year in seconds.
</span><span class="noop">
</span><span class="noop">        In the first example, only one minute and thirty seconds of the year
</span><span class="noop">        remain:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.timetools import TOY
</span><span class="noop">        &gt;&gt;&gt; TOY(&#39;12_31_23_58_30&#39;).left_seconds
</span><span class="noop">        90
</span><span class="noop">
</span><span class="noop">        The second example shows that the 29th February is generally included:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; TOY(&#39;2&#39;).left_seconds
</span><span class="noop">        28944000
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return int((self._ENDDATE.datetime -
</span><span class="noop">                    Date(self).datetime).total_seconds())
</span><span class="noop">
</span><span class="hit">    def __lt__(self, other):
</span><span class="hit">        return self.passed_seconds &lt; other.passed_seconds
</span><span class="noop">
</span><span class="hit">    def __le__(self, other):
</span><span class="hit">        return self.passed_seconds &lt;= other.passed_seconds
</span><span class="noop">
</span><span class="hit">    def __eq__(self, other):
</span><span class="hit">        return self.passed_seconds == other.passed_seconds
</span><span class="noop">
</span><span class="hit">    def __ne__(self, other):
</span><span class="hit">        return self.passed_seconds != other.passed_seconds
</span><span class="noop">
</span><span class="hit">    def __gt__(self, other):
</span><span class="hit">        return self.passed_seconds &gt; other.passed_seconds
</span><span class="noop">
</span><span class="hit">    def __ge__(self, other):
</span><span class="hit">        return self.passed_seconds &gt;= other.passed_seconds
</span><span class="noop">
</span><span class="hit">    def __sub__(self, other):
</span><span class="hit">        if self &gt;= other:
</span><span class="hit">            return self.passed_seconds - other.passed_seconds
</span><span class="noop">        else:
</span><span class="hit">            return self.passed_seconds + other.left_seconds
</span><span class="noop">
</span><span class="hit">    def __hash__(self):
</span><span class="hit">        return hash(str(self))
</span><span class="noop">
</span><span class="hit">    def __str__(self):
</span><span class="hit">        return &#34;toy_%s&#34; % &#39;_&#39;.join(str(getattr(self, prop)) for prop
</span><span class="noop">                                   in self._PROPERTIES.keys())
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        return &#34;TOY(&#39;%s&#39;)&#34; % &#39;_&#39;.join(str(getattr(self, prop)) for prop
</span><span class="noop">                                      in self._PROPERTIES.keys())
</span><span class="noop">
</span><span class="hit">    __dir__ = objecttools.dir_
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/cythons/__init__.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/cythons/__init__.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;
</span><span class="noop">Created on Mon Jan 30 14:23:11 2017
</span><span class="noop">
</span><span class="noop">@author: tyralla
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop">
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/cythons/modelutils.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/cythons/modelutils.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
677 &nbsp;
678 &nbsp;
679 &nbsp;
680 &nbsp;
681 &nbsp;
682 &nbsp;
683 &nbsp;
684 &nbsp;
685 &nbsp;
686 &nbsp;
687 &nbsp;
688 &nbsp;
689 &nbsp;
690 &nbsp;
691 &nbsp;
692 &nbsp;
693 &nbsp;
694 &nbsp;
695 &nbsp;
696 &nbsp;
697 &nbsp;
698 &nbsp;
699 &nbsp;
700 &nbsp;
701 &nbsp;
702 &nbsp;
703 &nbsp;
704 &nbsp;
705 &nbsp;
706 &nbsp;
707 &nbsp;
708 &nbsp;
709 &nbsp;
710 &nbsp;
711 &nbsp;
712 &nbsp;
713 &nbsp;
714 &nbsp;
715 &nbsp;
716 &nbsp;
717 &nbsp;
718 &nbsp;
719 &nbsp;
720 &nbsp;
721 &nbsp;
722 &nbsp;
723 &nbsp;
724 &nbsp;
725 &nbsp;
726 &nbsp;
727 &nbsp;
728 &nbsp;
729 &nbsp;
730 &nbsp;
731 &nbsp;
732 &nbsp;
733 &nbsp;
734 &nbsp;
735 &nbsp;
736 &nbsp;
737 &nbsp;
738 &nbsp;
739 &nbsp;
740 &nbsp;
741 &nbsp;
742 &nbsp;
743 &nbsp;
744 &nbsp;
745 &nbsp;
746 &nbsp;
747 &nbsp;
748 &nbsp;
749 &nbsp;
750 &nbsp;
751 &nbsp;
752 &nbsp;
753 &nbsp;
754 &nbsp;
755 &nbsp;
756 &nbsp;
757 &nbsp;
758 &nbsp;
759 &nbsp;
760 &nbsp;
761 &nbsp;
762 &nbsp;
763 &nbsp;
764 &nbsp;
765 &nbsp;
766 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">
</span><span class="hit">&#34;&#34;&#34; This module provides utilities to build and apply cython models.
</span><span class="noop">
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import os
</span><span class="hit">import sys
</span><span class="hit">import platform
</span><span class="hit">import shutil
</span><span class="hit">import copy
</span><span class="hit">import inspect
</span><span class="hit">import importlib
</span><span class="hit">import distutils.core
</span><span class="hit">import distutils.extension
</span><span class="hit">import Cython.Build
</span><span class="hit">import math
</span><span class="noop"># ...third party modules
</span><span class="hit">import numpy
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy import cythons
</span><span class="hit">from hydpy.core import objecttools
</span><span class="hit">from hydpy.core import parametertools
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="hit">from hydpy.core import magictools
</span><span class="noop">
</span><span class="hit">if platform.system().lower() == &#39;windows&#39;:
</span><span class="miss">    dllextension = &#39;.pyd&#39;
</span><span class="miss">    &#34;&#34;&#34;The dll file extension on the respective system.&#34;&#34;&#34;
</span><span class="noop">else:
</span><span class="hit">    dllextension = &#39;.so&#39;
</span><span class="noop">
</span><span class="hit">TYPE2STR = {bool: &#39;bint&#39;,
</span><span class="noop">            int: &#39;numpy.&#39;+str(numpy.array([1]).dtype)+&#39;_t&#39;,
</span><span class="noop">            float: &#39;double&#39;,
</span><span class="noop">            str: &#39;str&#39;,
</span><span class="noop">            None: &#39;void&#39;}
</span><span class="noop">&#34;&#34;&#34;Maps Python types to Cython compatible type declarations.
</span><span class="noop">
</span><span class="noop">The Cython type belonging to Python&#39;s :class:`int` is selected to be in
</span><span class="noop">agreement with numpy&#39;s default integer type on the respective platform/system.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="hit">NDIM2STR = {0: &#39;&#39;,
</span><span class="noop">            1: &#39;[:]&#39;,
</span><span class="noop">            2: &#39;[:,:]&#39;,
</span><span class="noop">            3: &#39;[:,:,:]&#39;}
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Lines(list):
</span><span class="noop">    &#34;&#34;&#34;Handles lines to be written into a `.pyx` file.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self, *args):
</span><span class="hit">        list.__init__(self, args)
</span><span class="noop">
</span><span class="hit">    def add(self, indent, line):
</span><span class="noop">        &#34;&#34;&#34;Appends the given text line with prefixed spaces in accordance with
</span><span class="noop">        the given number of indentation levels.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        list.append(self, indent*4*&#39; &#39; + line)
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        return &#39;\n&#39;.join(self) + &#39;\n&#39;
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Cythonizer(object):
</span><span class="noop">    &#34;&#34;&#34;Handles the writing, compiling and initialization of cython models.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        frame = inspect.currentframe().f_back
</span><span class="hit">        self.pymodule = frame.f_globals[&#39;__name__&#39;]
</span><span class="hit">        for (key, value) in frame.f_locals.items():
</span><span class="hit">            setattr(self, key, value)
</span><span class="noop">
</span><span class="hit">    def complete(self):
</span><span class="hit">        if self.outdated:
</span><span class="hit">            if not pub.options.skipdoctests:
</span><span class="miss">                pub.options.usecython = False
</span><span class="miss">                self.tester.doit()
</span><span class="hit">            self.doit()
</span><span class="hit">            if not pub.options.skipdoctests:
</span><span class="miss">                pub.options.usecython = True
</span><span class="miss">                self.tester.doit()
</span><span class="noop">
</span><span class="hit">    def doit(self):
</span><span class="hit">        with magictools.PrintStyle(color=33, font=4):
</span><span class="hit">            print(&#39;Translate module/package %s.&#39; % self.pyname)
</span><span class="hit">        with magictools.PrintStyle(color=33, font=2):
</span><span class="hit">            self.pyxwriter.write()
</span><span class="hit">        with magictools.PrintStyle(color=31, font=4):
</span><span class="hit">            print(&#39;Compile module %s.&#39; % self.cyname)
</span><span class="hit">        with magictools.PrintStyle(color=31, font=2):
</span><span class="hit">            self.compile_()
</span><span class="hit">            self.movedll()
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def pyname(self):
</span><span class="noop">        &#34;&#34;&#34;Name of the compiled module.&#34;&#34;&#34;
</span><span class="hit">        if self.pymodule.endswith(&#39;__init__&#39;):
</span><span class="hit">            return self.pymodule.split(&#39;.&#39;)[-2]
</span><span class="noop">        else:
</span><span class="hit">            return self.pymodule.split(&#39;.&#39;)[-1]
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def cyname(self):
</span><span class="noop">        &#34;&#34;&#34;Name of the compiled module.&#34;&#34;&#34;
</span><span class="hit">        return &#39;c_&#39; + self.pyname
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def cydirpath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path of the directory containing the compiled modules.&#34;&#34;&#34;
</span><span class="hit">        return cythons.__path__[0]
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def cymodule(self):
</span><span class="noop">        &#34;&#34;&#34;The compiled module.&#34;&#34;&#34;
</span><span class="hit">        return importlib.import_module(&#39;hydpy.cythons.&#39;+self.cyname)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def cyfilepath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path of the compiled module.&#34;&#34;&#34;
</span><span class="hit">        return os.path.join(self.cydirpath, self.cyname+&#39;.pyx&#39;)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def buildpath(self):
</span><span class="noop">        &#34;&#34;&#34;Absolute path for temporarily build files.&#34;&#34;&#34;
</span><span class="hit">        return os.path.join(self.cydirpath, &#39;_build&#39;)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def pyxwriter(self):
</span><span class="noop">        &#34;&#34;&#34;Update the pyx file.&#34;&#34;&#34;
</span><span class="hit">        model = self.Model()
</span><span class="hit">        if hasattr(self, &#39;Parameters&#39;):
</span><span class="hit">            model.parameters = self.Parameters(vars(self))
</span><span class="noop">        else:
</span><span class="hit">            model.parameters = parametertools.Parameters(vars(self))
</span><span class="hit">        if hasattr(self, &#39;Sequences&#39;):
</span><span class="miss">            model.sequences = self.Sequences(vars(self))
</span><span class="noop">        else:
</span><span class="hit">            model.sequences = sequencetools.Sequences(vars(self))
</span><span class="hit">        return PyxWriter(self, model, self.cyfilepath)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def pysourcefiles(self):
</span><span class="noop">        &#34;&#34;&#34;All source files of the actual models Python classes and their
</span><span class="noop">        respective base classes.&#34;&#34;&#34;
</span><span class="hit">        sourcefiles = set()
</span><span class="hit">        for (name, child) in vars(self).items():
</span><span class="hit">            try:
</span><span class="hit">                parents = inspect.getmro(child)
</span><span class="hit">            except AttributeError:
</span><span class="hit">                continue
</span><span class="hit">            for parent in parents:
</span><span class="hit">                try:
</span><span class="hit">                    sourcefile = inspect.getfile(parent)
</span><span class="hit">                except TypeError:
</span><span class="hit">                    break
</span><span class="hit">                sourcefiles.add(sourcefile)
</span><span class="hit">        return Lines(*sourcefiles)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def outdated(self):
</span><span class="noop">        &#34;&#34;&#34;True if at least one of the :attr:`~Cythonizer.pysourcefiles`
</span><span class="noop">        is newer than the compiled file under :attr:`~Cythonizer.cyfilepath`,
</span><span class="noop">        otherwise False.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if not os.path.exists(self.cyfilepath):
</span><span class="hit">            return True
</span><span class="hit">        cydate = os.stat(self.cyfilepath).st_mtime
</span><span class="hit">        for pysourcefile in self.pysourcefiles:
</span><span class="hit">            pydate = os.stat(pysourcefile).st_mtime
</span><span class="hit">            if pydate &gt; cydate:
</span><span class="miss">                return True
</span><span class="hit">        return False
</span><span class="noop">
</span><span class="hit">    def compile_(self):
</span><span class="noop">        &#34;&#34;&#34;Translate cython code to C code and compile it.&#34;&#34;&#34;
</span><span class="hit">        argv = copy.deepcopy(sys.argv)
</span><span class="hit">        sys.argv = [sys.argv[0], &#39;build_ext&#39;, &#39;--build-lib=&#39;+self.buildpath]
</span><span class="hit">        exc_modules = Cython.Build.cythonize(self.cyfilepath)
</span><span class="hit">        distutils.core.setup(ext_modules=exc_modules,
</span><span class="noop">                             include_dirs=[numpy.get_include()])
</span><span class="hit">        sys.argv = argv
</span><span class="noop">
</span><span class="hit">    def movedll(self):
</span><span class="noop">        &#34;&#34;&#34;Try to find the resulting dll file and to move it into the
</span><span class="noop">        `cythons` package.
</span><span class="noop">
</span><span class="noop">        Things to be aware of:
</span><span class="noop">          * The file extension either `pyd` (Window) or `so` (Linux).
</span><span class="noop">          * The folder containing the dll file is system dependend, but is
</span><span class="noop">            always a subfolder of the `cythons` package.
</span><span class="noop">          * Under Linux, the filename might contain system information, e.g.
</span><span class="noop">            ...cpython-36m-x86_64-linux-gnu.so.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        dirinfos = os.walk(self.buildpath)
</span><span class="hit">        next(dirinfos)
</span><span class="hit">        system_dependend_filename = None
</span><span class="hit">        for dirinfo in dirinfos:
</span><span class="hit">            for filename in dirinfo[2]:
</span><span class="hit">                if (filename.startswith(self.cyname) and
</span><span class="noop">                        filename.endswith(dllextension)):
</span><span class="hit">                    system_dependend_filename = filename
</span><span class="hit">                    break
</span><span class="hit">            if system_dependend_filename:
</span><span class="hit">                try:
</span><span class="hit">                    shutil.move(os.path.join(dirinfo[0],
</span><span class="noop">                                             system_dependend_filename),
</span><span class="noop">                                os.path.join(self.cydirpath,
</span><span class="noop">                                             self.cyname+dllextension))
</span><span class="hit">                    break
</span><span class="miss">                except BaseException:
</span><span class="miss">                    prefix = (&#39;After trying to cythonize module %s, when &#39;
</span><span class="noop">                              &#39;trying to move the final cython module %s &#39;
</span><span class="noop">                              &#39;from directory %s to directory %s&#39;
</span><span class="noop">                              % (self.pyname, system_dependend_filename,
</span><span class="noop">                                 self.buildpath, self.cydirpath))
</span><span class="miss">                    suffix = (&#39;A likely error cause is that the cython module &#39;
</span><span class="noop">                              &#39;%s does already exist in this directory and is &#39;
</span><span class="noop">                              &#39;currently blocked by another Python process.  &#39;
</span><span class="noop">                              &#39;Maybe it helps to close all Python processes &#39;
</span><span class="noop">                              &#39;and restart the cyhonization afterwards.&#39;
</span><span class="noop">                              % self.cyname+dllextension)
</span><span class="miss">                    objecttools.augmentexcmessage(prefix, suffix)
</span><span class="noop">        else:
</span><span class="miss">            raise IOError(&#39;After trying to cythonize module %s, the resulting &#39;
</span><span class="noop">                          &#39;file %s could neither be found in directory %s nor &#39;
</span><span class="noop">                          &#39;its subdirectories.  The distul report should tell &#39;
</span><span class="noop">                          &#39;whether the file has been stored somewhere else,&#39;
</span><span class="noop">                          &#39;is named somehow else, or could not be build at &#39;
</span><span class="noop">                          &#39;all.&#39; % self.buildpath)
</span><span class="noop">
</span><span class="hit">    def __dir__(self):
</span><span class="miss">        return objecttools.dir_(self)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class PyxWriter(object):
</span><span class="noop">    &#34;&#34;&#34;Writes a new pyx file into framework.models.cython when initialized.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def __init__(self, cythonizer, model, pyxpath):
</span><span class="hit">        self.cythonizer = cythonizer
</span><span class="hit">        self.model = model
</span><span class="hit">        self.pyxpath = pyxpath
</span><span class="noop">
</span><span class="hit">    def write(self):
</span><span class="hit">        with open(self.pyxpath, &#39;w&#39;) as pxf:
</span><span class="hit">            print(&#39;    %s&#39; % &#39;* cython options&#39;)
</span><span class="hit">            pxf.write(repr(self.cythonoptions))
</span><span class="hit">            print(&#39;    %s&#39; % &#39;* C imports&#39;)
</span><span class="hit">            pxf.write(repr(self.cimports))
</span><span class="hit">            print(&#39;    %s&#39; % &#39;* constants (if defined)&#39;)
</span><span class="hit">            pxf.write(repr(self.constants))
</span><span class="hit">            print(&#39;    %s&#39; % &#39;* parameter classes&#39;)
</span><span class="hit">            pxf.write(repr(self.parameters))
</span><span class="hit">            print(&#39;    %s&#39; % &#39;* sequence classes&#39;)
</span><span class="hit">            pxf.write(repr(self.sequences))
</span><span class="hit">            print(&#39;    %s&#39; % &#39;* model class&#39;)
</span><span class="hit">            print(&#39;        %s&#39; % &#39;- model attributes&#39;)
</span><span class="hit">            pxf.write(repr(self.modeldeclarations))
</span><span class="hit">            print(&#39;        %s&#39; % &#39;- standard functions&#39;)
</span><span class="hit">            pxf.write(repr(self.modelstandardfunctions))
</span><span class="hit">            print(&#39;        %s&#39; % &#39;- additional functions&#39;)
</span><span class="hit">            pxf.write(repr(self.modeluserfunctions))
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def cythonoptions(self):
</span><span class="noop">        &#34;&#34;&#34;Cython option lines.&#34;&#34;&#34;
</span><span class="hit">        return Lines(&#39;#!python&#39;,
</span><span class="noop">                     &#39;#cython: boundscheck=False&#39;,
</span><span class="noop">                     &#39;#cython: wraparound=False&#39;,
</span><span class="noop">                     &#39;#cython: initializedcheck=False&#39;)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def cimports(self):
</span><span class="noop">        &#34;&#34;&#34;Import command lines.&#34;&#34;&#34;
</span><span class="hit">        return Lines(&#39;import numpy&#39;,
</span><span class="noop">                     &#39;cimport numpy&#39;,
</span><span class="noop">                     &#39;from libc.math cimport exp, fabs&#39;,
</span><span class="noop">                     &#39;from libc.stdio cimport *&#39;,
</span><span class="noop">                     &#39;from libc.stdlib cimport *&#39;,
</span><span class="noop">                     &#39;import cython&#39;,
</span><span class="noop">                     &#39;from cpython.mem cimport PyMem_Malloc&#39;,
</span><span class="noop">                     &#39;from cpython.mem cimport PyMem_Realloc&#39;,
</span><span class="noop">                     &#39;from cpython.mem cimport PyMem_Free&#39;,
</span><span class="noop">                     &#39;from hydpy.cythons cimport pointer&#39;,
</span><span class="noop">                     &#39;from hydpy.cythons import pointer&#39;)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def constants(self):
</span><span class="noop">        &#34;&#34;&#34;Constants declaration lines.&#34;&#34;&#34;
</span><span class="hit">        lines = Lines()
</span><span class="hit">        for (name, member) in vars(self.cythonizer).items():
</span><span class="hit">            if (name.isupper() and
</span><span class="noop">                    (not inspect.isclass(member)) and
</span><span class="noop">                    (type(member) in TYPE2STR)):
</span><span class="hit">                ndim = numpy.array(member).ndim
</span><span class="hit">                ctype = TYPE2STR[type(member)] + NDIM2STR[ndim]
</span><span class="hit">                lines.add(0, &#39;cdef public %s %s = %s&#39;
</span><span class="noop">                             % (ctype, name, member))
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def parameters(self):
</span><span class="noop">        &#34;&#34;&#34;Parameter declaration lines.&#34;&#34;&#34;
</span><span class="hit">        lines = Lines()
</span><span class="hit">        for (name1, subpars) in self.model.parameters:
</span><span class="hit">            print(&#39;        - %s&#39; % name1)
</span><span class="hit">            lines.add(0, &#39;@cython.final&#39;)
</span><span class="hit">            lines.add(0, &#39;cdef class %s(object):&#39;
</span><span class="noop">                         % objecttools.classname(subpars))
</span><span class="hit">            for (name2, par) in subpars:
</span><span class="hit">                ctype = TYPE2STR[par.TYPE] + NDIM2STR[par.NDIM]
</span><span class="hit">                lines.add(1, &#39;cdef public %s %s&#39; % (ctype, name2))
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def sequences(self):
</span><span class="noop">        &#34;&#34;&#34;Sequence declaration lines.&#34;&#34;&#34;
</span><span class="hit">        lines = Lines()
</span><span class="hit">        for (name1, subseqs) in self.model.sequences:
</span><span class="hit">            print(&#39;        - %s&#39; % name1)
</span><span class="hit">            lines.add(0, &#39;@cython.final&#39;)
</span><span class="hit">            lines.add(0, &#39;cdef class %s(object):&#39;
</span><span class="noop">                         % objecttools.classname(subseqs))
</span><span class="hit">            for (name2, seq) in subseqs:
</span><span class="hit">                ctype = &#39;double&#39; + NDIM2STR[seq.NDIM]
</span><span class="hit">                if isinstance(subseqs, sequencetools.LinkSequences):
</span><span class="hit">                    if seq.NDIM == 0:
</span><span class="hit">                        lines.add(1, &#39;cdef double *%s&#39; % name2)
</span><span class="hit">                    elif seq.NDIM == 1:
</span><span class="hit">                        lines.add(1, &#39;cdef double **%s&#39; % name2)
</span><span class="hit">                        lines.add(1, &#39;cdef public int len_%s&#39; % name2)
</span><span class="noop">                else:
</span><span class="hit">                    lines.add(1, &#39;cdef public %s %s&#39; % (ctype, name2))
</span><span class="hit">                lines.add(1, &#39;cdef public int _%s_ndim&#39; % name2)
</span><span class="hit">                lines.add(1, &#39;cdef public int _%s_length&#39; % name2)
</span><span class="hit">                for idx in range(seq.NDIM):
</span><span class="hit">                    lines.add(1, &#39;cdef public int _%s_length_%d&#39;
</span><span class="noop">                                 % (seq.name, idx))
</span><span class="hit">                if isinstance(subseqs, sequencetools.IOSubSequences):
</span><span class="hit">                    lines.extend(self.iosequence(seq))
</span><span class="hit">            if isinstance(subseqs, sequencetools.InputSequences):
</span><span class="hit">                lines.extend(self.loaddata(subseqs))
</span><span class="hit">            if isinstance(subseqs, sequencetools.IOSubSequences):
</span><span class="hit">                lines.extend(self.openfiles(subseqs))
</span><span class="hit">                lines.extend(self.closefiles(subseqs))
</span><span class="hit">                if not isinstance(subseqs, sequencetools.InputSequence):
</span><span class="hit">                    lines.extend(self.savedata(subseqs))
</span><span class="hit">            if isinstance(subseqs, sequencetools.LinkSequences):
</span><span class="hit">                lines.extend(self.setpointer(subseqs))
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    def iosequence(self, seq):
</span><span class="noop">        &#34;&#34;&#34;Special declaration lines for the given
</span><span class="noop">        :class:`~hydpy.core.sequencetools.IOSequence` object.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.add(1, &#39;cdef public bint _%s_diskflag&#39; % seq.name)
</span><span class="hit">        lines.add(1, &#39;cdef public str _%s_path&#39; % seq.name)
</span><span class="hit">        lines.add(1, &#39;cdef FILE *_%s_file&#39; % seq.name)
</span><span class="hit">        lines.add(1, &#39;cdef public bint _%s_ramflag&#39; % seq.name)
</span><span class="hit">        ctype = &#39;double&#39; + NDIM2STR[seq.NDIM+1]
</span><span class="hit">        lines.add(1, &#39;cdef public %s _%s_array&#39; % (ctype, seq.name))
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    def openfiles(self, subseqs):
</span><span class="noop">        &#34;&#34;&#34;Open file statements.&#34;&#34;&#34;
</span><span class="hit">        print(&#39;            . openfiles&#39;)
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.add(1, &#39;cpdef openfiles(self, int idx):&#39;)
</span><span class="hit">        for (name, seq) in subseqs:
</span><span class="hit">            lines.add(2, &#39;if self._%s_diskflag:&#39; % name)
</span><span class="hit">            lines.add(3, &#39;self._%s_file = fopen(str(self._%s_path).encode(), &#39;
</span><span class="noop">                         &#39;&#34;rb+&#34;)&#39; % (2*(name,)))
</span><span class="hit">            if seq.NDIM == 0:
</span><span class="hit">                lines.add(3, &#39;fseek(self._%s_file, idx*8, SEEK_SET)&#39; % name)
</span><span class="noop">            else:
</span><span class="hit">                lines.add(3, &#39;fseek(self._%s_file, idx*self._%s_length*8, &#39;
</span><span class="noop">                             &#39;SEEK_SET)&#39; % (2*(name,)))
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    def closefiles(self, subseqs):
</span><span class="noop">        &#34;&#34;&#34;Close file statements.&#34;&#34;&#34;
</span><span class="hit">        print(&#39;            . closefiles&#39;)
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.add(1, &#39;cpdef inline closefiles(self):&#39;)
</span><span class="hit">        for (name, seq) in sorted(subseqs):
</span><span class="hit">            lines.add(2, &#39;if self._%s_diskflag:&#39; % name)
</span><span class="hit">            lines.add(3, &#39;fclose(self._%s_file)&#39; % name)
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    def loaddata(self, subseqs):
</span><span class="noop">        &#34;&#34;&#34;Load data statements.&#34;&#34;&#34;
</span><span class="hit">        print(&#39;            . loaddata&#39;)
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.add(1, &#39;cpdef inline loaddata(self, int idx):&#39;)
</span><span class="hit">        lines.add(2, &#39;cdef int jdx0, jdx1, jdx2, jdx3, jdx4, jdx5&#39;)
</span><span class="hit">        for (name, seq) in subseqs:
</span><span class="hit">            lines.add(2, &#39;if self._%s_diskflag:&#39; % name)
</span><span class="hit">            if seq.NDIM == 0:
</span><span class="hit">                lines.add(3, &#39;fread(&amp;self.%s, 8, 1, self._%s_file)&#39;
</span><span class="noop">                             % (2*(name,)))
</span><span class="noop">            else:
</span><span class="miss">                lines.add(3, &#39;fread(&amp;self.%s[0], 8, self._%s_length, &#39;
</span><span class="noop">                             &#39;self._%s_file)&#39; % (3*((name,))))
</span><span class="hit">            lines.add(2, &#39;elif self._%s_ramflag:&#39; % name)
</span><span class="hit">            if seq.NDIM == 0:
</span><span class="hit">                lines.add(3, &#39;self.%s = self._%s_array[idx]&#39; % (2*(name,)))
</span><span class="noop">            else:
</span><span class="miss">                indexing = &#39;&#39;
</span><span class="miss">                for idx in range(seq.NDIM):
</span><span class="miss">                    lines.add(3+idx, &#39;for jdx%d in range(self._%s_length_%d):&#39;
</span><span class="noop">                                     % (idx, name, idx))
</span><span class="miss">                    indexing += &#39;jdx%d,&#39; % idx
</span><span class="miss">                indexing = indexing[:-1]
</span><span class="miss">                lines.add(3+seq.NDIM, &#39;self.%s[%s] = self._%s_array[idx,%s]&#39;
</span><span class="noop">                                      % (2*(name, indexing)))
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    def savedata(self, subseqs):
</span><span class="noop">        &#34;&#34;&#34;Save data statements.&#34;&#34;&#34;
</span><span class="hit">        print(&#39;            . savedata&#39;)
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.add(1, &#39;cpdef inline savedata(self, int idx):&#39;)
</span><span class="hit">        lines.add(2, &#39;cdef int jdx0, jdx1, jdx2, jdx3, jdx4, jdx5&#39;)
</span><span class="hit">        for (name, seq) in subseqs:
</span><span class="hit">            lines.add(2, &#39;if self._%s_diskflag:&#39; % name)
</span><span class="hit">            if seq.NDIM == 0:
</span><span class="hit">                lines.add(3, &#39;fwrite(&amp;self.%s, 8, 1, self._%s_file)&#39;
</span><span class="noop">                             % (2*(name,)))
</span><span class="noop">            else:
</span><span class="hit">                lines.add(3, &#39;fwrite(&amp;self.%s[0], 8, self._%s_length, &#39;
</span><span class="noop">                             &#39;self._%s_file)&#39; % (3*(name,)))
</span><span class="hit">            lines.add(2, &#39;elif self._%s_ramflag:&#39; % name)
</span><span class="hit">            if seq.NDIM == 0:
</span><span class="hit">                lines.add(3, &#39;self._%s_array[idx] = self.%s&#39; % (2*(name,)))
</span><span class="noop">            else:
</span><span class="hit">                indexing = &#39;&#39;
</span><span class="hit">                for idx in range(seq.NDIM):
</span><span class="hit">                    lines.add(3+idx, &#39;for jdx%d in range(self._%s_length_%d):&#39;
</span><span class="noop">                                     % (idx, name, idx))
</span><span class="hit">                    indexing += &#39;jdx%d,&#39; % idx
</span><span class="hit">                indexing = indexing[:-1]
</span><span class="hit">                lines.add(3+seq.NDIM, &#39;self._%s_array[idx,%s] = self.%s[%s]&#39;
</span><span class="noop">                                      % (2*(name, indexing)))
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    def setpointer(self, subseqs):
</span><span class="noop">        &#34;&#34;&#34;Setpointer functions for link sequences.&#34;&#34;&#34;
</span><span class="hit">        lines = Lines()
</span><span class="hit">        for (name, seq) in subseqs:
</span><span class="hit">            if seq.NDIM == 0:
</span><span class="hit">                lines.extend(self.setpointer0d(subseqs))
</span><span class="hit">            break
</span><span class="hit">        for (name, seq) in subseqs:
</span><span class="hit">            if seq.NDIM == 1:
</span><span class="hit">                lines.extend(self.alloc(subseqs))
</span><span class="hit">                lines.extend(self.dealloc(subseqs))
</span><span class="hit">                lines.extend(self.setpointer1d(subseqs))
</span><span class="hit">            break
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    def setpointer0d(self, subseqs):
</span><span class="noop">        &#34;&#34;&#34;Setpointer function for 0-dimensional link sequences.&#34;&#34;&#34;
</span><span class="hit">        print(&#39;            . setpointer0d&#39;)
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.add(1, &#39;cpdef inline setpointer0d&#39;
</span><span class="noop">                     &#39;(self, str name, pointer.PDouble value):&#39;)
</span><span class="hit">        for (name, seq) in subseqs:
</span><span class="hit">            lines.add(2, &#39;if name == &#34;%s&#34;:&#39; % name)
</span><span class="hit">            lines.add(3, &#39;self.%s = value.p_value&#39; % name)
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    def alloc(self, subseqs):
</span><span class="noop">        &#34;&#34;&#34;Allocate memory for 1-dimensional link sequences.&#34;&#34;&#34;
</span><span class="hit">        print(&#39;            . setlength&#39;)
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.add(1, &#39;cpdef inline alloc(self, name, int length):&#39;)
</span><span class="hit">        for (name, seq) in subseqs:
</span><span class="hit">            lines.add(2, &#39;if name == &#34;%s&#34;:&#39; % name)
</span><span class="hit">            lines.add(3, &#39;self._%s_length_0 = length&#39; % name)
</span><span class="hit">            lines.add(3, &#39;self.%s = &lt;double**&gt; &#39;
</span><span class="noop">                         &#39;PyMem_Malloc(length * sizeof(double*))&#39; % name)
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    def dealloc(self, subseqs):
</span><span class="noop">        &#34;&#34;&#34;Deallocate memory for 1-dimensional link sequences.&#34;&#34;&#34;
</span><span class="hit">        print(&#39;            . dealloc&#39;)
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.add(1, &#39;cpdef inline dealloc(self):&#39;)
</span><span class="hit">        for (name, seq) in subseqs:
</span><span class="hit">            lines.add(2, &#39;PyMem_Free(self.%s)&#39; % name)
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    def setpointer1d(self, subseqs):
</span><span class="noop">        &#34;&#34;&#34;Setpointer function for 1-dimensional link sequences.&#34;&#34;&#34;
</span><span class="hit">        print(&#39;            . setpointer1d&#39;)
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.add(1, &#39;cpdef inline setpointer1d&#39;
</span><span class="noop">                     &#39;(self, str name, pointer.PDouble value, int idx):&#39;)
</span><span class="hit">        for (name, seq) in subseqs:
</span><span class="hit">            lines.add(2, &#39;if name == &#34;%s&#34;:&#39; % name)
</span><span class="hit">            lines.add(3, &#39;self.%s[idx] = value.p_value&#39; % name)
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def modeldeclarations(self):
</span><span class="noop">        &#34;&#34;&#34;Attribute declarations of the model class.&#34;&#34;&#34;
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.add(0, &#39;@cython.final&#39;)
</span><span class="hit">        lines.add(0, &#39;cdef class Model(object):&#39;)
</span><span class="hit">        lines.add(1, &#39;cdef public int idx_sim&#39;)
</span><span class="hit">        for things in (self.model.parameters, self.model.sequences):
</span><span class="hit">            for (name, thing) in things:
</span><span class="hit">                lines.add(1, &#39;cdef public %s %s&#39;
</span><span class="noop">                             % (objecttools.classname(thing), name))
</span><span class="hit">        if getattr(self.model.sequences, &#39;states&#39;, None) is not None:
</span><span class="hit">            lines.add(1, &#39;cdef public StateSequences old_states&#39;)
</span><span class="hit">            lines.add(1, &#39;cdef public StateSequences new_states&#39;)
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def modelstandardfunctions(self):
</span><span class="noop">        &#34;&#34;&#34;Standard functions of the model class.&#34;&#34;&#34;
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.extend(self.doit)
</span><span class="hit">        lines.extend(self.iofunctions)
</span><span class="hit">        lines.extend(self.new2old)
</span><span class="hit">        if &#39;run&#39; not in [tpl[0] for tpl in self.listofmodeluserfunctions]:
</span><span class="hit">            lines.extend(self.run)
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def doit(self):
</span><span class="noop">        &#34;&#34;&#34;Do (most of) it function of the model class.&#34;&#34;&#34;
</span><span class="hit">        print(&#39;                . doit&#39;)
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.add(1, &#39;cpdef inline void doit(self, int idx):&#39;)
</span><span class="hit">        lines.add(2, &#39;self.idx_sim = idx&#39;)
</span><span class="hit">        if getattr(self.model.sequences, &#39;inputs&#39;, None) is not None:
</span><span class="hit">            lines.add(2, &#39;self.loaddata()&#39;)
</span><span class="hit">        if getattr(self.model.sequences, &#39;inlets&#39;, None) is not None:
</span><span class="hit">            lines.add(2, &#39;self.update_inlets()&#39;)
</span><span class="hit">        lines.add(2, &#39;self.run()&#39;)
</span><span class="hit">        if getattr(self.model.sequences, &#39;outlets&#39;, None) is not None:
</span><span class="hit">            lines.add(2, &#39;self.update_outlets()&#39;)
</span><span class="hit">        if getattr(self.model.sequences, &#39;states&#39;, None) is not None:
</span><span class="hit">            lines.add(2, &#39;self.new2old()&#39;)
</span><span class="hit">        if getattr(self.model.sequences, &#39;senders&#39;, None) is not None:
</span><span class="miss">            lines.add(2, &#39;self.update_senders()&#39;)
</span><span class="hit">        if ((getattr(self.model.sequences, &#39;fluxes&#39;, None) is not None) or
</span><span class="noop">                (getattr(self.model.sequences, &#39;states&#39;, None) is not None)):
</span><span class="hit">            lines.add(2, &#39;self.savedata()&#39;)
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def iofunctions(self):
</span><span class="noop">        &#34;&#34;&#34;Input/output functions of the model class.&#34;&#34;&#34;
</span><span class="hit">        lines = Lines()
</span><span class="hit">        for func in (&#39;openfiles&#39;, &#39;closefiles&#39;, &#39;loaddata&#39;, &#39;savedata&#39;):
</span><span class="hit">            if ((func == &#39;loaddata&#39;) and
</span><span class="noop">                    (getattr(self.model.sequences, &#39;inputs&#39;, None) is None)):
</span><span class="hit">                continue
</span><span class="hit">            if ((func == &#39;savedata&#39;) and
</span><span class="noop">                ((getattr(self.model.sequences, &#39;fluxes&#39;, None) is None) and
</span><span class="noop">                 (getattr(self.model.sequences, &#39;states&#39;, None) is None))):
</span><span class="miss">                continue
</span><span class="hit">            print(&#39;            . %s&#39; % func)
</span><span class="hit">            lines.add(1, &#39;cpdef inline void %s(self):&#39; % func)
</span><span class="hit">            for (name, subseqs) in self.model.sequences:
</span><span class="hit">                if func == &#39;loaddata&#39;:
</span><span class="hit">                    applyfuncs = (&#39;inputs&#39;,)
</span><span class="hit">                elif func == &#39;savedata&#39;:
</span><span class="hit">                    applyfuncs = (&#39;fluxes&#39;, &#39;states&#39;)
</span><span class="noop">                else:
</span><span class="hit">                    applyfuncs = (&#39;inputs&#39;, &#39;fluxes&#39;, &#39;states&#39;)
</span><span class="hit">                if name in applyfuncs:
</span><span class="hit">                    if func == &#39;closefiles&#39;:
</span><span class="hit">                        lines.add(2, &#39;self.%s.%s()&#39; % (name, func))
</span><span class="noop">                    else:
</span><span class="hit">                        lines.add(2, &#39;self.%s.%s(self.idx_sim)&#39; % (name, func))
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def new2old(self):
</span><span class="hit">        lines = Lines()
</span><span class="hit">        if getattr(self.model.sequences, &#39;states&#39;, None) is not None:
</span><span class="hit">            print(&#39;                . new2old&#39;)
</span><span class="hit">            lines.add(1, &#39;cpdef inline void new2old(self):&#39;)
</span><span class="hit">            lines.add(2, &#39;cdef int jdx0, jdx1, jdx2, jdx3, jdx4, jdx5&#39;)
</span><span class="hit">            for (name, seq) in sorted(self.model.sequences.states):
</span><span class="hit">                if seq.NDIM == 0:
</span><span class="hit">                    lines.add(2, &#39;self.old_states.%s = self.new_states.%s&#39;
</span><span class="noop">                                 % (2*(name,)))
</span><span class="noop">                else:
</span><span class="hit">                    indexing = &#39;&#39;
</span><span class="hit">                    for idx in range(seq.NDIM):
</span><span class="hit">                        lines.add(
</span><span class="noop">                            2+idx,
</span><span class="noop">                            &#39;for jdx%d in range(self.states._%s_length_%d):&#39;
</span><span class="noop">                            % (idx, name, idx))
</span><span class="hit">                        indexing += &#39;jdx%d,&#39; % idx
</span><span class="hit">                    indexing = indexing[:-1]
</span><span class="hit">                    lines.add(
</span><span class="noop">                        2+seq.NDIM,
</span><span class="noop">                        &#39;self.old_states.%s[%s] = self.new_states.%s[%s]&#39;
</span><span class="noop">                        % (2*(name, indexing)))
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def run(self):
</span><span class="hit">        lines = Lines()
</span><span class="hit">        lines.add(1, &#39;cpdef inline void run(self):&#39;)
</span><span class="hit">        anything = False
</span><span class="hit">        for method in self.model._RUNMETHODS:
</span><span class="hit">            if not method.__name__.startswith(&#39;update_&#39;):
</span><span class="hit">                lines.add(2, &#39;self.%s()&#39; % method.__name__)
</span><span class="hit">                anything = True
</span><span class="hit">        if not anything:
</span><span class="miss">            lines.add(2, &#39;pass&#39;)
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def listofmodeluserfunctions(self):
</span><span class="noop">        &#34;&#34;&#34;User functions of the model class.&#34;&#34;&#34;
</span><span class="hit">        lines = []
</span><span class="hit">        for (name, member) in vars(self.model.__class__).items():
</span><span class="hit">            if (inspect.isfunction(member) and
</span><span class="noop">                    (name not in (&#39;run&#39;, &#39;new2old&#39;)) and
</span><span class="noop">                    (&#39;fastaccess&#39; in inspect.getsource(member))):
</span><span class="miss">                lines.append((name, member))
</span><span class="hit">        run = vars(self.model.__class__).get(&#39;run&#39;)
</span><span class="hit">        if run is not None:
</span><span class="miss">            lines.append((&#39;run&#39;, run))
</span><span class="hit">        for (name, member) in vars(self.model).items():
</span><span class="hit">            if (inspect.ismethod(member) and
</span><span class="noop">                    (&#39;fastaccess&#39; in inspect.getsource(member))):
</span><span class="hit">                lines.append((name, member))
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def modeluserfunctions(self):
</span><span class="hit">        lines = Lines()
</span><span class="hit">        for (name, func) in self.listofmodeluserfunctions:
</span><span class="hit">            print(&#39;            . %s&#39; % name)
</span><span class="hit">            funcconverter = FuncConverter(self.model, name, func)
</span><span class="hit">            lines.extend(funcconverter.pyxlines)
</span><span class="hit">        return lines
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FuncConverter(object):
</span><span class="noop">
</span><span class="hit">    def __init__(self, model, funcname, func):
</span><span class="hit">        self.model = model
</span><span class="hit">        self.funcname = funcname
</span><span class="hit">        self.func = func
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def argnames(self):
</span><span class="miss">        return inspect.getargs(self.func.__code__)[0]
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def varnames(self):
</span><span class="hit">        return self.func.__code__.co_varnames
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def locnames(self):
</span><span class="miss">        return [vn for vn in self.varnames if vn not in self.argnames]
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def sourcelines(self):
</span><span class="miss">        return Lines(*inspect.getsourcelines(self.func)[0])
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def collectornames(self):
</span><span class="hit">        names = []
</span><span class="hit">        for things in (self.model.parameters, self.model.sequences):
</span><span class="hit">            for (name, thing) in things:
</span><span class="hit">                if name[:3] in self.varnames:
</span><span class="hit">                    names.append(name)
</span><span class="hit">        if &#39;old&#39; in self.varnames:
</span><span class="hit">            names.append(&#39;old_states&#39;)
</span><span class="hit">        if &#39;new&#39; in self.varnames:
</span><span class="hit">            names.append(&#39;new_states&#39;)
</span><span class="hit">        return names
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def collectorshortcuts(self):
</span><span class="hit">        return [name[:3] for name in self.collectornames]
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def untypedvarnames(self):
</span><span class="hit">        return [name for name in self.varnames
</span><span class="noop">                if name not in (self.collectorshortcuts + [&#39;self&#39;])]
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def untypedarguments(self):
</span><span class="hit">        defline = self.cleanlines[0]
</span><span class="hit">        return [name for name in self.untypedvarnames
</span><span class="noop">                if ((&#39;, %s,&#39; % name in defline) or
</span><span class="noop">                    (&#39;, %s)&#39; % name in defline))]
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def untypedinternalvarnames(self):
</span><span class="hit">        return [name for name in self.untypedvarnames if
</span><span class="noop">                name not in self.untypedarguments]
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def cleanlines(self):
</span><span class="noop">        &#34;&#34;&#34;Cleaned code lines.
</span><span class="noop">
</span><span class="noop">        Implemented cleanups:
</span><span class="noop">          * eventually remove method version
</span><span class="noop">          * remove docstrings
</span><span class="noop">          * remove comments
</span><span class="noop">          * remove empty lines
</span><span class="noop">          * replace `modelutils` with nothing
</span><span class="noop">          * remove complete lines containing `fastaccess`
</span><span class="noop">          * replace shortcuts with complete references
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        code = inspect.getsource(self.func)
</span><span class="hit">        code = &#39;\n&#39;.join(code.split(&#39;&#34;&#34;&#34;&#39;)[::2])
</span><span class="hit">        code = code.replace(&#39;modelutils.&#39;, &#39;&#39;)
</span><span class="hit">        for (name, shortcut) in zip(self.collectornames,
</span><span class="noop">                                    self.collectorshortcuts):
</span><span class="hit">            code = code.replace(&#39;%s.&#39; % shortcut, &#39;self.%s.&#39; % name)
</span><span class="hit">        lines = code.splitlines()
</span><span class="hit">        lines[0] = &#39;def %s(self):&#39; % self.funcname
</span><span class="hit">        lines = [l.split(&#39;#&#39;)[0] for l in lines]
</span><span class="hit">        lines = [l for l in lines if &#39;fastaccess&#39; not in l]
</span><span class="hit">        lines = [l.rstrip() for l in lines if l.rstrip()]
</span><span class="hit">        return Lines(*lines)
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def pyxlines(self):
</span><span class="noop">        &#34;&#34;&#34;Cython code lines.
</span><span class="noop">
</span><span class="noop">        Assumptions:
</span><span class="noop">          * Function shall be a method
</span><span class="noop">          * Method shall be inlined
</span><span class="noop">          * Method returns nothing
</span><span class="noop">          * Method arguments are of type `int` (except self)
</span><span class="noop">          * Local variables are of type `int`
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        lines = [&#39;    &#39;+line for line in self.cleanlines]
</span><span class="hit">        lines[0] = lines[0].replace(&#39;def &#39;, &#39;cpdef inline void &#39;)
</span><span class="hit">        for name in self.untypedarguments:
</span><span class="miss">            lines[0] = lines[0].replace(&#39;, %s &#39; % name, &#39;, int %s &#39; % name)
</span><span class="miss">            lines[0] = lines[0].replace(&#39;, %s)&#39; % name, &#39;, int %s)&#39; % name)
</span><span class="hit">        if self.untypedinternalvarnames:
</span><span class="hit">            lines.insert(1, &#39;        cdef int &#39; +
</span><span class="noop">                            &#39;, &#39;.join(self.untypedinternalvarnames))
</span><span class="hit">        return Lines(*lines)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def exp(double):
</span><span class="noop">    &#34;&#34;&#34;Cython wrapper for numpys exp function applied on a single float.&#34;&#34;&#34;
</span><span class="hit">    return numpy.exp(double)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def fabs(double):
</span><span class="noop">    &#34;&#34;&#34;Cython wrapper for maths fabs function applied on a single float.&#34;&#34;&#34;
</span><span class="hit">    return math.fabs(double)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/docs/__init__.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/docs/__init__.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre></pre>
      </td>
      <td class="source">
        <pre></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/docs/apidoc.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/docs/apidoc.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">
</span><span class="miss">import os
</span><span class="miss">import webbrowser
</span><span class="noop">
</span><span class="miss">os.system(r&#39;make clean&#39;)
</span><span class="miss">os.system(r&#39;make html&#39;)
</span><span class="noop">
</span><span class="miss">paths = [os.path.join(&#39;_build&#39;, &#39;html&#39;, fn)
</span><span class="noop">         for fn in os.listdir(os.path.join(&#39;_build&#39;, &#39;html&#39;))
</span><span class="noop">         if fn.endswith(&#39;.html&#39;)]
</span><span class="miss">for path in paths:
</span><span class="miss">    lines = []
</span><span class="miss">    for line in open(path):
</span><span class="miss">        if line.startswith(&#39;&lt;dd&gt;&lt;p&gt;alias of &lt;a class=&#34;reference external&#34;&#39;):
</span><span class="miss">            line = line.split(&#39;span&#39;)[1]
</span><span class="miss">            line = line.split(&#39;&gt;&#39;)[1]
</span><span class="miss">            line = line.split(&#39;&lt;&#39;)[0]
</span><span class="miss">            lines[-1] = lines[-1].replace(
</span><span class="noop">                    &#39;TYPE&lt;/code&gt;&#39;,
</span><span class="noop">                    &#39;TYPE&lt;/code&gt;&lt;em class=&#34;property&#34;&gt; = %s&lt;/em&gt;&#39; % line)
</span><span class="noop">        else:
</span><span class="miss">            lines.append(line)
</span><span class="miss">    open(path, &#39;w&#39;).write(&#39;&#39;.join(lines))
</span><span class="noop">
</span><span class="noop">
</span><span class="miss">os.chdir(r&#39;C:\Program Files (x86)\Mozilla Firefox&#39;)
</span><span class="miss">webbrowser.register(&#39;firefox&#39;, None, webbrowser.GenericBrowser(&#39;firefox&#39;), 1)
</span><span class="miss">webbrowser.get(&#39;firefox&#39;).open_new_tab(
</span><span class="noop">                                r&#39;C:\HydPy\hydpy\docs\_build\html\index.html&#39;)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/docs/conf.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/docs/conf.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">#
</span><span class="noop"># HydPy documentation build configuration file, created by
</span><span class="noop"># sphinx-quickstart on Thu Jun 09 14:33:31 2016.
</span><span class="noop">#
</span><span class="noop"># This file is execfile()d with the current directory set to its containing dir.
</span><span class="noop">#
</span><span class="noop"># Note that not all possible configuration values are present in this
</span><span class="noop"># autogenerated file.
</span><span class="noop">#
</span><span class="noop"># All configuration values have a default; values that are commented out
</span><span class="noop"># serve to show the default.
</span><span class="noop">
</span><span class="hit">import sys, os
</span><span class="noop">
</span><span class="noop"># If extensions (or modules to document with autodoc) are in another directory,
</span><span class="noop"># add these directories to sys.path here. If the directory is relative to the
</span><span class="noop"># documentation root, use os.path.abspath to make it absolute, like shown here.
</span><span class="hit">sys.path.insert(0, os.path.abspath(&#39;..\\..\\&#39;))
</span><span class="noop">
</span><span class="noop"># -- General configuration -----------------------------------------------------
</span><span class="noop">
</span><span class="noop"># If your documentation needs a minimal Sphinx version, state it here.
</span><span class="noop">#needs_sphinx = &#39;1.0&#39;
</span><span class="noop">
</span><span class="noop"># Add any Sphinx extension module names here, as strings. They can be extensions
</span><span class="noop"># coming with Sphinx (named &#39;sphinx.ext.*&#39;) or your custom ones.
</span><span class="hit">extensions = [&#39;sphinx.ext.autodoc&#39;,
</span><span class="noop">              &#39;sphinx.ext.napoleon&#39;,
</span><span class="noop">              &#39;sphinx.ext.intersphinx&#39;,
</span><span class="noop">              &#39;sphinx.ext.viewcode&#39;,
</span><span class="noop">              &#39;sphinx.ext.inheritance_diagram&#39;,
</span><span class="noop">              &#39;sphinx.ext.mathjax&#39;]
</span><span class="noop">
</span><span class="hit">autoclass_content = &#39;class&#39;
</span><span class="hit">autodoc_default_flags = [&#39;undoc-members&#39;]
</span><span class="hit">autodoc_member_order = &#39;bysource&#39;
</span><span class="noop">
</span><span class="noop"># Napoleon settings
</span><span class="hit">napoleon_google_docstring = False
</span><span class="hit">napoleon_numpy_docstring = False
</span><span class="hit">napoleon_include_private_with_doc = False
</span><span class="hit">napoleon_include_special_with_doc = False
</span><span class="hit">napoleon_use_admonition_for_examples = False
</span><span class="hit">napoleon_use_admonition_for_notes = False
</span><span class="hit">napoleon_use_admonition_for_references = False
</span><span class="hit">napoleon_use_ivar = False
</span><span class="hit">napoleon_use_param = False
</span><span class="hit">napoleon_use_rtype = False
</span><span class="noop">
</span><span class="hit">intersphinx_mapping = {&#39;python&#39;: (&#39;https://docs.python.org/2.7&#39;, None)}
</span><span class="noop">
</span><span class="noop"># Add any paths that contain templates here, relative to this directory.
</span><span class="hit">templates_path = [&#39;_templates&#39;]
</span><span class="noop">
</span><span class="noop"># The suffix of source filenames.
</span><span class="hit">source_suffix = &#39;.rst&#39;
</span><span class="noop">
</span><span class="noop"># The encoding of source files.
</span><span class="noop">#source_encoding = &#39;utf-8-sig&#39;
</span><span class="noop">
</span><span class="noop"># The master toctree document.
</span><span class="hit">master_doc = &#39;index&#39;
</span><span class="noop">
</span><span class="noop"># General information about the project.
</span><span class="hit">project = u&#39;HydPy&#39;
</span><span class="hit">copyright = u&#39;2017, Christoph Tyralla&#39;
</span><span class="noop">
</span><span class="noop"># The version info for the project you&#39;re documenting, acts as replacement for
</span><span class="noop"># |version| and |release|, also used in various other places throughout the
</span><span class="noop"># built documents.
</span><span class="noop">#
</span><span class="noop"># The short X.Y version.
</span><span class="hit">version = &#39;2.0&#39;
</span><span class="noop"># The full version, including alpha/beta/rc tags.
</span><span class="hit">release = &#39;2.0.0&#39;
</span><span class="noop">
</span><span class="noop"># The language for content autogenerated by Sphinx. Refer to documentation
</span><span class="noop"># for a list of supported languages.
</span><span class="noop">#language = None
</span><span class="noop">
</span><span class="noop"># There are two options for replacing |today|: either, you set today to some
</span><span class="noop"># non-false value, then it is used:
</span><span class="noop">#today = &#39;&#39;
</span><span class="noop"># Else, today_fmt is used as the format for a strftime call.
</span><span class="noop">#today_fmt = &#39;%B %d, %Y&#39;
</span><span class="noop">
</span><span class="noop"># List of patterns, relative to source directory, that match files and
</span><span class="noop"># directories to ignore when looking for source files.
</span><span class="hit">exclude_patterns = [&#39;_build&#39;]
</span><span class="noop">
</span><span class="noop"># The reST default role (used for this markup: `text`) to use for all documents.
</span><span class="noop">#default_role = None
</span><span class="noop">
</span><span class="noop"># If true, &#39;()&#39; will be appended to :func: etc. cross-reference text.
</span><span class="hit">add_function_parentheses = True
</span><span class="noop">
</span><span class="noop"># If true, the current module name will be prepended to all description
</span><span class="noop"># unit titles (such as .. function::).
</span><span class="noop">#add_module_names = True
</span><span class="noop">
</span><span class="noop"># If true, sectionauthor and moduleauthor directives will be shown in the
</span><span class="noop"># output. They are ignored by default.
</span><span class="noop">#show_authors = False
</span><span class="noop">
</span><span class="noop"># The name of the Pygments (syntax highlighting) style to use.
</span><span class="hit">pygments_style = &#39;sphinx&#39;
</span><span class="noop">
</span><span class="noop"># A list of ignored prefixes for module index sorting.
</span><span class="noop">#modindex_common_prefix = []
</span><span class="noop">
</span><span class="noop">
</span><span class="noop"># -- Options for HTML output ---------------------------------------------------
</span><span class="noop">
</span><span class="noop"># The theme to use for HTML and HTML Help pages.  See the documentation for
</span><span class="noop"># a list of builtin themes.
</span><span class="hit">html_theme = &#39;default&#39;
</span><span class="noop">
</span><span class="noop"># Theme options are theme-specific and customize the look and feel of a theme
</span><span class="noop"># further.  For a list of options available for each theme, see the
</span><span class="noop"># documentation.
</span><span class="hit">html_theme_options = {&#39;stickysidebar&#39;: True}
</span><span class="noop">
</span><span class="noop"># Add any paths that contain custom themes here, relative to this directory.
</span><span class="noop">#html_theme_path = []
</span><span class="noop">
</span><span class="noop"># The name for this set of Sphinx documents.  If None, it defaults to
</span><span class="noop"># &#34;&lt;project&gt; v&lt;release&gt; documentation&#34;.
</span><span class="noop">#html_title = None
</span><span class="noop">
</span><span class="noop"># A shorter title for the navigation bar.  Default is the same as html_title.
</span><span class="noop">#html_short_title = None
</span><span class="noop">
</span><span class="noop"># The name of an image file (relative to this directory) to place at the top
</span><span class="noop"># of the sidebar.
</span><span class="noop">#html_logo = None
</span><span class="noop">
</span><span class="noop"># The name of an image file (within the static path) to use as favicon of the
</span><span class="noop"># docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
</span><span class="noop"># pixels large.
</span><span class="noop">#html_favicon = None
</span><span class="noop">
</span><span class="noop"># Add any paths that contain custom static files (such as style sheets) here,
</span><span class="noop"># relative to this directory. They are copied after the builtin static files,
</span><span class="noop"># so a file named &#34;default.css&#34; will overwrite the builtin &#34;default.css&#34;.
</span><span class="hit">html_static_path = []
</span><span class="noop">
</span><span class="noop"># If not &#39;&#39;, a &#39;Last updated on:&#39; timestamp is inserted at every page bottom,
</span><span class="noop"># using the given strftime format.
</span><span class="noop">#html_last_updated_fmt = &#39;%b %d, %Y&#39;
</span><span class="noop">
</span><span class="noop"># If true, SmartyPants will be used to convert quotes and dashes to
</span><span class="noop"># typographically correct entities.
</span><span class="noop">#html_use_smartypants = True
</span><span class="noop">
</span><span class="noop"># Custom sidebar templates, maps document names to template names.
</span><span class="noop">#html_sidebars = {}
</span><span class="noop">
</span><span class="noop"># Additional templates that should be rendered to pages, maps page names to
</span><span class="noop"># template names.
</span><span class="noop">#html_additional_pages = {}
</span><span class="noop">
</span><span class="noop"># If false, no module index is generated.
</span><span class="noop">#html_domain_indices = True
</span><span class="noop">
</span><span class="noop"># If false, no index is generated.
</span><span class="noop">#html_use_index = True
</span><span class="noop">
</span><span class="noop"># If true, the index is split into individual pages for each letter.
</span><span class="noop">#html_split_index = False
</span><span class="noop">
</span><span class="noop"># If true, links to the reST sources are added to the pages.
</span><span class="noop">#html_show_sourcelink = True
</span><span class="noop">
</span><span class="noop"># If true, &#34;Created using Sphinx&#34; is shown in the HTML footer. Default is True.
</span><span class="noop">#html_show_sphinx = True
</span><span class="noop">
</span><span class="noop"># If true, &#34;(C) Copyright ...&#34; is shown in the HTML footer. Default is True.
</span><span class="noop">#html_show_copyright = True
</span><span class="noop">
</span><span class="noop"># If true, an OpenSearch description file will be output, and all pages will
</span><span class="noop"># contain a &lt;link&gt; tag referring to it.  The value of this option must be the
</span><span class="noop"># base URL from which the finished HTML is served.
</span><span class="noop">#html_use_opensearch = &#39;&#39;
</span><span class="noop">
</span><span class="noop"># This is the file name suffix for HTML files (e.g. &#34;.xhtml&#34;).
</span><span class="noop">#html_file_suffix = None
</span><span class="noop">
</span><span class="noop"># Output file base name for HTML help builder.
</span><span class="hit">htmlhelp_basename = &#39;HydPydoc&#39;
</span><span class="noop">
</span><span class="noop">
</span><span class="noop"># -- Options for LaTeX output --------------------------------------------------
</span><span class="noop">
</span><span class="hit">latex_elements = {
</span><span class="noop"># The paper size (&#39;letterpaper&#39; or &#39;a4paper&#39;).
</span><span class="noop">#&#39;papersize&#39;: &#39;letterpaper&#39;,
</span><span class="noop">
</span><span class="noop"># The font size (&#39;10pt&#39;, &#39;11pt&#39; or &#39;12pt&#39;).
</span><span class="noop">#&#39;pointsize&#39;: &#39;10pt&#39;,
</span><span class="noop">
</span><span class="noop"># Additional stuff for the LaTeX preamble.
</span><span class="noop">#&#39;preamble&#39;: &#39;&#39;,
</span><span class="noop">}
</span><span class="noop">
</span><span class="noop"># Grouping the document tree into LaTeX files. List of tuples
</span><span class="noop"># (source start file, target name, title, author, documentclass [howto/manual]).
</span><span class="hit">latex_documents = [
</span><span class="noop">  (&#39;index&#39;, &#39;HydPy.tex&#39;, u&#39;HydPy Documentation&#39;,
</span><span class="noop">   u&#39;Christoph Tyralla&#39;, &#39;manual&#39;),
</span><span class="noop">]
</span><span class="noop">
</span><span class="noop"># The name of an image file (relative to this directory) to place at the top of
</span><span class="noop"># the title page.
</span><span class="noop">#latex_logo = None
</span><span class="noop">
</span><span class="noop"># For &#34;manual&#34; documents, if this is true, then toplevel headings are parts,
</span><span class="noop"># not chapters.
</span><span class="noop">#latex_use_parts = False
</span><span class="noop">
</span><span class="noop"># If true, show page references after internal links.
</span><span class="noop">#latex_show_pagerefs = False
</span><span class="noop">
</span><span class="noop"># If true, show URL addresses after external links.
</span><span class="noop">#latex_show_urls = False
</span><span class="noop">
</span><span class="noop"># Documents to append as an appendix to all manuals.
</span><span class="noop">#latex_appendices = []
</span><span class="noop">
</span><span class="noop"># If false, no module index is generated.
</span><span class="noop">#latex_domain_indices = True
</span><span class="noop">
</span><span class="noop">
</span><span class="noop"># -- Options for manual page output --------------------------------------------
</span><span class="noop">
</span><span class="noop"># One entry per manual page. List of tuples
</span><span class="noop"># (source start file, name, description, authors, manual section).
</span><span class="hit">man_pages = [
</span><span class="noop">    (&#39;index&#39;, &#39;hydpy&#39;, u&#39;HydPy Documentation&#39;,
</span><span class="noop">     [u&#39;Christoph Tyralla&#39;], 1)
</span><span class="noop">]
</span><span class="noop">
</span><span class="noop"># If true, show URL addresses after external links.
</span><span class="noop">#man_show_urls = False
</span><span class="noop">
</span><span class="noop">
</span><span class="noop"># -- Options for Texinfo output ------------------------------------------------
</span><span class="noop">
</span><span class="noop"># Grouping the document tree into Texinfo files. List of tuples
</span><span class="noop"># (source start file, target name, title, author,
</span><span class="noop">#  dir menu entry, description, category)
</span><span class="hit">texinfo_documents = [
</span><span class="noop">  (&#39;index&#39;, &#39;HydPy&#39;, u&#39;HydPy Documentation&#39;,
</span><span class="noop">   u&#39;Christoph Tyralla&#39;, &#39;HydPy&#39;, &#39;One line description of project.&#39;,
</span><span class="noop">   &#39;Miscellaneous&#39;),
</span><span class="noop">]
</span><span class="noop">
</span><span class="noop"># Documents to append as an appendix to all manuals.
</span><span class="noop">#texinfo_appendices = []
</span><span class="noop">
</span><span class="noop"># If false, no module index is generated.
</span><span class="noop">#texinfo_domain_indices = True
</span><span class="noop">
</span><span class="noop"># How to display URL addresses: &#39;footnote&#39;, &#39;no&#39;, or &#39;inline&#39;.
</span><span class="noop">#texinfo_show_urls = &#39;footnote&#39;
</span><span class="noop">
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/__init__.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/__init__.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre></pre>
      </td>
      <td class="source">
        <pre></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hbranch_v1.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hbranch_v1.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core.modelimports import *
</span><span class="hit">from hydpy.core import parametertools
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop"># ...from hbranch
</span><span class="hit">from hydpy.models.hbranch import hbranch_model
</span><span class="hit">from hydpy.models.hbranch import hbranch_control
</span><span class="hit">from hydpy.models.hbranch import hbranch_derived
</span><span class="hit">from hydpy.models.hbranch import hbranch_fluxes
</span><span class="hit">from hydpy.models.hbranch import hbranch_inlets
</span><span class="hit">from hydpy.models.hbranch import hbranch_outlets
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Model(hbranch_model.Model):
</span><span class="noop">    &#34;&#34;&#34;The HBV96 version of HydPy-H-Stream (hbranch_v1).&#34;&#34;&#34;
</span><span class="hit">    _RUNMETHODS = (hbranch_model.calc_outputs_v1,
</span><span class="noop">                   hbranch_model.update_inlets_v1,
</span><span class="noop">                   hbranch_model.update_outlets_v1)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ControlParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Control parameters of hbranch_v1, directly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (hbranch_control.XPoints,
</span><span class="noop">                   hbranch_control.YPoints)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class DerivedParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Derived parameters of hbranch_v1, indirectly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (hbranch_derived.NmbBranches,
</span><span class="noop">                   hbranch_derived.NmbPoints)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FluxSequences(sequencetools.FluxSequences):
</span><span class="noop">    &#34;&#34;&#34;Flux sequences of hbranch_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (hbranch_fluxes.Input,
</span><span class="noop">                   hbranch_fluxes.Outputs)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class InletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Upstream link sequences of hbranch_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (hbranch_inlets.Total,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class OutletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Downstream link sequences of hbranch_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (hbranch_outlets.Branched,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">tester = Tester()
</span><span class="hit">cythonizer = Cythonizer()
</span><span class="hit">cythonizer.complete()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland_v1.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland_v1.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core.modelimports import *
</span><span class="hit">from hydpy.core import modeltools
</span><span class="hit">from hydpy.core import parametertools
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop"># ...from hland
</span><span class="hit">from hydpy.models.hland import hland_model
</span><span class="hit">from hydpy.models.hland import hland_control
</span><span class="hit">from hydpy.models.hland import hland_derived
</span><span class="hit">from hydpy.models.hland import hland_inputs
</span><span class="hit">from hydpy.models.hland import hland_fluxes
</span><span class="hit">from hydpy.models.hland import hland_states
</span><span class="hit">from hydpy.models.hland import hland_aides
</span><span class="hit">from hydpy.models.hland import hland_logs
</span><span class="hit">from hydpy.models.hland import hland_outlets
</span><span class="hit">from hydpy.models.hland.hland_parameters import Parameters
</span><span class="hit">from hydpy.models.hland.hland_constants import *
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Model(modeltools.Model):
</span><span class="noop">    &#34;&#34;&#34;HBV96 version of HydPy-H-Land (hland_v1).&#34;&#34;&#34;
</span><span class="hit">    _RUNMETHODS = (hland_model.calc_tc_v1,
</span><span class="noop">                   hland_model.calc_tmean_v1,
</span><span class="noop">                   hland_model.calc_fracrain_v1,
</span><span class="noop">                   hland_model.calc_rfc_sfc_v1,
</span><span class="noop">                   hland_model.calc_pc_v1,
</span><span class="noop">                   hland_model.calc_ep_v1,
</span><span class="noop">                   hland_model.calc_epc_v1,
</span><span class="noop">                   hland_model.calc_tf_ic_v1,
</span><span class="noop">                   hland_model.calc_ei_ic_v1,
</span><span class="noop">                   hland_model.calc_sp_wc_v1,
</span><span class="noop">                   hland_model.calc_melt_sp_wc_v1,
</span><span class="noop">                   hland_model.calc_refr_sp_wc_v1,
</span><span class="noop">                   hland_model.calc_glmelt_in_v1,
</span><span class="noop">                   hland_model.calc_in_wc_v1,
</span><span class="noop">                   hland_model.calc_r_sm_v1,
</span><span class="noop">                   hland_model.calc_cf_sm_v1,
</span><span class="noop">                   hland_model.calc_ea_sm_v1,
</span><span class="noop">                   hland_model.calc_inuz_v1,
</span><span class="noop">                   hland_model.calc_contriarea_v1,
</span><span class="noop">                   hland_model.calc_q0_perc_uz_v1,
</span><span class="noop">                   hland_model.calc_lz_v1,
</span><span class="noop">                   hland_model.calc_el_lz_v1,
</span><span class="noop">                   hland_model.calc_q1_lz_v1,
</span><span class="noop">                   hland_model.calc_inuh_v1,
</span><span class="noop">                   hland_model.calc_outuh_quh_v1,
</span><span class="noop">                   hland_model.calc_qt_v1,
</span><span class="noop">                   hland_model.update_outlets_v1)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ControlParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Control parameters of hland_v1, directly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (hland_control.Area,
</span><span class="noop">                   hland_control.NmbZones,
</span><span class="noop">                   hland_control.ZoneType,
</span><span class="noop">                   hland_control.ZoneArea,
</span><span class="noop">                   hland_control.ZoneZ,
</span><span class="noop">                   hland_control.ZRelP,
</span><span class="noop">                   hland_control.ZRelT,
</span><span class="noop">                   hland_control.ZRelE,
</span><span class="noop">                   hland_control.PCorr,
</span><span class="noop">                   hland_control.PCAlt,
</span><span class="noop">                   hland_control.RfCF,
</span><span class="noop">                   hland_control.SfCF,
</span><span class="noop">                   hland_control.TCAlt,
</span><span class="noop">                   hland_control.ECorr,
</span><span class="noop">                   hland_control.ECAlt,
</span><span class="noop">                   hland_control.EPF,
</span><span class="noop">                   hland_control.ETF,
</span><span class="noop">                   hland_control.ERed,
</span><span class="noop">                   hland_control.TTIce,
</span><span class="noop">                   hland_control.IcMax,
</span><span class="noop">                   hland_control.TT,
</span><span class="noop">                   hland_control.TTInt,
</span><span class="noop">                   hland_control.DTTM,
</span><span class="noop">                   hland_control.CFMax,
</span><span class="noop">                   hland_control.GMelt,
</span><span class="noop">                   hland_control.CFR,
</span><span class="noop">                   hland_control.WHC,
</span><span class="noop">                   hland_control.FC,
</span><span class="noop">                   hland_control.LP,
</span><span class="noop">                   hland_control.Beta,
</span><span class="noop">                   hland_control.PercMax,
</span><span class="noop">                   hland_control.CFlux,
</span><span class="noop">                   hland_control.RespArea,
</span><span class="noop">                   hland_control.RecStep,
</span><span class="noop">                   hland_control.Alpha,
</span><span class="noop">                   hland_control.K,
</span><span class="noop">                   hland_control.K4,
</span><span class="noop">                   hland_control.Gamma,
</span><span class="noop">                   hland_control.MaxBaz,
</span><span class="noop">                   hland_control.Abstr)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class DerivedParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Derived parameters of hland_v1, indirectly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (hland_derived.RelZoneArea,
</span><span class="noop">                   hland_derived.RelSoilArea,
</span><span class="noop">                   hland_derived.RelSoilZoneArea,
</span><span class="noop">                   hland_derived.RelLandZoneArea,
</span><span class="noop">                   hland_derived.RelLandArea,
</span><span class="noop">                   hland_derived.TTM,
</span><span class="noop">                   hland_derived.DT,
</span><span class="noop">                   hland_derived.NmbUH,
</span><span class="noop">                   hland_derived.UH,
</span><span class="noop">                   hland_derived.QFactor)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class InputSequences(sequencetools.InputSequences):
</span><span class="noop">    &#34;&#34;&#34;Input sequences of hland_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (hland_inputs.P,
</span><span class="noop">                   hland_inputs.T,
</span><span class="noop">                   hland_inputs.TN,
</span><span class="noop">                   hland_inputs.EPN)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FluxSequences(sequencetools.FluxSequences):
</span><span class="noop">    &#34;&#34;&#34;Flux sequences of hland_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (hland_fluxes.TMean,
</span><span class="noop">                   hland_fluxes.TC,
</span><span class="noop">                   hland_fluxes.FracRain,
</span><span class="noop">                   hland_fluxes.RfC,
</span><span class="noop">                   hland_fluxes.SfC,
</span><span class="noop">                   hland_fluxes.PC,
</span><span class="noop">                   hland_fluxes.EP,
</span><span class="noop">                   hland_fluxes.EPC,
</span><span class="noop">                   hland_fluxes.EI,
</span><span class="noop">                   hland_fluxes.TF,
</span><span class="noop">                   hland_fluxes.TFWat,
</span><span class="noop">                   hland_fluxes.TFIce,
</span><span class="noop">                   hland_fluxes.GlMelt,
</span><span class="noop">                   hland_fluxes.MeltPot,
</span><span class="noop">                   hland_fluxes.Melt,
</span><span class="noop">                   hland_fluxes.RefrPot,
</span><span class="noop">                   hland_fluxes.Refr,
</span><span class="noop">                   hland_fluxes.In_,
</span><span class="noop">                   hland_fluxes.R,
</span><span class="noop">                   hland_fluxes.EA,
</span><span class="noop">                   hland_fluxes.CFPot,
</span><span class="noop">                   hland_fluxes.CF,
</span><span class="noop">                   hland_fluxes.Perc,
</span><span class="noop">                   hland_fluxes.ContriArea,
</span><span class="noop">                   hland_fluxes.InUZ,
</span><span class="noop">                   hland_fluxes.Q0,
</span><span class="noop">                   hland_fluxes.EL,
</span><span class="noop">                   hland_fluxes.Q1,
</span><span class="noop">                   hland_fluxes.InUH,
</span><span class="noop">                   hland_fluxes.OutUH,
</span><span class="noop">                   hland_fluxes.QT)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class StateSequences(sequencetools.StateSequences):
</span><span class="noop">    &#34;&#34;&#34;State sequences of hland_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (hland_states.Ic,
</span><span class="noop">                   hland_states.SP,
</span><span class="noop">                   hland_states.WC,
</span><span class="noop">                   hland_states.SM,
</span><span class="noop">                   hland_states.UZ,
</span><span class="noop">                   hland_states.LZ)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class LogSequences(sequencetools.AideSequences):
</span><span class="noop">    &#34;&#34;&#34;Aide sequences of hland_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (hland_logs.QUH,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class AideSequences(sequencetools.AideSequences):
</span><span class="noop">    &#34;&#34;&#34;Aide sequences of hland_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (hland_aides.Perc,
</span><span class="noop">                   hland_aides.Q0)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class OutletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Downstream link sequences of hland_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (hland_outlets.Q,)
</span><span class="noop">
</span><span class="hit">tester = Tester()
</span><span class="hit">cythonizer = Cythonizer()
</span><span class="hit">cythonizer.complete()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream_v1.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream_v1.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core.modelimports import *
</span><span class="hit">from hydpy.core import modeltools
</span><span class="hit">from hydpy.core import parametertools
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop"># ...from hstream
</span><span class="hit">from hydpy.models.hstream import hstream_model
</span><span class="hit">from hydpy.models.hstream import hstream_control
</span><span class="hit">from hydpy.models.hstream import hstream_derived
</span><span class="hit">from hydpy.models.hstream import hstream_states
</span><span class="hit">from hydpy.models.hstream import hstream_inlets
</span><span class="hit">from hydpy.models.hstream import hstream_outlets
</span><span class="hit">from hydpy.models.hstream.hstream_parameters import Parameters
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Model(modeltools.Model):
</span><span class="noop">    &#34;&#34;&#34;The HBV96 version of HydPy-H-Stream (hstream_v1).&#34;&#34;&#34;
</span><span class="hit">    _RUNMETHODS = (hstream_model.calc_qjoints_v1,
</span><span class="noop">                   hstream_model.update_inlets_v1,
</span><span class="noop">                   hstream_model.update_outlets_v1)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ControlParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Control parameters of hstream_v1, directly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (hstream_control.Lag,
</span><span class="noop">                   hstream_control.Damp)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class DerivedParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Derived parameters of hstream_v1, indirectly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (hstream_derived.NmbSegments,
</span><span class="noop">                   hstream_derived.C1,
</span><span class="noop">                   hstream_derived.C2,
</span><span class="noop">                   hstream_derived.C3)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class StateSequences(sequencetools.StateSequences):
</span><span class="noop">    &#34;&#34;&#34;State sequences of hstream_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (hstream_states.QJoints,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class InletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Upstream link sequences of stream_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (hstream_inlets.Q,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class OutletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Downstream link sequences of hstream_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (hstream_outlets.Q,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">tester = Tester()
</span><span class="hit">cythonizer = Cythonizer()
</span><span class="hit">cythonizer.complete()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake_v1.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake_v1.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;
</span><span class="noop">The LARSIM-Lake version of HydPy-L-Lake (called llake_v1) is a simple lake
</span><span class="noop">model. Its continuity equation is primarily solved via a central finite
</span><span class="noop">difference approach.  It allows for an arbitrary number of inflows and
</span><span class="noop">determines a single outflow value for each simulation time step.
</span><span class="noop">The relationships between water stage, water volume and the associated
</span><span class="noop">outflow are defined via vectors.  Between/beyond the triples defined by
</span><span class="noop">these vectors, linear interpolation/extrapolation is performed.
</span><span class="noop">The outflow vector is allowed to vary with seasonal pattern.  Therefore,
</span><span class="noop">different vectors for different times of the year need to be defined.
</span><span class="noop">Again, between these dates linear interpolation is performed to gain
</span><span class="noop">intermediate vectors.
</span><span class="noop">
</span><span class="noop">Two additional features are implemented.  Firstly, one can define a
</span><span class="noop">maximum drop of the water stage, which is not exceeded even when the
</span><span class="noop">triples of  water state, water volume and outflow indicate so.
</span><span class="noop">Secondly, water can be added to or substracted from the outflow
</span><span class="noop">calculated beforehand.  Both associated scalar parameters are allowed
</span><span class="noop">to vary in time, as explained for the outflow vector.
</span><span class="noop">
</span><span class="noop">Note that the accuracy of the results calculated by lake_v1 depend
</span><span class="noop">on the internal step size parameter
</span><span class="noop">:class:`~hydpy.models.llake.llake_control.MaxDT`.
</span><span class="noop">
</span><span class="noop">Integration examples:
</span><span class="noop">
</span><span class="noop">    The following are performed over a period of 20 days:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy import pub, Timegrid, Timegrids, Nodes, Element
</span><span class="noop">    &gt;&gt;&gt; pub.timegrids = Timegrids(Timegrid(&#39;01.01.2000&#39;,
</span><span class="noop">    ...                                    &#39;21.01.2000&#39;,
</span><span class="noop">    ...                                    &#39;1d&#39;))
</span><span class="noop">
</span><span class="noop">    Import the model and define the time settings:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.llake_v1 import *
</span><span class="noop">    &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">
</span><span class="noop">    For testing purposes, the model input shall be retrieved from the nodes
</span><span class="noop">    `input1` and `input2` and the model output shall be passed to node
</span><span class="noop">    `output`.  Firstly, define all nodes:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; nodes = Nodes(&#39;input1&#39;, &#39;input2&#39;, &#39;output&#39;)
</span><span class="noop">
</span><span class="noop">    Secondly, define the element &#34;lake&#34; and build the connections between
</span><span class="noop">    the nodes defined above and the `llake_v1` model instance:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; lake = Element(&#39;lake&#39;, inlets=[&#39;input1&#39;, &#39;input2&#39;], outlets=&#39;output&#39;)
</span><span class="noop">    &gt;&gt;&gt; lake.connect(model)
</span><span class="noop">
</span><span class="noop">    Prepare a test function object, which prints the respective values of
</span><span class="noop">    the model sequences `qz`, `qa`, `v`, and `w`.  The node sequence `sim`
</span><span class="noop">    is added in order to prove that the values calculated for `qa` are
</span><span class="noop">    actually passed to `sim`:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.testtools import Test
</span><span class="noop">    &gt;&gt;&gt; test = Test(lake,
</span><span class="noop">    ...             seqs=(fluxes.qz, fluxes.qa, nodes.output.sequences.sim,
</span><span class="noop">    ...                   states.v, states.w),
</span><span class="noop">    ...             inits={&#39;v&#39;: 0.,
</span><span class="noop">    ...                    &#39;w&#39;: 0.})
</span><span class="noop">    &gt;&gt;&gt; test.dateformat = &#39;%d.%m.&#39;
</span><span class="noop">
</span><span class="noop">    Set the values of those control parameter, which remain fixed for all
</span><span class="noop">    three example simulations, in the most simple manner:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; n(2)
</span><span class="noop">    &gt;&gt;&gt; w(0., 1.)
</span><span class="noop">    &gt;&gt;&gt; v(0., 1e6)
</span><span class="noop">    &gt;&gt;&gt; q(0., 10.)
</span><span class="noop">    &gt;&gt;&gt; maxdt(&#39;1d&#39;)
</span><span class="noop">
</span><span class="noop">    Define two flood events, one for each lake inflow:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; nodes.input1.sequences.sim.series = [
</span><span class="noop">    ...                         0., 0., 1., 3., 2., 1., 0., 0., 0., 0.,
</span><span class="noop">    ...                         0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]
</span><span class="noop">    &gt;&gt;&gt; nodes.input2.sequences.sim.series = [
</span><span class="noop">    ...                         0., 1., 5., 9., 8., 5., 3., 2., 1., 0.,
</span><span class="noop">    ...                         0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]
</span><span class="noop">
</span><span class="noop">    In the first example, neither a restriction regarding the maximum
</span><span class="noop">    water drop nor a water abstraction is defined.  Hence the sums of
</span><span class="noop">    the total input (qz) and of the final output (identical with qa) are
</span><span class="noop">    nearly the same.  The maximum of the final output occurs when
</span><span class="noop">    the falling limb of qz intersects with qa:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; maxdw(.0)
</span><span class="noop">    &gt;&gt;&gt; verzw(0.)
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |   date |   qz |       qa |   output |             v |        w |
</span><span class="noop">    ------------------------------------------------------------------
</span><span class="noop">    | 01.01. |  0.0 |      0.0 |      0.0 |           0.0 |      0.0 |
</span><span class="noop">    | 02.01. |  1.0 | 0.301676 | 0.301676 |  60335.195531 | 0.060335 |
</span><span class="noop">    | 03.01. |  6.0 | 2.231391 | 2.231391 | 385943.010518 | 0.385943 |
</span><span class="noop">    | 04.01. | 12.0 | 6.315244 | 6.315244 | 877105.886853 | 0.877106 |
</span><span class="noop">    | 05.01. | 10.0 | 9.141801 | 9.141801 | 951254.290316 | 0.951254 |
</span><span class="noop">    | 06.01. |  6.0 | 8.452893 | 8.452893 | 739324.327444 | 0.739324 |
</span><span class="noop">    | 07.01. |  3.0 | 6.067907 | 6.067907 | 474257.135467 | 0.474257 |
</span><span class="noop">    | 08.01. |  2.0 | 3.915203 | 3.915203 | 308783.556526 | 0.308784 |
</span><span class="noop">    | 09.01. |  1.0 | 2.457986 | 2.457986 |  182813.58946 | 0.182814 |
</span><span class="noop">    | 10.01. |  0.0 | 1.276631 | 1.276631 |  72512.652803 | 0.072513 |
</span><span class="noop">    | 11.01. |  0.0 | 0.506373 | 0.506373 |   28762.00195 | 0.028762 |
</span><span class="noop">    | 12.01. |  0.0 | 0.200852 | 0.200852 |  11408.391835 | 0.011408 |
</span><span class="noop">    | 13.01. |  0.0 | 0.079668 | 0.079668 |   4525.116314 | 0.004525 |
</span><span class="noop">    | 14.01. |  0.0 |   0.0316 |   0.0316 |   1794.878538 | 0.001795 |
</span><span class="noop">    | 15.01. |  0.0 | 0.012534 | 0.012534 |    711.935063 | 0.000712 |
</span><span class="noop">    | 16.01. |  0.0 | 0.004972 | 0.004972 |    282.387651 | 0.000282 |
</span><span class="noop">    | 17.01. |  0.0 | 0.001972 | 0.001972 |    112.008509 | 0.000112 |
</span><span class="noop">    | 18.01. |  0.0 | 0.000782 | 0.000782 |     44.427956 | 0.000044 |
</span><span class="noop">    | 19.01. |  0.0 |  0.00031 |  0.00031 |     17.622262 | 0.000018 |
</span><span class="noop">    | 20.01. |  0.0 | 0.000123 | 0.000123 |      6.989836 | 0.000007 |
</span><span class="noop">
</span><span class="noop">    When the maximum water drop is set to 0.1 m/d, the resulting
</span><span class="noop">    outflow hydrograph shows a plateau in its falling limb.  This
</span><span class="noop">    plateau is placed in the time period, where little inflow occurs
</span><span class="noop">    but the (potential) outflow is still high, due to large amounts
</span><span class="noop">    of stored water.  In this time period, qa is limited by the
</span><span class="noop">    maximum water drop allowed:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; maxdw(.1)
</span><span class="noop">    &gt;&gt;&gt; verzw(0.)
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |   date |   qz |       qa |   output |             v |        w |
</span><span class="noop">    ------------------------------------------------------------------
</span><span class="noop">    | 01.01. |  0.0 |      0.0 |      0.0 |           0.0 |      0.0 |
</span><span class="noop">    | 02.01. |  1.0 | 0.301676 | 0.301676 |  60335.195531 | 0.060335 |
</span><span class="noop">    | 03.01. |  6.0 | 2.231391 | 2.231391 | 385943.010518 | 0.385943 |
</span><span class="noop">    | 04.01. | 12.0 | 6.315244 | 6.315244 | 877105.886853 | 0.877106 |
</span><span class="noop">    | 05.01. | 10.0 | 9.141801 | 9.141801 | 951254.290316 | 0.951254 |
</span><span class="noop">    | 06.01. |  6.0 | 7.157407 | 7.157407 | 851254.290316 | 0.851254 |
</span><span class="noop">    | 07.01. |  3.0 | 4.157407 | 4.157407 | 751254.290316 | 0.751254 |
</span><span class="noop">    | 08.01. |  2.0 | 3.157407 | 3.157407 | 651254.290316 | 0.651254 |
</span><span class="noop">    | 09.01. |  1.0 | 2.157407 | 2.157407 | 551254.290316 | 0.551254 |
</span><span class="noop">    | 10.01. |  0.0 | 1.157407 | 1.157407 | 451254.290316 | 0.451254 |
</span><span class="noop">    | 11.01. |  0.0 | 1.157407 | 1.157407 | 351254.290316 | 0.351254 |
</span><span class="noop">    | 12.01. |  0.0 | 1.157407 | 1.157407 | 251254.290316 | 0.251254 |
</span><span class="noop">    | 13.01. |  0.0 | 1.157407 | 1.157407 | 151254.290316 | 0.151254 |
</span><span class="noop">    | 14.01. |  0.0 | 1.056245 | 1.056245 |  59994.718505 | 0.059995 |
</span><span class="noop">    | 15.01. |  0.0 | 0.418958 | 0.418958 |  23796.787787 | 0.023797 |
</span><span class="noop">    | 16.01. |  0.0 | 0.166179 | 0.166179 |   9438.949346 | 0.009439 |
</span><span class="noop">    | 17.01. |  0.0 | 0.065914 | 0.065914 |   3743.940802 | 0.003744 |
</span><span class="noop">    | 18.01. |  0.0 | 0.026145 | 0.026145 |   1485.026799 | 0.001485 |
</span><span class="noop">    | 19.01. |  0.0 |  0.01037 |  0.01037 |    589.032976 | 0.000589 |
</span><span class="noop">    | 20.01. |  0.0 | 0.004113 | 0.004113 |    233.638778 | 0.000234 |
</span><span class="noop">
</span><span class="noop">    In the above example, the water balance is still maintained.  This
</span><span class="noop">    is not the case for the last example, where 1 m³/s is subtracted
</span><span class="noop">    from the total outflow.  Regarding its peak time and form, the
</span><span class="noop">    output hydrograph is identical/similar to the one of the first
</span><span class="noop">    example:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; maxdw(.0)
</span><span class="noop">    &gt;&gt;&gt; verzw(1.)
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |   date |   qz |       qa |   output |             v |        w |
</span><span class="noop">    ------------------------------------------------------------------
</span><span class="noop">    | 01.01. |  0.0 |      0.0 |      0.0 |           0.0 |      0.0 |
</span><span class="noop">    | 02.01. |  1.0 |      0.0 |      0.0 |  60335.195531 | 0.060335 |
</span><span class="noop">    | 03.01. |  6.0 | 1.231391 | 1.231391 | 385943.010518 | 0.385943 |
</span><span class="noop">    | 04.01. | 12.0 | 5.315244 | 5.315244 | 877105.886853 | 0.877106 |
</span><span class="noop">    | 05.01. | 10.0 | 8.141801 | 8.141801 | 951254.290316 | 0.951254 |
</span><span class="noop">    | 06.01. |  6.0 | 7.452893 | 7.452893 | 739324.327444 | 0.739324 |
</span><span class="noop">    | 07.01. |  3.0 | 5.067907 | 5.067907 | 474257.135467 | 0.474257 |
</span><span class="noop">    | 08.01. |  2.0 | 2.915203 | 2.915203 | 308783.556526 | 0.308784 |
</span><span class="noop">    | 09.01. |  1.0 | 1.457986 | 1.457986 |  182813.58946 | 0.182814 |
</span><span class="noop">    | 10.01. |  0.0 | 0.276631 | 0.276631 |  72512.652803 | 0.072513 |
</span><span class="noop">    | 11.01. |  0.0 |      0.0 |      0.0 |   28762.00195 | 0.028762 |
</span><span class="noop">    | 12.01. |  0.0 |      0.0 |      0.0 |  11408.391835 | 0.011408 |
</span><span class="noop">    | 13.01. |  0.0 |      0.0 |      0.0 |   4525.116314 | 0.004525 |
</span><span class="noop">    | 14.01. |  0.0 |      0.0 |      0.0 |   1794.878538 | 0.001795 |
</span><span class="noop">    | 15.01. |  0.0 |      0.0 |      0.0 |    711.935063 | 0.000712 |
</span><span class="noop">    | 16.01. |  0.0 |      0.0 |      0.0 |    282.387651 | 0.000282 |
</span><span class="noop">    | 17.01. |  0.0 |      0.0 |      0.0 |    112.008509 | 0.000112 |
</span><span class="noop">    | 18.01. |  0.0 |      0.0 |      0.0 |     44.427956 | 0.000044 |
</span><span class="noop">    | 19.01. |  0.0 |      0.0 |      0.0 |     17.622262 | 0.000018 |
</span><span class="noop">    | 20.01. |  0.0 |      0.0 |      0.0 |      6.989836 | 0.000007 |
</span><span class="noop">
</span><span class="noop">    In the following, the given examples above repeated.  The only
</span><span class="noop">    parameter that will be altered is the internal simulation step size,
</span><span class="noop">    beeing one hour instead of one day:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; maxdt(&#39;1h&#39;)
</span><span class="noop">    &gt;&gt;&gt; model.parameters.update()
</span><span class="noop">
</span><span class="noop">    Hence, the principles discussed above remain valid, but the result are
</span><span class="noop">    a little more accurate.
</span><span class="noop">
</span><span class="noop">    Repetition of the first experiment:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; maxdw(.0)
</span><span class="noop">    &gt;&gt;&gt; verzw(0.)
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |   date |   qz |       qa |   output |             v |        w |
</span><span class="noop">    ------------------------------------------------------------------
</span><span class="noop">    | 01.01. |  0.0 |      0.0 |      0.0 |           0.0 |      0.0 |
</span><span class="noop">    | 02.01. |  1.0 | 0.330363 | 0.330363 |  57856.651951 | 0.057857 |
</span><span class="noop">    | 03.01. |  6.0 | 2.369607 | 2.369607 | 371522.641905 | 0.371523 |
</span><span class="noop">    | 04.01. | 12.0 | 6.452208 | 6.452208 | 850851.903469 | 0.850852 |
</span><span class="noop">    | 05.01. | 10.0 | 9.001249 | 9.001249 |  937143.99857 | 0.937144 |
</span><span class="noop">    | 06.01. |  6.0 | 8.257642 | 8.257642 | 742083.768745 | 0.742084 |
</span><span class="noop">    | 07.01. |  3.0 | 5.960357 | 5.960357 | 486308.901331 | 0.486309 |
</span><span class="noop">    | 08.01. |  2.0 | 3.917231 | 3.917231 | 320660.156784 |  0.32066 |
</span><span class="noop">    | 09.01. |  1.0 | 2.477622 | 2.477622 |  192993.57788 | 0.192994 |
</span><span class="noop">    | 10.01. |  0.0 | 1.292357 | 1.292357 |  81333.955239 | 0.081334 |
</span><span class="noop">    | 11.01. |  0.0 | 0.544642 | 0.544642 |  34276.851838 | 0.034277 |
</span><span class="noop">    | 12.01. |  0.0 | 0.229531 | 0.229531 |  14445.412971 | 0.014445 |
</span><span class="noop">    | 13.01. |  0.0 | 0.096732 | 0.096732 |   6087.780665 | 0.006088 |
</span><span class="noop">    | 14.01. |  0.0 | 0.040766 | 0.040766 |   2565.594594 | 0.002566 |
</span><span class="noop">    | 15.01. |  0.0 |  0.01718 |  0.01718 |   1081.227459 | 0.001081 |
</span><span class="noop">    | 16.01. |  0.0 |  0.00724 |  0.00724 |    455.665451 | 0.000456 |
</span><span class="noop">    | 17.01. |  0.0 | 0.003051 | 0.003051 |    192.032677 | 0.000192 |
</span><span class="noop">    | 18.01. |  0.0 | 0.001286 | 0.001286 |     80.928999 | 0.000081 |
</span><span class="noop">    | 19.01. |  0.0 | 0.000542 | 0.000542 |      34.10619 | 0.000034 |
</span><span class="noop">    | 20.01. |  0.0 | 0.000228 | 0.000228 |      14.37349 | 0.000014 |
</span><span class="noop">
</span><span class="noop">    Repetition of the second experiment:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; maxdw(.1)
</span><span class="noop">    &gt;&gt;&gt; verzw(0.)
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |   date |   qz |       qa |   output |             v |        w |
</span><span class="noop">    ------------------------------------------------------------------
</span><span class="noop">    | 01.01. |  0.0 |      0.0 |      0.0 |           0.0 |      0.0 |
</span><span class="noop">    | 02.01. |  1.0 | 0.330363 | 0.330363 |  57856.651951 | 0.057857 |
</span><span class="noop">    | 03.01. |  6.0 | 2.369607 | 2.369607 | 371522.641905 | 0.371523 |
</span><span class="noop">    | 04.01. | 12.0 | 6.452208 | 6.452208 | 850851.903469 | 0.850852 |
</span><span class="noop">    | 05.01. | 10.0 | 9.001249 | 9.001249 |  937143.99857 | 0.937144 |
</span><span class="noop">    | 06.01. |  6.0 | 7.157407 | 7.157407 |  837143.99857 | 0.837144 |
</span><span class="noop">    | 07.01. |  3.0 | 4.157407 | 4.157407 |  737143.99857 | 0.737144 |
</span><span class="noop">    | 08.01. |  2.0 | 3.157407 | 3.157407 |  637143.99857 | 0.637144 |
</span><span class="noop">    | 09.01. |  1.0 | 2.157407 | 2.157407 |  537143.99857 | 0.537144 |
</span><span class="noop">    | 10.01. |  0.0 | 1.157407 | 1.157407 |  437143.99857 | 0.437144 |
</span><span class="noop">    | 11.01. |  0.0 | 1.157407 | 1.157407 |  337143.99857 | 0.337144 |
</span><span class="noop">    | 12.01. |  0.0 | 1.157407 | 1.157407 |  237143.99857 | 0.237144 |
</span><span class="noop">    | 13.01. |  0.0 | 1.157407 | 1.157407 |  137143.99857 | 0.137144 |
</span><span class="noop">    | 14.01. |  0.0 | 0.918367 | 0.918367 |  57797.072646 | 0.057797 |
</span><span class="noop">    | 15.01. |  0.0 | 0.387031 | 0.387031 |  24357.621488 | 0.024358 |
</span><span class="noop">    | 16.01. |  0.0 | 0.163108 | 0.163108 |    10265.1172 | 0.010265 |
</span><span class="noop">    | 17.01. |  0.0 | 0.068739 | 0.068739 |   4326.064069 | 0.004326 |
</span><span class="noop">    | 18.01. |  0.0 | 0.028969 | 0.028969 |   1823.148238 | 0.001823 |
</span><span class="noop">    | 19.01. |  0.0 | 0.012208 | 0.012208 |    768.335707 | 0.000768 |
</span><span class="noop">    | 20.01. |  0.0 | 0.005145 | 0.005145 |    323.802391 | 0.000324 |
</span><span class="noop">
</span><span class="noop">    Repetition of the third experiment:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; maxdw(.0)
</span><span class="noop">    &gt;&gt;&gt; verzw(1.)
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |   date |   qz |       qa |   output |             v |        w |
</span><span class="noop">    ------------------------------------------------------------------
</span><span class="noop">    | 01.01. |  0.0 |      0.0 |      0.0 |           0.0 |      0.0 |
</span><span class="noop">    | 02.01. |  1.0 |      0.0 |      0.0 |  57856.651951 | 0.057857 |
</span><span class="noop">    | 03.01. |  6.0 | 1.369607 | 1.369607 | 371522.641905 | 0.371523 |
</span><span class="noop">    | 04.01. | 12.0 | 5.452208 | 5.452208 | 850851.903469 | 0.850852 |
</span><span class="noop">    | 05.01. | 10.0 | 8.001249 | 8.001249 |  937143.99857 | 0.937144 |
</span><span class="noop">    | 06.01. |  6.0 | 7.257642 | 7.257642 | 742083.768745 | 0.742084 |
</span><span class="noop">    | 07.01. |  3.0 | 4.960357 | 4.960357 | 486308.901331 | 0.486309 |
</span><span class="noop">    | 08.01. |  2.0 | 2.917231 | 2.917231 | 320660.156784 |  0.32066 |
</span><span class="noop">    | 09.01. |  1.0 | 1.477622 | 1.477622 |  192993.57788 | 0.192994 |
</span><span class="noop">    | 10.01. |  0.0 | 0.292357 | 0.292357 |  81333.955239 | 0.081334 |
</span><span class="noop">    | 11.01. |  0.0 |      0.0 |      0.0 |  34276.851838 | 0.034277 |
</span><span class="noop">    | 12.01. |  0.0 |      0.0 |      0.0 |  14445.412971 | 0.014445 |
</span><span class="noop">    | 13.01. |  0.0 |      0.0 |      0.0 |   6087.780665 | 0.006088 |
</span><span class="noop">    | 14.01. |  0.0 |      0.0 |      0.0 |   2565.594594 | 0.002566 |
</span><span class="noop">    | 15.01. |  0.0 |      0.0 |      0.0 |   1081.227459 | 0.001081 |
</span><span class="noop">    | 16.01. |  0.0 |      0.0 |      0.0 |    455.665451 | 0.000456 |
</span><span class="noop">    | 17.01. |  0.0 |      0.0 |      0.0 |    192.032677 | 0.000192 |
</span><span class="noop">    | 18.01. |  0.0 |      0.0 |      0.0 |     80.928999 | 0.000081 |
</span><span class="noop">    | 19.01. |  0.0 |      0.0 |      0.0 |      34.10619 | 0.000034 |
</span><span class="noop">    | 20.01. |  0.0 |      0.0 |      0.0 |      14.37349 | 0.000014 |
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">from hydpy.core import modeltools
</span><span class="hit">from hydpy.core import parametertools
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core.modelimports import *
</span><span class="noop"># ...from llake
</span><span class="hit">from hydpy.models.llake import llake_model
</span><span class="hit">from hydpy.models.llake import llake_control
</span><span class="hit">from hydpy.models.llake import llake_derived
</span><span class="hit">from hydpy.models.llake import llake_fluxes
</span><span class="hit">from hydpy.models.llake import llake_states
</span><span class="hit">from hydpy.models.llake import llake_aides
</span><span class="hit">from hydpy.models.llake import llake_inlets
</span><span class="hit">from hydpy.models.llake import llake_outlets
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Model(modeltools.Model):
</span><span class="noop">    &#34;&#34;&#34;LARSIM-Lake version of HydPy-L-Lake (llake_v1).&#34;&#34;&#34;
</span><span class="hit">    _RUNMETHODS = (llake_model.update_inlets_v1,
</span><span class="noop">                   llake_model.solve_dv_dt_v1,
</span><span class="noop">                   llake_model.interp_w_v1,
</span><span class="noop">                   llake_model.corr_dw_v1,
</span><span class="noop">                   llake_model.modify_qa_v1,
</span><span class="noop">                   llake_model.update_outlets_v1)
</span><span class="hit">    _ADDMETHODS = (llake_model.interp_v_v1,
</span><span class="noop">                   llake_model.calc_vq_v1,
</span><span class="noop">                   llake_model.interp_qa_v1,
</span><span class="noop">                   llake_model.calc_v_qa_v1)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ControlParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Control parameters of llake_v1, directly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (llake_control.N,
</span><span class="noop">                   llake_control.W,
</span><span class="noop">                   llake_control.V,
</span><span class="noop">                   llake_control.Q,
</span><span class="noop">                   llake_control.MaxDT,
</span><span class="noop">                   llake_control.MaxDW,
</span><span class="noop">                   llake_control.Verzw)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class DerivedParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Derived parameters of llake_v1, indirectly defined by the user.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (llake_derived.TOY,
</span><span class="noop">                   llake_derived.Seconds,
</span><span class="noop">                   llake_derived.NmbSubsteps,
</span><span class="noop">                   llake_derived.VQ)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class StateSequences(sequencetools.StateSequences):
</span><span class="noop">    &#34;&#34;&#34;State sequences of llake_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (llake_states.V,
</span><span class="noop">                   llake_states.W)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FluxSequences(sequencetools.FluxSequences):
</span><span class="noop">    &#34;&#34;&#34;Flux sequences of llake_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (llake_fluxes.QZ,
</span><span class="noop">                   llake_fluxes.QA)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class AideSequences(sequencetools.AideSequences):
</span><span class="noop">    &#34;&#34;&#34;Aide sequences of llake_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (llake_aides.QA,
</span><span class="noop">                   llake_aides.VQ,
</span><span class="noop">                   llake_aides.V,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class InletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Upstream link sequences of llake_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (llake_inlets.Q,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class OutletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Downstream link sequences of llake_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (llake_outlets.Q,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">tester = Tester()
</span><span class="hit">cythonizer = Cythonizer()
</span><span class="hit">cythonizer.complete()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland_v1.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland_v1.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;
</span><span class="noop">Version 1 of the L-Land model is designed to aggree with the LARSIM-ME
</span><span class="noop">configuration of the LARSIM model used by the German Federal Institute
</span><span class="noop">of Hydrology (BfG), but offers more flexibility in some regards (e.g. in
</span><span class="noop">parameterization).  It can briefly be summarized as follows:
</span><span class="noop">
</span><span class="noop"> * Simple routines for adjusting the meteorological input data.
</span><span class="noop"> * Reference evapotranspiration after Turc-Wendling.
</span><span class="noop"> * An enhanced degree-day-method for calculating snow melt.
</span><span class="noop"> * A simple snow retention routine.
</span><span class="noop"> * Landuse and month specific potential evapotranspiration.
</span><span class="noop"> * Acual soil evapotranspiration after ATV-DVWK- 504 (2002).
</span><span class="noop"> * Soil routine based on the Xinanjiang model.
</span><span class="noop"> * One base flow, two interflow and two direct flow components.
</span><span class="noop"> * Seperate linear storages for modelling runoff concentration.
</span><span class="noop"> * Additional evaporation from water areas.
</span><span class="noop">
</span><span class="noop">The following picture shows the general structure of L-Land Version 1.  Note
</span><span class="noop">that, besides water areas and sealed surface areas, all land use types rely
</span><span class="noop">on the same process equations:
</span><span class="noop">
</span><span class="noop">.. image:: HydPy-L-Land_Version-1.png
</span><span class="noop">
</span><span class="noop">As all models implemented in HydPy, base model L-Land can principally be
</span><span class="noop">applied on arbitrary simulation step sizes.  But for the L-Land version 1
</span><span class="noop">application model one has to be aware, that the Turc-Wendling equation
</span><span class="noop">for calculating reference evaporation is designed for daily values only.
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">Integration tests:
</span><span class="noop">
</span><span class="noop">    The integration tests are performed in January (to allow for realistic
</span><span class="noop">    snow examples), spanning over a period of five days:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy import pub, Timegrid, Timegrids
</span><span class="noop">    &gt;&gt;&gt; pub.timegrids = Timegrids(Timegrid(&#39;01.01.2000&#39;,
</span><span class="noop">    ...                                    &#39;06.01.2000&#39;,
</span><span class="noop">    ...                                    &#39;1d&#39;))
</span><span class="noop">
</span><span class="noop">    Prepare the model instance and built the connections to element `land`
</span><span class="noop">    and node `outlet`:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.lland_v1 import *
</span><span class="noop">    &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">    &gt;&gt;&gt; from hydpy import Node, Element
</span><span class="noop">    &gt;&gt;&gt; outlet = Node(&#39;outlet&#39;)
</span><span class="noop">    &gt;&gt;&gt; land = Element(&#39;land&#39;, outlets=outlet)
</span><span class="noop">    &gt;&gt;&gt; land.connect(model)
</span><span class="noop">
</span><span class="noop">    All tests shall be performed using single hydrological response unit with
</span><span class="noop">    a size of one square kilometre an a altitude of 100 meter:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; nhru(1)
</span><span class="noop">    &gt;&gt;&gt; ft(1.)
</span><span class="noop">    &gt;&gt;&gt; fhru(1.)
</span><span class="noop">    &gt;&gt;&gt; hnn(100.)
</span><span class="noop">
</span><span class="noop">    Initialize a test function object, which prepares and runs the tests
</span><span class="noop">    and prints their results for the given sequences:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.core.testtools import Test
</span><span class="noop">    &gt;&gt;&gt; test = Test(land, inits={&#39;inzp&#39;: 0.,
</span><span class="noop">    ...                          &#39;wats&#39;: 0.,
</span><span class="noop">    ...                          &#39;waes&#39;: 0.,
</span><span class="noop">    ...                          &#39;bowa&#39;: 0.,
</span><span class="noop">    ...                          &#39;qdgz1&#39;: 0.,
</span><span class="noop">    ...                          &#39;qdgz2&#39;: 0.,
</span><span class="noop">    ...                          &#39;qigz1&#39;: 0.,
</span><span class="noop">    ...                          &#39;qigz2&#39;: 0.,
</span><span class="noop">    ...                          &#39;qbgz&#39;: 0.,
</span><span class="noop">    ...                          &#39;qdga1&#39;: 0.,
</span><span class="noop">    ...                          &#39;qdga2&#39;: 0.,
</span><span class="noop">    ...                          &#39;qiga1&#39;: 0.,
</span><span class="noop">    ...                          &#39;qiga2&#39;: 0.,
</span><span class="noop">    ...                          &#39;qbga&#39;: 0.})
</span><span class="noop">    &gt;&gt;&gt; test.dateformat = &#39;%d.%m.&#39;
</span><span class="noop">
</span><span class="noop">    Set the input values for the complete simulation period:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; inputs.nied.series = 0., 5., 5., 5., 0.
</span><span class="noop">    &gt;&gt;&gt; inputs.teml.series = -2., -1., 0., 1., 2.
</span><span class="noop">    &gt;&gt;&gt; inputs.glob.series = 100.
</span><span class="noop">
</span><span class="noop">    Define the control parameter values (select only arable land, sealed
</span><span class="noop">    soil and water area as landuse classes, as all other land use classes
</span><span class="noop">    are functionally identical with arable land):
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; lnk(ACKER)
</span><span class="noop">    &gt;&gt;&gt; kg(1.2)
</span><span class="noop">    &gt;&gt;&gt; kt(-1.)
</span><span class="noop">    &gt;&gt;&gt; ke(0.9)
</span><span class="noop">    &gt;&gt;&gt; kf(.6)
</span><span class="noop">    &gt;&gt;&gt; fln.acker_jan = 1.
</span><span class="noop">    &gt;&gt;&gt; fln.vers_jan = .8
</span><span class="noop">    &gt;&gt;&gt; fln.wasser_jan = 1.3
</span><span class="noop">    &gt;&gt;&gt; hinz(.2)
</span><span class="noop">    &gt;&gt;&gt; lai.acker_jan = 1.0
</span><span class="noop">    &gt;&gt;&gt; treft(0.)
</span><span class="noop">    &gt;&gt;&gt; trefn(0.)
</span><span class="noop">    &gt;&gt;&gt; tgr(0.)
</span><span class="noop">    &gt;&gt;&gt; tsp(0.)
</span><span class="noop">    &gt;&gt;&gt; gtf(5.)
</span><span class="noop">    &gt;&gt;&gt; rschmelz(334.)
</span><span class="noop">    &gt;&gt;&gt; cpwasser(4.1868)
</span><span class="noop">    &gt;&gt;&gt; pwmax(1.4)
</span><span class="noop">    &gt;&gt;&gt; grasref_r(5.)
</span><span class="noop">    &gt;&gt;&gt; nfk(200.)
</span><span class="noop">    &gt;&gt;&gt; relwz(.5)
</span><span class="noop">    &gt;&gt;&gt; relwb(.05)
</span><span class="noop">    &gt;&gt;&gt; beta(.01)
</span><span class="noop">    &gt;&gt;&gt; fbeta(1.)
</span><span class="noop">    &gt;&gt;&gt; dmax(5.)
</span><span class="noop">    &gt;&gt;&gt; dmin(1.)
</span><span class="noop">    &gt;&gt;&gt; bsf(.4)
</span><span class="noop">    &gt;&gt;&gt; a1(0.)
</span><span class="noop">    &gt;&gt;&gt; a2(inf)
</span><span class="noop">    &gt;&gt;&gt; tind(1.)
</span><span class="noop">    &gt;&gt;&gt; eqb(100.)
</span><span class="noop">    &gt;&gt;&gt; eqi1(50.)
</span><span class="noop">    &gt;&gt;&gt; eqi2(10.)
</span><span class="noop">    &gt;&gt;&gt; eqd1(2.)
</span><span class="noop">    &gt;&gt;&gt; eqd2(1.)
</span><span class="noop">
</span><span class="noop">    Check the correctness of the results:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; test()
</span><span class="noop">    |   date | nied | teml |  glob | nkor | tkor |      et0 |     evpo | nbes | sbes | evi |      evb |     wgtf |     schm |     wada |      qdb | qib1 | qib2 | qbb |     qdgz |        q | inzp |     wats |     waes |     bowa |    qdgz1 | qdgz2 | qigz1 | qigz2 | qbgz |    qdga1 | qdga2 | qiga1 | qiga2 | qbga |   outlet |
</span><span class="noop">    --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span><span class="noop">    | 01.01. |  0.0 | -2.0 | 100.0 |  0.0 | -3.0 | 0.779561 | 0.779561 |  0.0 |  0.0 | 0.0 |      0.0 |      0.0 |      0.0 |      0.0 |      0.0 |  0.0 |  0.0 | 0.0 |      0.0 |      0.0 |  0.0 |      0.0 |      0.0 |      0.0 |      0.0 |   0.0 |   0.0 |   0.0 |  0.0 |      0.0 |   0.0 |   0.0 |   0.0 |  0.0 |      0.0 |
</span><span class="noop">    | 02.01. |  5.0 | -1.0 | 100.0 |  6.0 | -2.0 | 0.813809 | 0.813809 |  5.8 |  5.8 | 0.2 |      0.0 |      0.0 |      0.0 |      0.0 |      0.0 |  0.0 |  0.0 | 0.0 |      0.0 |      0.0 |  0.0 |      5.8 |      5.8 |      0.0 |      0.0 |   0.0 |   0.0 |   0.0 |  0.0 |      0.0 |   0.0 |   0.0 |   0.0 |  0.0 |      0.0 |
</span><span class="noop">    | 03.01. |  5.0 |  0.0 | 100.0 |  6.0 | -1.0 | 0.847495 | 0.847495 |  5.8 |  5.8 | 0.2 |      0.0 |      0.0 |      0.0 |      0.0 |      0.0 |  0.0 |  0.0 | 0.0 |      0.0 |      0.0 |  0.0 |     11.6 |     11.6 |      0.0 |      0.0 |   0.0 |   0.0 |   0.0 |  0.0 |      0.0 |   0.0 |   0.0 |   0.0 |  0.0 |      0.0 |
</span><span class="noop">    | 04.01. |  5.0 |  1.0 | 100.0 |  6.0 |  0.0 | 0.880634 | 0.880634 |  5.8 |  0.0 | 0.2 |      0.0 |      0.0 |      0.0 |     1.16 | 0.000962 |  0.0 |  0.0 | 0.0 | 0.000962 | 0.000205 |  0.0 |     11.6 |    16.24 | 1.159038 | 0.000962 |   0.0 |   0.0 |   0.0 |  0.0 | 0.000205 |   0.0 |   0.0 |   0.0 |  0.0 | 0.000002 |
</span><span class="noop">    | 05.01. |  0.0 |  2.0 | 100.0 |  0.0 |  1.0 | 0.913238 | 0.913238 |  0.0 |  0.0 | 0.0 | 0.013321 | 5.012535 | 5.012535 | 7.017549 | 0.047086 |  0.0 |  0.0 | 0.0 | 0.047086 |  0.01033 |  0.0 | 6.587465 | 9.222451 |  8.11618 | 0.047086 |   0.0 |   0.0 |   0.0 |  0.0 |  0.01033 |   0.0 |   0.0 |   0.0 |  0.0 |  0.00012 |
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core.modelimports import *
</span><span class="hit">from hydpy.core import modeltools
</span><span class="hit">from hydpy.core import parametertools
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop"># ...from lland
</span><span class="hit">from hydpy.models.lland import lland_model
</span><span class="hit">from hydpy.models.lland import lland_control
</span><span class="hit">from hydpy.models.lland import lland_derived
</span><span class="hit">from hydpy.models.lland import lland_inputs
</span><span class="hit">from hydpy.models.lland import lland_fluxes
</span><span class="hit">from hydpy.models.lland import lland_states
</span><span class="hit">from hydpy.models.lland import lland_aides
</span><span class="hit">from hydpy.models.lland import lland_outlets
</span><span class="hit">from hydpy.models.lland.lland_parameters import Parameters
</span><span class="hit">from hydpy.models.lland.lland_constants import *
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Model(modeltools.Model):
</span><span class="noop">    &#34;&#34;&#34;LARSIM-Land version of HydPy-L-Land (lland_v1).&#34;&#34;&#34;
</span><span class="hit">    _RUNMETHODS = (lland_model.calc_nkor_v1,
</span><span class="noop">                   lland_model.calc_tkor_v1,
</span><span class="noop">                   lland_model.calc_et0_v1,
</span><span class="noop">                   lland_model.calc_evpo_v1,
</span><span class="noop">                   lland_model.calc_nbes_inzp_v1,
</span><span class="noop">                   lland_model.calc_evi_inzp_v1,
</span><span class="noop">                   lland_model.calc_sbes_v1,
</span><span class="noop">                   lland_model.calc_wgtf_v1,
</span><span class="noop">                   lland_model.calc_schm_wats_v1,
</span><span class="noop">                   lland_model.calc_wada_waes_v1,
</span><span class="noop">                   lland_model.calc_evb_v1,
</span><span class="noop">                   lland_model.calc_qbb_v1,
</span><span class="noop">                   lland_model.calc_qib1_v1,
</span><span class="noop">                   lland_model.calc_qib2_v1,
</span><span class="noop">                   lland_model.calc_qdb_v1,
</span><span class="noop">                   lland_model.calc_bowa_v1,
</span><span class="noop">                   lland_model.calc_qbgz_v1,
</span><span class="noop">                   lland_model.calc_qigz1_v1,
</span><span class="noop">                   lland_model.calc_qigz2_v1,
</span><span class="noop">                   lland_model.calc_qdgz_v1,
</span><span class="noop">                   lland_model.calc_qdgz1_qdgz2_v1,
</span><span class="noop">                   lland_model.calc_qbga_v1,
</span><span class="noop">                   lland_model.calc_qiga1_v1,
</span><span class="noop">                   lland_model.calc_qiga2_v1,
</span><span class="noop">                   lland_model.calc_qdga1_v1,
</span><span class="noop">                   lland_model.calc_qdga2_v1,
</span><span class="noop">                   lland_model.calc_q_v1,
</span><span class="noop">                   lland_model.update_outlets_v1)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ControlParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Control parameters of lland_v1, directly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (lland_control.FT,
</span><span class="noop">                   lland_control.NHRU,
</span><span class="noop">                   lland_control.Lnk,
</span><span class="noop">                   lland_control.FHRU,
</span><span class="noop">                   lland_control.HNN,
</span><span class="noop">                   lland_control.KG,
</span><span class="noop">                   lland_control.KT,
</span><span class="noop">                   lland_control.KE,
</span><span class="noop">                   lland_control.KF,
</span><span class="noop">                   lland_control.FLn,
</span><span class="noop">                   lland_control.HInz,
</span><span class="noop">                   lland_control.LAI,
</span><span class="noop">                   lland_control.TRefT,
</span><span class="noop">                   lland_control.TRefN,
</span><span class="noop">                   lland_control.TGr,
</span><span class="noop">                   lland_control.TSp,
</span><span class="noop">                   lland_control.GTF,
</span><span class="noop">                   lland_control.RSchmelz,
</span><span class="noop">                   lland_control.CPWasser,
</span><span class="noop">                   lland_control.PWMax,
</span><span class="noop">                   lland_control.GrasRef_R,
</span><span class="noop">                   lland_control.NFk,
</span><span class="noop">                   lland_control.RelWZ,
</span><span class="noop">                   lland_control.RelWB,
</span><span class="noop">                   lland_control.Beta,
</span><span class="noop">                   lland_control.FBeta,
</span><span class="noop">                   lland_control.DMax,
</span><span class="noop">                   lland_control.DMin,
</span><span class="noop">                   lland_control.BSf,
</span><span class="noop">                   lland_control.A1,
</span><span class="noop">                   lland_control.A2,
</span><span class="noop">                   lland_control.TInd,
</span><span class="noop">                   lland_control.EQB,
</span><span class="noop">                   lland_control.EQI1,
</span><span class="noop">                   lland_control.EQI2,
</span><span class="noop">                   lland_control.EQD1,
</span><span class="noop">                   lland_control.EQD2)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class DerivedParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Derived parameters of lland_v1, indirectly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (lland_derived.MOY,
</span><span class="noop">                   lland_derived.KInz,
</span><span class="noop">                   lland_derived.WB,
</span><span class="noop">                   lland_derived.WZ,
</span><span class="noop">                   lland_derived.KB,
</span><span class="noop">                   lland_derived.KI1,
</span><span class="noop">                   lland_derived.KI2,
</span><span class="noop">                   lland_derived.KD1,
</span><span class="noop">                   lland_derived.KD2,
</span><span class="noop">                   lland_derived.QFactor)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class InputSequences(sequencetools.InputSequences):
</span><span class="noop">    &#34;&#34;&#34;Input sequences of lland_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (lland_inputs.Nied,
</span><span class="noop">                   lland_inputs.TemL,
</span><span class="noop">                   lland_inputs.Glob)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FluxSequences(sequencetools.FluxSequences):
</span><span class="noop">    &#34;&#34;&#34;Flux sequences of lland_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (lland_fluxes.NKor,
</span><span class="noop">                   lland_fluxes.TKor,
</span><span class="noop">                   lland_fluxes.ET0,
</span><span class="noop">                   lland_fluxes.EvPo,
</span><span class="noop">                   lland_fluxes.NBes,
</span><span class="noop">                   lland_fluxes.SBes,
</span><span class="noop">                   lland_fluxes.EvI,
</span><span class="noop">                   lland_fluxes.EvB,
</span><span class="noop">                   lland_fluxes.WGTF,
</span><span class="noop">                   lland_fluxes.Schm,
</span><span class="noop">                   lland_fluxes.WaDa,
</span><span class="noop">                   lland_fluxes.QDB,
</span><span class="noop">                   lland_fluxes.QIB1,
</span><span class="noop">                   lland_fluxes.QIB2,
</span><span class="noop">                   lland_fluxes.QBB,
</span><span class="noop">                   lland_fluxes.QDGZ,
</span><span class="noop">                   lland_fluxes.Q)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class StateSequences(sequencetools.StateSequences):
</span><span class="noop">    &#34;&#34;&#34;State sequences of lland_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (lland_states.Inzp,
</span><span class="noop">                   lland_states.WATS,
</span><span class="noop">                   lland_states.WAeS,
</span><span class="noop">                   lland_states.BoWa,
</span><span class="noop">                   lland_states.QDGZ1,
</span><span class="noop">                   lland_states.QDGZ2,
</span><span class="noop">                   lland_states.QIGZ1,
</span><span class="noop">                   lland_states.QIGZ2,
</span><span class="noop">                   lland_states.QBGZ,
</span><span class="noop">                   lland_states.QDGA1,
</span><span class="noop">                   lland_states.QDGA2,
</span><span class="noop">                   lland_states.QIGA1,
</span><span class="noop">                   lland_states.QIGA2,
</span><span class="noop">                   lland_states.QBGA)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class AideSequences(sequencetools.AideSequences):
</span><span class="noop">    &#34;&#34;&#34;Aide sequences of lland_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (lland_aides.Temp,
</span><span class="noop">                   lland_aides.SfA,
</span><span class="noop">                   lland_aides.Exz,
</span><span class="noop">                   lland_aides.BVl,
</span><span class="noop">                   lland_aides.MVl,
</span><span class="noop">                   lland_aides.RVl,
</span><span class="noop">                   lland_aides.EPW)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class OutletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Downstream link sequences of lland_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (lland_outlets.Q,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">tester = Tester()
</span><span class="hit">cythonizer = Cythonizer()
</span><span class="hit">cythonizer.complete()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream_v1.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream_v1.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;
</span><span class="noop">Integration test:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.lstream_v1 import *
</span><span class="noop">    &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">    &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">
</span><span class="noop">    Secondly, the final model output shall be passed to `outflow`:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.cythons.pointer import Double
</span><span class="noop">    &gt;&gt;&gt; inflow, outflow = Double(0.), Double(0.)
</span><span class="noop">    &gt;&gt;&gt; inlets.q.shape = 1
</span><span class="noop">    &gt;&gt;&gt; inlets.q.setpointer(inflow, 0)
</span><span class="noop">    &gt;&gt;&gt; outlets.q.setpointer(outflow)
</span><span class="noop">
</span><span class="noop">    Define the geometry and roughness values for the first test channel:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; bm(2.)
</span><span class="noop">    &gt;&gt;&gt; bnm(4.)
</span><span class="noop">    &gt;&gt;&gt; hm(1.)
</span><span class="noop">    &gt;&gt;&gt; bv(.5, 10.)
</span><span class="noop">    &gt;&gt;&gt; bbv(1., 2.)
</span><span class="noop">    &gt;&gt;&gt; bnv(1., 8.)
</span><span class="noop">    &gt;&gt;&gt; bnvr(20.)
</span><span class="noop">    &gt;&gt;&gt; ekm(1.)
</span><span class="noop">    &gt;&gt;&gt; skm(20.)
</span><span class="noop">    &gt;&gt;&gt; ekv(1.)
</span><span class="noop">    &gt;&gt;&gt; skv(60., 80.)
</span><span class="noop">    &gt;&gt;&gt; gef(.01)
</span><span class="noop">    &gt;&gt;&gt; laen(10.)
</span><span class="noop">
</span><span class="noop">    Set the error tolerances of the iteration small enough, not to
</span><span class="noop">    compromise the shown first six decimal places of the following results:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; qtol(1e-10)
</span><span class="noop">    &gt;&gt;&gt; htol(1e-10)
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; parameters.update()
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; states.qz.old = 1.
</span><span class="noop">    &gt;&gt;&gt; states.qz.new = 1.
</span><span class="noop">    &gt;&gt;&gt; states.qa.old = 1.
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; inflow[0] = 2.
</span><span class="noop">    &gt;&gt;&gt; outflow[0] = 0.
</span><span class="noop">    &gt;&gt;&gt; model.doit(0)
</span><span class="noop">    &gt;&gt;&gt; print(round(outflow[0], 6))
</span><span class="noop">    1.737971
</span><span class="noop">    &gt;&gt;&gt; inflow[0] = 2000.
</span><span class="noop">    &gt;&gt;&gt; outflow[0] = 0.
</span><span class="noop">    &gt;&gt;&gt; model.doit(1)
</span><span class="noop">    &gt;&gt;&gt; print(round(outflow[0], 6))
</span><span class="noop">    1932.529863
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core.modelimports import *
</span><span class="hit">from hydpy.core import modeltools
</span><span class="hit">from hydpy.core import parametertools
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop"># ...from lstream
</span><span class="hit">from hydpy.models.lstream import lstream_model
</span><span class="hit">from hydpy.models.lstream import lstream_control
</span><span class="hit">from hydpy.models.lstream import lstream_derived
</span><span class="hit">from hydpy.models.lstream import lstream_fluxes
</span><span class="hit">from hydpy.models.lstream import lstream_states
</span><span class="hit">from hydpy.models.lstream import lstream_aides
</span><span class="hit">from hydpy.models.lstream import lstream_inlets
</span><span class="hit">from hydpy.models.lstream import lstream_outlets
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Model(modeltools.Model):
</span><span class="noop">    &#34;&#34;&#34;LARSIM-Stream (Manning) version of HydPy-L-Stream (lstream_v1).&#34;&#34;&#34;
</span><span class="hit">    _RUNMETHODS = (lstream_model.update_inlets_v1,
</span><span class="noop">                   lstream_model.calc_qref_v1,
</span><span class="noop">                   lstream_model.calc_hmin_qmin_hmax_qmax_v1,
</span><span class="noop">                   lstream_model.calc_h_v1,
</span><span class="noop">                   lstream_model.calc_ag_v1,
</span><span class="noop">                   lstream_model.calc_rk_v1,
</span><span class="noop">                   lstream_model.calc_qa_v1,
</span><span class="noop">                   lstream_model.update_outlets_v1)
</span><span class="hit">    _ADDMETHODS = (lstream_model.calc_am_um_v1,
</span><span class="noop">                   lstream_model.calc_qm_v1,
</span><span class="noop">                   lstream_model.calc_av_uv_v1,
</span><span class="noop">                   lstream_model.calc_qv_v1,
</span><span class="noop">                   lstream_model.calc_avr_uvr_v1,
</span><span class="noop">                   lstream_model.calc_qvr_v1,
</span><span class="noop">                   lstream_model.calc_qg_v1)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ControlParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Control parameters of lstream_v1, directly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (lstream_control.Laen,
</span><span class="noop">                   lstream_control.Gef,
</span><span class="noop">                   lstream_control.HM,
</span><span class="noop">                   lstream_control.BM,
</span><span class="noop">                   lstream_control.BV,
</span><span class="noop">                   lstream_control.BBV,
</span><span class="noop">                   lstream_control.BNM,
</span><span class="noop">                   lstream_control.BNV,
</span><span class="noop">                   lstream_control.BNVR,
</span><span class="noop">                   lstream_control.SKM,
</span><span class="noop">                   lstream_control.SKV,
</span><span class="noop">                   lstream_control.EKM,
</span><span class="noop">                   lstream_control.EKV,
</span><span class="noop">                   lstream_control.QTol,
</span><span class="noop">                   lstream_control.HTol)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class DerivedParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Derived parameters of lstream_v1, indirectly defined by the user.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (lstream_derived.HV,
</span><span class="noop">                   lstream_derived.QM,
</span><span class="noop">                   lstream_derived.QV,
</span><span class="noop">                   lstream_derived.Sek)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FluxSequences(sequencetools.FluxSequences):
</span><span class="noop">    &#34;&#34;&#34;Flux sequences of LARSIM-ME.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (lstream_fluxes.QRef,
</span><span class="noop">                   lstream_fluxes.H,
</span><span class="noop">                   lstream_fluxes.AM,
</span><span class="noop">                   lstream_fluxes.AV,
</span><span class="noop">                   lstream_fluxes.AVR,
</span><span class="noop">                   lstream_fluxes.AG,
</span><span class="noop">                   lstream_fluxes.UM,
</span><span class="noop">                   lstream_fluxes.UV,
</span><span class="noop">                   lstream_fluxes.UVR,
</span><span class="noop">                   lstream_fluxes.UG,
</span><span class="noop">                   lstream_fluxes.QM,
</span><span class="noop">                   lstream_fluxes.QV,
</span><span class="noop">                   lstream_fluxes.QVR,
</span><span class="noop">                   lstream_fluxes.QG,
</span><span class="noop">                   lstream_fluxes.RK)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class StateSequences(sequencetools.StateSequences):
</span><span class="noop">    &#34;&#34;&#34;State sequences of lstream_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (lstream_states.QZ,
</span><span class="noop">                   lstream_states.QA)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class AideSequences(sequencetools.AideSequences):
</span><span class="noop">    &#34;&#34;&#34;Aide sequences of lstream_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (lstream_aides.Temp,
</span><span class="noop">                   lstream_aides.HMin,
</span><span class="noop">                   lstream_aides.HMax,
</span><span class="noop">                   lstream_aides.QMin,
</span><span class="noop">                   lstream_aides.QMax,
</span><span class="noop">                   lstream_aides.QTest)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class InletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Upstream link sequences of lstream_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (lstream_inlets.Q,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class OutletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Downstream link sequences of lstream_v1.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (lstream_outlets.Q,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">tester = Tester()
</span><span class="hit">cythonizer = Cythonizer()
</span><span class="hit">cythonizer.complete()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hbranch/__init__.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hbranch/__init__.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;The HydPy-H-Branch model allows for branching the input from a
</span><span class="noop">single inlet :class:`~hydpy.core.devicetools.Node` instance to
</span><span class="noop">an arbitrary number of outlet :class:`~hydpy.core.devicetools.Node`
</span><span class="noop">instances.  In the original  HBV96 implementation, it is supposed to
</span><span class="noop">seperate inflowing discharge, but in :ref:`HydPy` it can be used for
</span><span class="noop">arbitrary variables.  Calculations are performed for each branch
</span><span class="noop">individually by linear interpolation (or extrapolation) in accordance
</span><span class="noop">with tabulated supporting points.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core.modelimports import *
</span><span class="noop"># ...from hbranch
</span><span class="hit">from hydpy.models.hbranch.hbranch_control import ControlParameters
</span><span class="hit">from hydpy.models.hbranch.hbranch_derived import DerivedParameters
</span><span class="hit">from hydpy.models.hbranch.hbranch_fluxes import FluxSequences
</span><span class="hit">from hydpy.models.hbranch.hbranch_inlets import InletSequences
</span><span class="hit">from hydpy.models.hbranch.hbranch_outlets import OutletSequences
</span><span class="hit">from hydpy.models.hbranch.hbranch_model import Model
</span><span class="noop">
</span><span class="hit">autodoc_basemodel()
</span><span class="hit">tester = Tester()
</span><span class="hit">cythonizer = Cythonizer()
</span><span class="hit">cythonizer.complete()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hbranch/hbranch_control.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hbranch/hbranch_control.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy.core import parametertools
</span><span class="hit">from hydpy.core import devicetools
</span><span class="hit">from hydpy.core import objecttools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class XPoints(parametertools.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Supporting points for the independent input variable [eg. m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="hit">        self.shape = len(args)
</span><span class="hit">        if self.shape[0] &lt; 2:
</span><span class="miss">            raise ValueError(&#39;Branching via linear interpolation requires &#39;
</span><span class="noop">                             &#39;at least two supporting points, but for &#39;
</span><span class="noop">                             &#39;parameter `%s` only %d are given.&#39;
</span><span class="noop">                             % (self.name, self.shape[0]))
</span><span class="hit">        parametertools.MultiParameter.__call__(self, *args, **kwargs)
</span><span class="hit">        if min(numpy.diff(self)) &lt;= 0.:
</span><span class="miss">            raise ValueError(&#39;The values of parameter `xpoints` must be &#39;
</span><span class="noop">                             &#39;arranged in a strictly monotnously manner, &#39;
</span><span class="noop">                             &#39;which is not the case for the given values &#39;
</span><span class="noop">                             &#39;`%s`.&#39; % &#39;, &#39;.join(str(value) for value in self))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class YPoints(parametertools.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Supporting points for the dependent output variables [eg. m³/s].
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">    The documentation on method
</span><span class="noop">    :func:`~hydpy.models.hbranch.Model.calc_outputs_v1` gives examples on how
</span><span class="noop">    to set the values of :class:`~hydpy.models.hbranch.YPoints` properly.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 2, float, None, (None, None)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="hit">        try:
</span><span class="hit">            self.shape = (len(kwargs), self.subpars.xpoints.shape[0])
</span><span class="miss">        except RuntimeError:
</span><span class="miss">            raise RuntimeError(&#39;The shape of parameter `ypoints` depends on &#39;
</span><span class="noop">                               &#39;the shape of parameter `xpoints`.  Make sure &#39;
</span><span class="noop">                               &#39;parameter `xpoints` is defined first (and is &#39;
</span><span class="noop">                               &#39;integrated into the hmodel as described in &#39;
</span><span class="noop">                               &#39;the documentation).&#39;)
</span><span class="hit">        branched = self.subpars.pars.model.sequences.outlets.branched
</span><span class="hit">        try:
</span><span class="hit">            branched.shape = self.shape[0]
</span><span class="hit">        except RuntimeError:
</span><span class="hit">            if branched.shape[0] != self.shape[0]:
</span><span class="miss">                raise RuntimeError(&#39;The number of branches of the hbranch &#39;
</span><span class="noop">                                   &#39;model should not be changed during run &#39;
</span><span class="noop">                                   &#39;time.  If you really need to do this, &#39;
</span><span class="noop">                                   &#39;first initialize a new `branched` &#39;
</span><span class="noop">                                   &#39;sequence and connect it to the &#39;
</span><span class="noop">                                   &#39;respective outlet nodes properly.&#39;)
</span><span class="hit">        if self.shape[0] == 0:
</span><span class="miss">            raise ValueError(&#39;No branches are defined.  Do this via keyword &#39;
</span><span class="noop">                             &#39;arguments of the same name as the related &#39;
</span><span class="noop">                             &#39;outlet node instances.&#39;)
</span><span class="hit">        self.subpars.pars.model.sequences.fluxes.outputs.shape = self.shape[0]
</span><span class="hit">        for (idx, key) in enumerate(sorted(kwargs)):
</span><span class="hit">            value = kwargs[key]
</span><span class="hit">            if ((key not in devicetools.Node.registerednames()) and
</span><span class="noop">                    (pub.timegrids is not None)):
</span><span class="miss">                raise ValueError(&#39;Node `%s` does not exist so far.  Hence it &#39;
</span><span class="noop">                                 &#39;is not possible to branch to it.&#39; % key)
</span><span class="hit">            try:
</span><span class="hit">                self[idx] = value
</span><span class="miss">            except ValueError:
</span><span class="miss">                if self.shape[1] != len(value):
</span><span class="miss">                    raise ValueError(&#39;Each branch requires the same number of &#39;
</span><span class="noop">                                     &#39;supporting points as given for &#39;
</span><span class="noop">                                     &#39;parameter `xpoints`, which is %d.  But &#39;
</span><span class="noop">                                     &#39;for branch `%s` %d are given.&#39;
</span><span class="noop">                                     % (self.shape[1], key, len(value)))
</span><span class="noop">                else:
</span><span class="miss">                    message = &#39;The affected keyword argument is `%s`&#39; % key
</span><span class="miss">                    objecttools.augmentexcmessage(suffix=message)
</span><span class="hit">            setattr(self, key, self[idx])
</span><span class="hit">            self.subpars.pars.model.nodenames.append(key)
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="miss">        lines = self.commentrepr()
</span><span class="miss">        nodenames = self.subpars.pars.model.nodenames
</span><span class="miss">        for (idx, values) in enumerate(self):
</span><span class="miss">            line = &#39;%s=%s,&#39; % (nodenames[idx], repr(list(values)))
</span><span class="miss">            if not idx:
</span><span class="miss">                lines.append(&#39;ypoints(&#39;+line)
</span><span class="noop">            else:
</span><span class="miss">                lines.append(&#39;        &#39;+line)
</span><span class="miss">        lines[-1] = lines[-1][:-1]+&#39;)&#39;
</span><span class="miss">        return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ControlParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Control parameters of hbranch, directly defined by the user.
</span><span class="noop">
</span><span class="noop">    Note that the number of supporting points handled parameter
</span><span class="noop">    :class:`~hydpy.models.hbranch.XPoints` and
</span><span class="noop">    :class:`~hydpy.models.hbranch.YPoints` must be identical.  First
</span><span class="noop">    define the values of parameter :class:`~hydpy.models.hbranch.XPoints`,
</span><span class="noop">    then the values  of parameter :class:`~hydpy.models.hbranch.YPoints`.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (XPoints, YPoints)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hbranch/hbranch_derived.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hbranch/hbranch_derived.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import parametertools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class NmbBranches(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Number of branches [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, int, None, (1, None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        con = self.subpars.pars.control
</span><span class="hit">        self(con.ypoints.shape[0])
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class NmbPoints(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Number of supporting points for linear interpolation [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, int, None, (2, None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        con = self.subpars.pars.control
</span><span class="hit">        self(con.ypoints.shape[1])
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class DerivedParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Derived parameters of hbranch, indirectly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (NmbBranches, NmbPoints)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hbranch/hbranch_fluxes.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hbranch/hbranch_fluxes.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Input(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Total input [e.g. m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Outputs(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Branched outputs [e.g. m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        nodenames = self.subseqs.seqs.model.nodenames
</span><span class="hit">        lines = []
</span><span class="hit">        for (idx, value) in enumerate(self.values):
</span><span class="hit">            line = &#39;%s=%s,&#39; % (nodenames[idx], repr(value))
</span><span class="hit">            if not idx:
</span><span class="hit">                lines.append(&#39;outputs(&#39;+line)
</span><span class="noop">            else:
</span><span class="hit">                lines.append(&#39;        &#39;+line)
</span><span class="hit">        lines[-1] = lines[-1][:-1]+&#39;)&#39;
</span><span class="hit">        return &#39;\n&#39;.join(lines)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FluxSequences(sequencetools.FluxSequences):
</span><span class="noop">    &#34;&#34;&#34;Flux sequences of the hbranch model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Input, Outputs)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hbranch/hbranch_inlets.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hbranch/hbranch_inlets.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Total(sequencetools.LinkSequence):
</span><span class="noop">    &#34;&#34;&#34;Total input [e.g. m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class InletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Upstream link sequences of the hbranch model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Total,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hbranch/hbranch_model.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hbranch/hbranch_model.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import modeltools
</span><span class="hit">from hydpy.core import devicetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_outputs_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Performs the actual interpolation or extrapolation.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hbranch.XPoints`
</span><span class="noop">      :class:`~hydpy.models.hbranch.YPoints`
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.models.hbranch.hbranch_derived.NmbPoints`
</span><span class="noop">      :class:`~hydpy.models.hbranch.hbranch_derived.NmbBranches`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.hbranch.hbranch_fluxes.Input`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.hbranch.hbranch_fluxes.Outputs`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        As a simple example, assume a weir directing all discharge into
</span><span class="noop">        `branch1` until the capacity limit of 2 m³/s is reached.  The
</span><span class="noop">        discharge exceeding this threshold is directed into `branch2`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hbranch import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; xpoints(0., 2., 4.)
</span><span class="noop">        &gt;&gt;&gt; ypoints(branch1=[0., 2., 2.],
</span><span class="noop">        ...         branch2=[0., 0., 2.])
</span><span class="noop">        &gt;&gt;&gt; model.parameters.update()
</span><span class="noop">
</span><span class="noop">        Low discharge example (linear interpolation between the first two
</span><span class="noop">        supporting point pairs):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.input = 1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_outputs_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.outputs
</span><span class="noop">        outputs(branch1=1.0,
</span><span class="noop">                branch2=0.0)
</span><span class="noop">
</span><span class="noop">        Medium discharge example (linear interpolation between the second
</span><span class="noop">        two supporting point pairs):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.input = 3.
</span><span class="noop">        &gt;&gt;&gt; model.calc_outputs_v1()
</span><span class="noop">        &gt;&gt;&gt; print(fluxes.outputs)
</span><span class="noop">        outputs(branch1=2.0,
</span><span class="noop">                branch2=1.0)
</span><span class="noop">
</span><span class="noop">        High discharge example (linear extrapolation beyond the second two
</span><span class="noop">        supporting point pairs):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.input = 5.
</span><span class="noop">        &gt;&gt;&gt; model.calc_outputs_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.outputs
</span><span class="noop">        outputs(branch1=2.0,
</span><span class="noop">                branch2=3.0)
</span><span class="noop">
</span><span class="noop">        Non-monotonous relationships and balance violations are allowed,
</span><span class="noop">        e.g.:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; xpoints(0., 2., 4., 6.)
</span><span class="noop">        &gt;&gt;&gt; ypoints(branch1=[0., 2., 0., 0.],
</span><span class="noop">        ...         branch2=[0., 0., 2., 4.])
</span><span class="noop">        &gt;&gt;&gt; model.parameters.update()
</span><span class="noop">        &gt;&gt;&gt; fluxes.input = 7.
</span><span class="noop">        &gt;&gt;&gt; model.calc_outputs_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.outputs
</span><span class="noop">        outputs(branch1=0.0,
</span><span class="noop">                branch2=5.0)
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="noop">    # Search for the index of the two relevant x points...
</span><span class="hit">    for pdx in range(1, der.nmbpoints):
</span><span class="hit">        if con.xpoints[pdx] &gt; flu.input:
</span><span class="hit">            break
</span><span class="noop">    # ...and use it for linear interpolation (or extrapolation).
</span><span class="hit">    for bdx in range(der.nmbbranches):
</span><span class="hit">        flu.outputs[bdx] = (
</span><span class="noop">            (flu.input-con.xpoints[pdx-1]) *
</span><span class="noop">            (con.ypoints[bdx, pdx]-con.ypoints[bdx, pdx-1]) /
</span><span class="noop">            (con.xpoints[pdx]-con.xpoints[pdx-1]) +
</span><span class="noop">            con.ypoints[bdx, pdx-1])
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def update_inlets_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Updates :class:`~hydpy.models.hbranch.Input` based on
</span><span class="noop">    :class:`~hydpy.models.hbranch.Total`.&#34;&#34;&#34;
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    inl = self.sequences.inlets.fastaccess
</span><span class="hit">    flu.input = inl.total[0]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def update_outlets_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Updates :class:`~hydpy.models.hbranch.Branched` based on
</span><span class="noop">    :class:`~hydpy.models.hbranch.Outputs`.&#34;&#34;&#34;
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    out = self.sequences.outlets.fastaccess
</span><span class="hit">    for bdx in range(der.nmbbranches):
</span><span class="hit">        out.branched[bdx][0] += flu.outputs[bdx]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Model(modeltools.Model):
</span><span class="noop">    &#34;&#34;&#34;The HydPy-H-Branch model.
</span><span class="noop">
</span><span class="noop">    Additional attribute:
</span><span class="noop">      * nodenames (:class:`list`): Names of the outlet node names, the
</span><span class="noop">        actual model shall be connected to.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    _RUNMETHODS = (calc_outputs_v1,
</span><span class="noop">                   update_inlets_v1,
</span><span class="noop">                   update_outlets_v1)
</span><span class="noop">
</span><span class="hit">    def __init__(self):
</span><span class="hit">        modeltools.Model.__init__(self)
</span><span class="hit">        self.nodenames = []
</span><span class="noop">
</span><span class="hit">    def connect(self):
</span><span class="noop">        &#34;&#34;&#34;Connect the :class:`~hydpy.core.sequencetools.LinkSequence`
</span><span class="noop">        instances handled by the actual model to the
</span><span class="noop">        :class:`~hydpy.core.sequencetools.NodeSequence` instances
</span><span class="noop">        handled by one inlet node and multiple oulet nodes.
</span><span class="noop">
</span><span class="noop">        The HydPy-H-Branch model passes multiple output values to different
</span><span class="noop">        outlet nodes.  This requires additional information regarding the
</span><span class="noop">        `direction` of each output value.  Therefore, node names are used
</span><span class="noop">        as keywords.  Assume, the discharge value of `n1` shall be branched
</span><span class="noop">        to `n1a` and `n1b` via element `e1`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import *
</span><span class="noop">        &gt;&gt;&gt; n1, n1a, n1b = Node(&#39;n1&#39;), Node(&#39;n1a&#39;), Node(&#39;n1b&#39;)
</span><span class="noop">        &gt;&gt;&gt; e1 = Element(&#39;e1&#39;, inlets=n1, outlets=[n1a, n1b])
</span><span class="noop">
</span><span class="noop">        Then parameter :class:`YPoints` relates different supporting
</span><span class="noop">        points via its keyword arguments to the respective nodes:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hbranch import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; xpoints(0., 3.)
</span><span class="noop">        &gt;&gt;&gt; ypoints(n1a=[0., 1.], n1b=[0., 2.])
</span><span class="noop">
</span><span class="noop">        After doing some preparations which are normally handled by
</span><span class="noop">        :ref:`HydPy` automatically ...
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.element = e1
</span><span class="noop">        &gt;&gt;&gt; model.parameters.update()
</span><span class="noop">        &gt;&gt;&gt; model.connect()
</span><span class="noop">
</span><span class="noop">        ...you can see that an example discharge value handled by the
</span><span class="noop">        :class:`~hydpy.core.devicetools.Node` instance `n1` is properly
</span><span class="noop">        divided:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; n1.sequences.sim = 6.
</span><span class="noop">        &gt;&gt;&gt; model.doit(0)
</span><span class="noop">        &gt;&gt;&gt; print(n1a.sequences.sim, n1b.sequences.sim)
</span><span class="noop">        sim(2.0) sim(4.0)
</span><span class="noop">
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        nodes = self.element.inlets.slaves
</span><span class="hit">        if len(nodes) == 1:
</span><span class="hit">            double = nodes[0].getdouble_via_exits()
</span><span class="hit">            self.sequences.inlets.total.setpointer(double)
</span><span class="noop">        else:
</span><span class="miss">            RuntimeError(&#39;The hbranch model must be connected to exactly one &#39;
</span><span class="noop">                         &#39;inlet node, but its parent element `%s` references &#39;
</span><span class="noop">                         &#39;currently %d inlet nodes.&#39;
</span><span class="noop">                         % (self.element.name, len(nodes)))
</span><span class="hit">        for (idx, name) in enumerate(self.nodenames):
</span><span class="hit">            try:
</span><span class="hit">                double = self.element.outlets[name].getdouble_via_entries()
</span><span class="miss">            except KeyError:
</span><span class="miss">                if name in devicetools.Node.registerednames():
</span><span class="miss">                    RuntimeError(&#39;The hbranch model tried to connect to the &#39;
</span><span class="noop">                                 &#39;outlet node `%s`, but its parent element &#39;
</span><span class="noop">                                 &#39;`%s` does not reference this node as an &#39;
</span><span class="noop">                                 &#39;outlet node.&#39; % (name, self.element.name))
</span><span class="noop">                else:
</span><span class="miss">                    RuntimeError(&#39;The hbranch model tried to connect to an &#39;
</span><span class="noop">                                 &#39;outlet node named `%s`, which is not &#39;
</span><span class="noop">                                 &#39;initialized yet.&#39; % name)
</span><span class="hit">            self.sequences.outlets.branched.setpointer(double, idx)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hbranch/hbranch_outlets.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hbranch/hbranch_outlets.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Branched(sequencetools.LinkSequence):
</span><span class="noop">    &#34;&#34;&#34;Branched outputs [e.g. m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class OutletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Downstream link sequences of the hbranch model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Branched,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/__init__.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/__init__.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;
</span><span class="noop">The H-Land model is the core of the HydPy implementation of the
</span><span class="noop">the frequently applied HBV96 model.  It consists of some routines
</span><span class="noop">for the preparation of meteorological input, and some process
</span><span class="noop">routines related to interception, snow, soil moisture, upper
</span><span class="noop">groundwater, lower groundwater (including lakes), and runoff
</span><span class="noop">concentration.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core.modelimports import *
</span><span class="noop"># ...from hland
</span><span class="hit">from hydpy.models.hland.hland_constants import FIELD, FOREST, GLACIER, ILAKE
</span><span class="hit">from hydpy.models.hland.hland_parameters import Parameters
</span><span class="hit">from hydpy.models.hland.hland_control import ControlParameters
</span><span class="hit">from hydpy.models.hland.hland_derived import DerivedParameters
</span><span class="hit">from hydpy.models.hland.hland_inputs import InputSequences
</span><span class="hit">from hydpy.models.hland.hland_fluxes import FluxSequences
</span><span class="hit">from hydpy.models.hland.hland_states import StateSequences
</span><span class="hit">from hydpy.models.hland.hland_aides import AideSequences
</span><span class="hit">from hydpy.models.hland.hland_logs import LogSequences
</span><span class="hit">from hydpy.models.hland.hland_outlets import OutletSequences
</span><span class="hit">from hydpy.models.hland.hland_model import Model
</span><span class="noop">
</span><span class="hit">autodoc_basemodel()
</span><span class="hit">tester = Tester()
</span><span class="hit">cythonizer = Cythonizer()
</span><span class="hit">cythonizer.complete()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_aides.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_aides.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Perc(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Percolation from the upper to the lower zone layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Q0(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Outflow from the upper zone layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class AideSequences(sequencetools.AideSequences):
</span><span class="noop">    &#34;&#34;&#34;Aide sequences of the hland model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Perc, Q0)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_constants.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_constants.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;The HydPy-H-Land model (`hland`) allows for the subdivision of subbasins
</span><span class="noop">into zones (hydrological response units).  Some processes, e.g. interception,
</span><span class="noop">are calculated seperately for each zone.  This is why some parameters (e.g.
</span><span class="noop">the interception capacity :class:`~hydpy.models.hland.hland_control.IcMax`)
</span><span class="noop">and some sequences (e.g. the actual interception storage
</span><span class="noop">:class:`~hydpy.models.hland.hland_states.Ic`) are 1-dimensional.  Each entry
</span><span class="noop">represents the value of a different zone.
</span><span class="noop">
</span><span class="noop">In contrasts to the original HBV96 model, the HydPy-H-Land model allows for
</span><span class="noop">arbitrary definitions of zones.  Nevertheless, the original distinction
</span><span class="noop">in accordance with four different zone types is still supported.  The
</span><span class="noop">parameter :class:`~hydpy.models.hland.hland_control.ZoneType` defines,
</span><span class="noop">which entry of e.g. :class:`~hydpy.models.hland.hland_control.IcMax` is
</span><span class="noop">related to which zone type via integer values.  Note that for zones of
</span><span class="noop">type `field` and `forest`, the same equations are applied. (Usually,
</span><span class="noop">larger :class:`~hydpy.models.hland.hland_control.IcMax` values and smaller
</span><span class="noop">:class:`~hydpy.models.hland.hland_control.CFMax` are assigned to `forest`
</span><span class="noop">zones due to their higher leaf area index and the associated decrease in
</span><span class="noop">solar radiation.) On the contrary, zones of type `glacier` and `ilake` are
</span><span class="noop">partly connected to different process equations.
</span><span class="noop">
</span><span class="noop">For comprehensibility, this module introduces the relevant integer constants.
</span><span class="noop">Through performing a wildcard import
</span><span class="noop">
</span><span class="noop">&gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">
</span><span class="noop">these are available in your local namespace:
</span><span class="noop">
</span><span class="noop">&gt;&gt;&gt; FIELD, FOREST, GLACIER, ILAKE
</span><span class="noop">(1, 2, 3, 4)
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">FIELD = 1
</span><span class="noop">&#34;&#34;&#34;Constant for the zone type `field`.&#34;&#34;&#34;
</span><span class="hit">FOREST = 2
</span><span class="noop">&#34;&#34;&#34;Constant for the zone type `forest.`&#34;&#34;&#34;
</span><span class="hit">GLACIER = 3
</span><span class="noop">&#34;&#34;&#34;Constant for the zone type `glacier`.&#34;&#34;&#34;
</span><span class="hit">ILAKE = 4
</span><span class="noop">&#34;&#34;&#34;Constant for the zone type `internal lake`.&#34;&#34;&#34;
</span><span class="hit">CONSTANTS = {key: value for key, value in locals().items()
</span><span class="noop">             if (key.isupper() and isinstance(value, int))}
</span><span class="hit">&#34;&#34;&#34;Dictionary containing all constants defined by HydPy-H-Land.&#34;&#34;&#34;
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_control.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_control.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import parametertools
</span><span class="noop"># ...model specific
</span><span class="hit">from hydpy.models.hland import hland_constants
</span><span class="hit">from hydpy.models.hland import hland_parameters
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Area(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Subbasin area [km²].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (1e-10, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class NmbZones(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Number of zones (hydrological response units) in a subbasin [-].
</span><span class="noop">
</span><span class="noop">    Note that :class:`NmbZones` determines the length of most 1-dimensional
</span><span class="noop">    HydPy-H-Land parameters and sequences.  This required that the value of
</span><span class="noop">    the respective :class:`NmbZones` instance is set before any of the values
</span><span class="noop">    of these 1-dimensional parameters or sequences are set.  Changing the
</span><span class="noop">    value of the :class:`NmbZones` instance necessitates setting their values
</span><span class="noop">    again.
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(5)
</span><span class="noop">        &gt;&gt;&gt; icmax.shape
</span><span class="noop">        (5,)
</span><span class="noop">        &gt;&gt;&gt; states.ic.shape
</span><span class="noop">        (5,)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, int, None, (1, None)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="noop">        &#34;&#34;&#34;The prefered way to pass a value to :class:`NmbZones` instances
</span><span class="noop">        within parameter control files.  Sets the shape of most 1-dimensional
</span><span class="noop">        parameter objects (except :class:`UH`) and sequence objects (except
</span><span class="noop">        :class:`QUH`) additionally.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        parametertools.SingleParameter.__call__(self, *args, **kwargs)
</span><span class="hit">        for (_name, subpars) in self.subpars.pars.model.parameters:
</span><span class="hit">            for (name, par) in subpars:
</span><span class="hit">                if (par.NDIM &gt; 0) and (name != &#39;uh&#39;):
</span><span class="hit">                    par.shape = self.value
</span><span class="hit">        for (_name, subseqs) in self.subpars.pars.model.sequences:
</span><span class="hit">            for (name, seq) in subseqs:
</span><span class="hit">                if (seq.NDIM &gt; 0) and (name != &#39;quh&#39;):
</span><span class="hit">                    seq.shape = self.value
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ZoneType(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Type of each zone: 1 (FIELD), 2 (FOREST), 3 (GLACIER), or 4 (ILAKE).
</span><span class="noop">
</span><span class="noop">    For increasing legibility, the HydPy-H-Land constants are used for string
</span><span class="noop">    representions of :class:`ZoneType` instances:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">    &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">    &gt;&gt;&gt; nmbzones(8)
</span><span class="noop">    &gt;&gt;&gt; zonetype(FIELD, FOREST, GLACIER, ILAKE, ILAKE, GLACIER, FOREST, FIELD)
</span><span class="noop">    &gt;&gt;&gt; zonetype.values
</span><span class="noop">    array([1, 2, 3, 4, 4, 3, 2, 1])
</span><span class="noop">    &gt;&gt;&gt; zonetype
</span><span class="noop">    zonetype(FIELD, FOREST, GLACIER, ILAKE, ILAKE, GLACIER, FOREST, FIELD)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, int, None, (1, 4)
</span><span class="noop">
</span><span class="hit">    def compressrepr(self):
</span><span class="noop">        &#34;&#34;&#34;Returns a list which contains a string representation with zone
</span><span class="noop">        types beeing defined by the constants `FIELD`, `FOREST`...
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        invmap = {value: key for key, value in
</span><span class="noop">                  hland_constants.CONSTANTS.items()}
</span><span class="hit">        return [&#39;, &#39;.join(invmap.get(value, repr(value))
</span><span class="noop">                          for value in self.values)]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ZoneArea(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Zone area [km²].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ZoneZ(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Zone elevation [100m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ZRelT(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Subbasin-wide reference elevation level for temperature [100m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ZRelP(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Subbasin-wide reference elevation level for precipitation [100m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ZRelE(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Subbasin-wide reference elevation level for evaporation [100m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class PCorr(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;General precipitation correction factor [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class PCAlt(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Elevation correction factor for precipitation [-1/100m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RfCF(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Rainfall correction factor [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class SfCF(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Snowfall correction factor [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TCAlt(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Elevation correction factor for temperature [-1°C/100m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ECorr(hland_parameters.MultiParameterNoGlacier):
</span><span class="noop">    &#34;&#34;&#34;General evaporation correction factor [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ECAlt(hland_parameters.MultiParameterNoGlacier):
</span><span class="noop">    &#34;&#34;&#34;Elevation correction factor for evaporation [-1/100m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class EPF(hland_parameters.MultiParameterNoGlacier):
</span><span class="noop">    &#34;&#34;&#34;Decrease in potential evaporation due to precipitation [T/mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ETF(hland_parameters.MultiParameterNoGlacier):
</span><span class="noop">    &#34;&#34;&#34;Temperature factor for evaporation [1/°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ERed(hland_parameters.MultiParameterSoil):
</span><span class="noop">    &#34;&#34;&#34;Factor for restricting actual to potential evaporation [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., 1.)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TTIce(hland_parameters.MultiParameterLake):
</span><span class="noop">    &#34;&#34;&#34;Temperature threshold for lake evaporation [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class IcMax(hland_parameters.MultiParameterSoil):
</span><span class="noop">    &#34;&#34;&#34;Maximum interception storage [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TT(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Temperature threshold for snow/rain [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TTInt(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Temperature interval with a mixture of snow and rain [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class DTTM(hland_parameters.MultiParameterLand):
</span><span class="noop">    &#34;&#34;&#34;Difference between :class:`TTM` and :class:`TT` [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class CFMax(hland_parameters.MultiParameterLand):
</span><span class="noop">    &#34;&#34;&#34;Degree day factor for snow (on glaciers or not) [mm/°C/T].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, True, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class GMelt(hland_parameters.MultiParameterGlacier):
</span><span class="noop">    &#34;&#34;&#34;Degree day factor for glacial ice [mm/°C/T].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, True, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class CFR(hland_parameters.MultiParameterLand):
</span><span class="noop">    &#34;&#34;&#34;Refreezing factor for water stored within the snow layer [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class WHC(hland_parameters.MultiParameterLand):
</span><span class="noop">    &#34;&#34;&#34;Relative water holding capacity of the snow layer [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FC(hland_parameters.MultiParameterSoil):
</span><span class="noop">    &#34;&#34;&#34;Maximum soil moisture content (field capacity) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class LP(hland_parameters.MultiParameterSoil):
</span><span class="noop">    &#34;&#34;&#34;Relative limit for potential evaporation [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., 1.)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Beta(hland_parameters.MultiParameterSoil):
</span><span class="noop">    &#34;&#34;&#34;Nonlinearity parameter of the soil routine [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class CFlux(hland_parameters.MultiParameterSoil):
</span><span class="noop">    &#34;&#34;&#34;Capacity (maximum) of the capillary return flux [mm/T].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, True, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RespArea(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Flag to enable the contibuting area approach [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, bool, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RecStep(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Number of internal computation steps per simulation time step [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, int, True, (1, None)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="hit">        parametertools.SingleParameter.__call__(self, *args, **kwargs)
</span><span class="hit">        self.value = int(round(self.value))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class PercMax(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Maximum percolation rate [mm/T].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, True, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class K(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Recession coefficient of the upper zone layer [1/T/mm^alpha].
</span><span class="noop">
</span><span class="noop">    In addition to the :class:`parametertools.SingleParameter` call method, it
</span><span class="noop">    is possible to set the value of parameter :class:`K` in accordance to
</span><span class="noop">    the keyword arguments `khq`, `hq` and (optionally) `alpha`.  If `alpha`
</span><span class="noop">    is not given, the value of the respective :class:`Alpha` instance is
</span><span class="noop">    taken.  This requires the :class:`Alpha` instance to be initialized
</span><span class="noop">    beforehand.
</span><span class="noop">
</span><span class="noop">    Basic Equation:
</span><span class="noop">        :math:`K = \\frac{HQ}{(HQ/KHQ)^{1+Alpha}}`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        When directly setting the value of parameter k, one only needs to be
</span><span class="noop">        aware of its time dependence:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; k(2.)
</span><span class="noop">        &gt;&gt;&gt; k
</span><span class="noop">        k(2.0)
</span><span class="noop">        &gt;&gt;&gt; k.value
</span><span class="noop">        1.0
</span><span class="noop">
</span><span class="noop">        Alternatively, one can specify the following three keyword
</span><span class="noop">        arguments directly,...
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; k(hq=10., khq=2., alpha=1.)
</span><span class="noop">        &gt;&gt;&gt; k
</span><span class="noop">        k(0.4)
</span><span class="noop">        &gt;&gt;&gt; k.value
</span><span class="noop">        0.2
</span><span class="noop">
</span><span class="noop">        ...or define the value of parameter alpha beforehand:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; alpha(2.)
</span><span class="noop">        &gt;&gt;&gt; k(hq=10., khq=2.)
</span><span class="noop">        &gt;&gt;&gt; k
</span><span class="noop">        k(0.08)
</span><span class="noop">        &gt;&gt;&gt; k.value
</span><span class="noop">        0.04
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, True, (0., None)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="noop">        &#34;&#34;&#34;The prefered way to pass values to :class:`K` instances
</span><span class="noop">        within parameter control files.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            parametertools.SingleParameter.__call__(self, *args, **kwargs)
</span><span class="hit">        except NotImplementedError:
</span><span class="hit">            counter = (&#39;khq&#39; in kwargs) + (&#39;hq&#39; in kwargs)
</span><span class="hit">            if counter == 0:
</span><span class="miss">                raise ValueError(&#39;For parameter `k` a value can be set &#39;
</span><span class="noop">                                 &#39;directly or indirectly by using the &#39;
</span><span class="noop">                                 &#39;keyword arguments `khq` and `hq`.&#39;)
</span><span class="hit">            elif counter == 1:
</span><span class="miss">                raise ValueError(&#39;For the alternative calculation of &#39;
</span><span class="noop">                                 &#39;parameter `k`, at least the keywords &#39;
</span><span class="noop">                                 &#39;arguments `khq` and `hq` must be given.&#39;)
</span><span class="hit">            elif counter == 2:
</span><span class="hit">                try:
</span><span class="hit">                    alpha = float(kwargs[&#39;alpha&#39;])
</span><span class="hit">                except KeyError:
</span><span class="hit">                    try:
</span><span class="hit">                        alpha = self.subpars.alpha.value
</span><span class="miss">                    except (AttributeError, RuntimeError):
</span><span class="miss">                        raise RuntimeError(&#39;For the alternative calculation &#39;
</span><span class="noop">                                           &#39;of parameter `k`, either the &#39;
</span><span class="noop">                                           &#39;keyword argument `alpha` must be &#39;
</span><span class="noop">                                           &#39;given or the value of parameter &#39;
</span><span class="noop">                                           &#39;`alpha` must be defined &#39;
</span><span class="noop">                                           &#39;beforehand.&#39;)
</span><span class="hit">                khq = float(kwargs[&#39;khq&#39;])
</span><span class="hit">                hq = float(kwargs[&#39;hq&#39;])
</span><span class="hit">                self(hq/((hq/khq)**(alpha+1.)))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Alpha(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Nonlinearity parameter of the upper zone layer [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class K4(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Recession coefficient of the lower zone layer [1/T].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, True, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Gamma(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Nonlinearity parameter of the lower zone layer [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MaxBaz(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Base length of the triangle unit hydrograph [T].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Abstr(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Abstraction of water from computed outflow [mm/T].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, True, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ControlParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Control parameters of HydPy-H-Land, directly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (Area, NmbZones, ZoneType, ZoneArea, ZoneZ, ZRelP, ZRelT,
</span><span class="noop">                   ZRelE, PCorr, PCAlt, RfCF, SfCF, TCAlt, ECorr, ECAlt, EPF,
</span><span class="noop">                   ETF, ERed, TTIce, IcMax, TT, TTInt, DTTM, CFMax, GMelt, CFR,
</span><span class="noop">                   WHC, FC, LP, Beta, PercMax, CFlux, RespArea, RecStep, Alpha,
</span><span class="noop">                   K, K4, Gamma, MaxBaz, Abstr)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_derived.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_derived.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import parametertools
</span><span class="noop"># ...model specific
</span><span class="hit">from hydpy.models.hland import hland_parameters
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RelZoneArea(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Relative zone area [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., 1.)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RelSoilArea(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Total area of all `field` and `forest` zones [km²].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., 1.)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RelSoilZoneArea(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Relative zone area of all `field` and `forest` zones [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., 1.)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RelLandZoneArea(hland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Relative Zone area of all `field`, `forest` and `glacier` zones [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., 1.)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RelLandArea(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Quotient of the sum of :class:`LandZoneArea` and :class:`Area` [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., 1.)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TTM(hland_parameters.MultiParameterLand):
</span><span class="noop">    &#34;&#34;&#34;Threshold temperature for snow melting and refreezing [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class DT(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Relative time step length for the upper zone layer calculations [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., 1.)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class NmbUH(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Number of the required unit hydrograph ordinates [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, int, None, (0, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class UH(parametertools.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Unit hydrograph ordinates [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., 1.)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QFactor(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Factor for converting mm/stepsize to m³/s.&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class DerivedParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Derived parameters of HydPy-H-Land, indirectly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (RelZoneArea, RelSoilArea, RelSoilZoneArea, RelLandZoneArea,
</span><span class="noop">                   RelLandArea, TTM, DT, NmbUH, UH, QFactor)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_fluxes.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_fluxes.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TMean(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Mean subbasin temperature [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TC(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Corrected temperature [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FracRain(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Fraction rainfall / total precipitation [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RfC(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Actual precipitation correction related to liquid precipitation [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class SfC(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Actual precipitation correction related to frozen precipitation [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class PC(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Corrected precipitation [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class EP(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Potential evaporation [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class EPC(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Corrected potential evaporation [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class EI(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Interception evaporation [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TF(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Throughfall [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TFWat(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Liquid throughfall [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TFIce(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Frozen throughfall [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class GlMelt(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Glacier melt [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MeltPot(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Potential melting of frozen water stored in the snow layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Melt(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Actual melting of frozen water stored in the snow layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RefrPot(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Potential (re)freezing of liquid water stored in the snow layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Refr(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Actual (re)freezing of liquid water stored in the snow layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class In_(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Snow module release / soil module inflow [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class R(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Effective soil response [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class EA(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Actual soil evaporation [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class CFPot(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Potential capillary flow [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class CF(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Actual capillary flow [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ContriArea(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Fraction of the `soil area` contributing to runoff generation [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class InUZ(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Inflow to the upper zone layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Perc(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Percolation from the upper to the lower zone layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Q0(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Outflow from the upper zone layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class EL(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Actual lake evaporation [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Q1(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Outflow from the lower zone layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class InUH(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Input of the triangle unit hydrograph  [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class OutUH(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Output of the triangle unit hydrograph  [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QT(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Total model outflow [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FluxSequences(sequencetools.FluxSequences):
</span><span class="noop">    &#34;&#34;&#34;Flux sequences of the HydPy-H-Land model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (TMean, TC, FracRain, RfC, SfC, PC, EP, EPC, EI, TF, TFWat,
</span><span class="noop">                   TFIce, GlMelt, MeltPot, Melt, RefrPot, Refr, In_, R,
</span><span class="noop">                   EA, CFPot, CF, Perc, ContriArea, InUZ, Q0, EL, Q1,
</span><span class="noop">                   InUH, OutUH, QT)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_inputs.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_inputs.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class P(sequencetools.InputSequence):
</span><span class="noop">    &#34;&#34;&#34;Precipitation [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class T(sequencetools.InputSequence):
</span><span class="noop">    &#34;&#34;&#34;Temperature [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TN(sequencetools.InputSequence):
</span><span class="noop">    &#34;&#34;&#34;Normal temperature [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class EPN(sequencetools.InputSequence):
</span><span class="noop">    &#34;&#34;&#34;Normal potential evaporation [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class InputSequences(sequencetools.InputSequences):
</span><span class="noop">    &#34;&#34;&#34;Input sequences of the hland model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (P, T, TN, EPN)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_logs.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_logs.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import sys
</span><span class="hit">import warnings
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QUH(sequencetools.LogSequence):
</span><span class="noop">    &#34;&#34;&#34;Whole outflow delayed by means of the unit hydrograph [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (0., None)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args):
</span><span class="miss">        try:
</span><span class="miss">            sequencetools.LogSequence.__call__(self, *args)
</span><span class="miss">        except BaseException:
</span><span class="miss">            message = sys.exc_info()[1]
</span><span class="miss">            sequencetools.LogSequence.__call__(self, numpy.sum(args))
</span><span class="miss">            warnings.warn(&#39;Note that, due to the following problem, the &#39;
</span><span class="noop">                          &#39;unit-hydrograph of the affected HydPy-H-Land &#39;
</span><span class="noop">                          &#39;model could be initialised with an summed &#39;
</span><span class="noop">                          &#39;value only: %s&#39; % message)
</span><span class="noop">        # The last value must be zero, otherwise all results were biased:
</span><span class="miss">        self.values[-1] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class LogSequences(sequencetools.LogSequences):
</span><span class="noop">    &#34;&#34;&#34;Log sequences of the hland model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (QUH,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_model.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_model.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
677 &nbsp;
678 &nbsp;
679 &nbsp;
680 &nbsp;
681 &nbsp;
682 &nbsp;
683 &nbsp;
684 &nbsp;
685 &nbsp;
686 &nbsp;
687 &nbsp;
688 &nbsp;
689 &nbsp;
690 &nbsp;
691 &nbsp;
692 &nbsp;
693 &nbsp;
694 &nbsp;
695 &nbsp;
696 &nbsp;
697 &nbsp;
698 &nbsp;
699 &nbsp;
700 &nbsp;
701 &nbsp;
702 &nbsp;
703 &nbsp;
704 &nbsp;
705 &nbsp;
706 &nbsp;
707 &nbsp;
708 &nbsp;
709 &nbsp;
710 &nbsp;
711 &nbsp;
712 &nbsp;
713 &nbsp;
714 &nbsp;
715 &nbsp;
716 &nbsp;
717 &nbsp;
718 &nbsp;
719 &nbsp;
720 &nbsp;
721 &nbsp;
722 &nbsp;
723 &nbsp;
724 &nbsp;
725 &nbsp;
726 &nbsp;
727 &nbsp;
728 &nbsp;
729 &nbsp;
730 &nbsp;
731 &nbsp;
732 &nbsp;
733 &nbsp;
734 &nbsp;
735 &nbsp;
736 &nbsp;
737 &nbsp;
738 &nbsp;
739 &nbsp;
740 &nbsp;
741 &nbsp;
742 &nbsp;
743 &nbsp;
744 &nbsp;
745 &nbsp;
746 &nbsp;
747 &nbsp;
748 &nbsp;
749 &nbsp;
750 &nbsp;
751 &nbsp;
752 &nbsp;
753 &nbsp;
754 &nbsp;
755 &nbsp;
756 &nbsp;
757 &nbsp;
758 &nbsp;
759 &nbsp;
760 &nbsp;
761 &nbsp;
762 &nbsp;
763 &nbsp;
764 &nbsp;
765 &nbsp;
766 &nbsp;
767 &nbsp;
768 &nbsp;
769 &nbsp;
770 &nbsp;
771 &nbsp;
772 &nbsp;
773 &nbsp;
774 &nbsp;
775 &nbsp;
776 &nbsp;
777 &nbsp;
778 &nbsp;
779 &nbsp;
780 &nbsp;
781 &nbsp;
782 &nbsp;
783 &nbsp;
784 &nbsp;
785 &nbsp;
786 &nbsp;
787 &nbsp;
788 &nbsp;
789 &nbsp;
790 &nbsp;
791 &nbsp;
792 &nbsp;
793 &nbsp;
794 &nbsp;
795 &nbsp;
796 &nbsp;
797 &nbsp;
798 &nbsp;
799 &nbsp;
800 &nbsp;
801 &nbsp;
802 &nbsp;
803 &nbsp;
804 &nbsp;
805 &nbsp;
806 &nbsp;
807 &nbsp;
808 &nbsp;
809 &nbsp;
810 &nbsp;
811 &nbsp;
812 &nbsp;
813 &nbsp;
814 &nbsp;
815 &nbsp;
816 &nbsp;
817 &nbsp;
818 &nbsp;
819 &nbsp;
820 &nbsp;
821 &nbsp;
822 &nbsp;
823 &nbsp;
824 &nbsp;
825 &nbsp;
826 &nbsp;
827 &nbsp;
828 &nbsp;
829 &nbsp;
830 &nbsp;
831 &nbsp;
832 &nbsp;
833 &nbsp;
834 &nbsp;
835 &nbsp;
836 &nbsp;
837 &nbsp;
838 &nbsp;
839 &nbsp;
840 &nbsp;
841 &nbsp;
842 &nbsp;
843 &nbsp;
844 &nbsp;
845 &nbsp;
846 &nbsp;
847 &nbsp;
848 &nbsp;
849 &nbsp;
850 &nbsp;
851 &nbsp;
852 &nbsp;
853 &nbsp;
854 &nbsp;
855 &nbsp;
856 &nbsp;
857 &nbsp;
858 &nbsp;
859 &nbsp;
860 &nbsp;
861 &nbsp;
862 &nbsp;
863 &nbsp;
864 &nbsp;
865 &nbsp;
866 &nbsp;
867 &nbsp;
868 &nbsp;
869 &nbsp;
870 &nbsp;
871 &nbsp;
872 &nbsp;
873 &nbsp;
874 &nbsp;
875 &nbsp;
876 &nbsp;
877 &nbsp;
878 &nbsp;
879 &nbsp;
880 &nbsp;
881 &nbsp;
882 &nbsp;
883 &nbsp;
884 &nbsp;
885 &nbsp;
886 &nbsp;
887 &nbsp;
888 &nbsp;
889 &nbsp;
890 &nbsp;
891 &nbsp;
892 &nbsp;
893 &nbsp;
894 &nbsp;
895 &nbsp;
896 &nbsp;
897 &nbsp;
898 &nbsp;
899 &nbsp;
900 &nbsp;
901 &nbsp;
902 &nbsp;
903 &nbsp;
904 &nbsp;
905 &nbsp;
906 &nbsp;
907 &nbsp;
908 &nbsp;
909 &nbsp;
910 &nbsp;
911 &nbsp;
912 &nbsp;
913 &nbsp;
914 &nbsp;
915 &nbsp;
916 &nbsp;
917 &nbsp;
918 &nbsp;
919 &nbsp;
920 &nbsp;
921 &nbsp;
922 &nbsp;
923 &nbsp;
924 &nbsp;
925 &nbsp;
926 &nbsp;
927 &nbsp;
928 &nbsp;
929 &nbsp;
930 &nbsp;
931 &nbsp;
932 &nbsp;
933 &nbsp;
934 &nbsp;
935 &nbsp;
936 &nbsp;
937 &nbsp;
938 &nbsp;
939 &nbsp;
940 &nbsp;
941 &nbsp;
942 &nbsp;
943 &nbsp;
944 &nbsp;
945 &nbsp;
946 &nbsp;
947 &nbsp;
948 &nbsp;
949 &nbsp;
950 &nbsp;
951 &nbsp;
952 &nbsp;
953 &nbsp;
954 &nbsp;
955 &nbsp;
956 &nbsp;
957 &nbsp;
958 &nbsp;
959 &nbsp;
960 &nbsp;
961 &nbsp;
962 &nbsp;
963 &nbsp;
964 &nbsp;
965 &nbsp;
966 &nbsp;
967 &nbsp;
968 &nbsp;
969 &nbsp;
970 &nbsp;
971 &nbsp;
972 &nbsp;
973 &nbsp;
974 &nbsp;
975 &nbsp;
976 &nbsp;
977 &nbsp;
978 &nbsp;
979 &nbsp;
980 &nbsp;
981 &nbsp;
982 &nbsp;
983 &nbsp;
984 &nbsp;
985 &nbsp;
986 &nbsp;
987 &nbsp;
988 &nbsp;
989 &nbsp;
990 &nbsp;
991 &nbsp;
992 &nbsp;
993 &nbsp;
994 &nbsp;
995 &nbsp;
996 &nbsp;
997 &nbsp;
998 &nbsp;
999 &nbsp;
1000 &nbsp;
1001 &nbsp;
1002 &nbsp;
1003 &nbsp;
1004 &nbsp;
1005 &nbsp;
1006 &nbsp;
1007 &nbsp;
1008 &nbsp;
1009 &nbsp;
1010 &nbsp;
1011 &nbsp;
1012 &nbsp;
1013 &nbsp;
1014 &nbsp;
1015 &nbsp;
1016 &nbsp;
1017 &nbsp;
1018 &nbsp;
1019 &nbsp;
1020 &nbsp;
1021 &nbsp;
1022 &nbsp;
1023 &nbsp;
1024 &nbsp;
1025 &nbsp;
1026 &nbsp;
1027 &nbsp;
1028 &nbsp;
1029 &nbsp;
1030 &nbsp;
1031 &nbsp;
1032 &nbsp;
1033 &nbsp;
1034 &nbsp;
1035 &nbsp;
1036 &nbsp;
1037 &nbsp;
1038 &nbsp;
1039 &nbsp;
1040 &nbsp;
1041 &nbsp;
1042 &nbsp;
1043 &nbsp;
1044 &nbsp;
1045 &nbsp;
1046 &nbsp;
1047 &nbsp;
1048 &nbsp;
1049 &nbsp;
1050 &nbsp;
1051 &nbsp;
1052 &nbsp;
1053 &nbsp;
1054 &nbsp;
1055 &nbsp;
1056 &nbsp;
1057 &nbsp;
1058 &nbsp;
1059 &nbsp;
1060 &nbsp;
1061 &nbsp;
1062 &nbsp;
1063 &nbsp;
1064 &nbsp;
1065 &nbsp;
1066 &nbsp;
1067 &nbsp;
1068 &nbsp;
1069 &nbsp;
1070 &nbsp;
1071 &nbsp;
1072 &nbsp;
1073 &nbsp;
1074 &nbsp;
1075 &nbsp;
1076 &nbsp;
1077 &nbsp;
1078 &nbsp;
1079 &nbsp;
1080 &nbsp;
1081 &nbsp;
1082 &nbsp;
1083 &nbsp;
1084 &nbsp;
1085 &nbsp;
1086 &nbsp;
1087 &nbsp;
1088 &nbsp;
1089 &nbsp;
1090 &nbsp;
1091 &nbsp;
1092 &nbsp;
1093 &nbsp;
1094 &nbsp;
1095 &nbsp;
1096 &nbsp;
1097 &nbsp;
1098 &nbsp;
1099 &nbsp;
1100 &nbsp;
1101 &nbsp;
1102 &nbsp;
1103 &nbsp;
1104 &nbsp;
1105 &nbsp;
1106 &nbsp;
1107 &nbsp;
1108 &nbsp;
1109 &nbsp;
1110 &nbsp;
1111 &nbsp;
1112 &nbsp;
1113 &nbsp;
1114 &nbsp;
1115 &nbsp;
1116 &nbsp;
1117 &nbsp;
1118 &nbsp;
1119 &nbsp;
1120 &nbsp;
1121 &nbsp;
1122 &nbsp;
1123 &nbsp;
1124 &nbsp;
1125 &nbsp;
1126 &nbsp;
1127 &nbsp;
1128 &nbsp;
1129 &nbsp;
1130 &nbsp;
1131 &nbsp;
1132 &nbsp;
1133 &nbsp;
1134 &nbsp;
1135 &nbsp;
1136 &nbsp;
1137 &nbsp;
1138 &nbsp;
1139 &nbsp;
1140 &nbsp;
1141 &nbsp;
1142 &nbsp;
1143 &nbsp;
1144 &nbsp;
1145 &nbsp;
1146 &nbsp;
1147 &nbsp;
1148 &nbsp;
1149 &nbsp;
1150 &nbsp;
1151 &nbsp;
1152 &nbsp;
1153 &nbsp;
1154 &nbsp;
1155 &nbsp;
1156 &nbsp;
1157 &nbsp;
1158 &nbsp;
1159 &nbsp;
1160 &nbsp;
1161 &nbsp;
1162 &nbsp;
1163 &nbsp;
1164 &nbsp;
1165 &nbsp;
1166 &nbsp;
1167 &nbsp;
1168 &nbsp;
1169 &nbsp;
1170 &nbsp;
1171 &nbsp;
1172 &nbsp;
1173 &nbsp;
1174 &nbsp;
1175 &nbsp;
1176 &nbsp;
1177 &nbsp;
1178 &nbsp;
1179 &nbsp;
1180 &nbsp;
1181 &nbsp;
1182 &nbsp;
1183 &nbsp;
1184 &nbsp;
1185 &nbsp;
1186 &nbsp;
1187 &nbsp;
1188 &nbsp;
1189 &nbsp;
1190 &nbsp;
1191 &nbsp;
1192 &nbsp;
1193 &nbsp;
1194 &nbsp;
1195 &nbsp;
1196 &nbsp;
1197 &nbsp;
1198 &nbsp;
1199 &nbsp;
1200 &nbsp;
1201 &nbsp;
1202 &nbsp;
1203 &nbsp;
1204 &nbsp;
1205 &nbsp;
1206 &nbsp;
1207 &nbsp;
1208 &nbsp;
1209 &nbsp;
1210 &nbsp;
1211 &nbsp;
1212 &nbsp;
1213 &nbsp;
1214 &nbsp;
1215 &nbsp;
1216 &nbsp;
1217 &nbsp;
1218 &nbsp;
1219 &nbsp;
1220 &nbsp;
1221 &nbsp;
1222 &nbsp;
1223 &nbsp;
1224 &nbsp;
1225 &nbsp;
1226 &nbsp;
1227 &nbsp;
1228 &nbsp;
1229 &nbsp;
1230 &nbsp;
1231 &nbsp;
1232 &nbsp;
1233 &nbsp;
1234 &nbsp;
1235 &nbsp;
1236 &nbsp;
1237 &nbsp;
1238 &nbsp;
1239 &nbsp;
1240 &nbsp;
1241 &nbsp;
1242 &nbsp;
1243 &nbsp;
1244 &nbsp;
1245 &nbsp;
1246 &nbsp;
1247 &nbsp;
1248 &nbsp;
1249 &nbsp;
1250 &nbsp;
1251 &nbsp;
1252 &nbsp;
1253 &nbsp;
1254 &nbsp;
1255 &nbsp;
1256 &nbsp;
1257 &nbsp;
1258 &nbsp;
1259 &nbsp;
1260 &nbsp;
1261 &nbsp;
1262 &nbsp;
1263 &nbsp;
1264 &nbsp;
1265 &nbsp;
1266 &nbsp;
1267 &nbsp;
1268 &nbsp;
1269 &nbsp;
1270 &nbsp;
1271 &nbsp;
1272 &nbsp;
1273 &nbsp;
1274 &nbsp;
1275 &nbsp;
1276 &nbsp;
1277 &nbsp;
1278 &nbsp;
1279 &nbsp;
1280 &nbsp;
1281 &nbsp;
1282 &nbsp;
1283 &nbsp;
1284 &nbsp;
1285 &nbsp;
1286 &nbsp;
1287 &nbsp;
1288 &nbsp;
1289 &nbsp;
1290 &nbsp;
1291 &nbsp;
1292 &nbsp;
1293 &nbsp;
1294 &nbsp;
1295 &nbsp;
1296 &nbsp;
1297 &nbsp;
1298 &nbsp;
1299 &nbsp;
1300 &nbsp;
1301 &nbsp;
1302 &nbsp;
1303 &nbsp;
1304 &nbsp;
1305 &nbsp;
1306 &nbsp;
1307 &nbsp;
1308 &nbsp;
1309 &nbsp;
1310 &nbsp;
1311 &nbsp;
1312 &nbsp;
1313 &nbsp;
1314 &nbsp;
1315 &nbsp;
1316 &nbsp;
1317 &nbsp;
1318 &nbsp;
1319 &nbsp;
1320 &nbsp;
1321 &nbsp;
1322 &nbsp;
1323 &nbsp;
1324 &nbsp;
1325 &nbsp;
1326 &nbsp;
1327 &nbsp;
1328 &nbsp;
1329 &nbsp;
1330 &nbsp;
1331 &nbsp;
1332 &nbsp;
1333 &nbsp;
1334 &nbsp;
1335 &nbsp;
1336 &nbsp;
1337 &nbsp;
1338 &nbsp;
1339 &nbsp;
1340 &nbsp;
1341 &nbsp;
1342 &nbsp;
1343 &nbsp;
1344 &nbsp;
1345 &nbsp;
1346 &nbsp;
1347 &nbsp;
1348 &nbsp;
1349 &nbsp;
1350 &nbsp;
1351 &nbsp;
1352 &nbsp;
1353 &nbsp;
1354 &nbsp;
1355 &nbsp;
1356 &nbsp;
1357 &nbsp;
1358 &nbsp;
1359 &nbsp;
1360 &nbsp;
1361 &nbsp;
1362 &nbsp;
1363 &nbsp;
1364 &nbsp;
1365 &nbsp;
1366 &nbsp;
1367 &nbsp;
1368 &nbsp;
1369 &nbsp;
1370 &nbsp;
1371 &nbsp;
1372 &nbsp;
1373 &nbsp;
1374 &nbsp;
1375 &nbsp;
1376 &nbsp;
1377 &nbsp;
1378 &nbsp;
1379 &nbsp;
1380 &nbsp;
1381 &nbsp;
1382 &nbsp;
1383 &nbsp;
1384 &nbsp;
1385 &nbsp;
1386 &nbsp;
1387 &nbsp;
1388 &nbsp;
1389 &nbsp;
1390 &nbsp;
1391 &nbsp;
1392 &nbsp;
1393 &nbsp;
1394 &nbsp;
1395 &nbsp;
1396 &nbsp;
1397 &nbsp;
1398 &nbsp;
1399 &nbsp;
1400 &nbsp;
1401 &nbsp;
1402 &nbsp;
1403 &nbsp;
1404 &nbsp;
1405 &nbsp;
1406 &nbsp;
1407 &nbsp;
1408 &nbsp;
1409 &nbsp;
1410 &nbsp;
1411 &nbsp;
1412 &nbsp;
1413 &nbsp;
1414 &nbsp;
1415 &nbsp;
1416 &nbsp;
1417 &nbsp;
1418 &nbsp;
1419 &nbsp;
1420 &nbsp;
1421 &nbsp;
1422 &nbsp;
1423 &nbsp;
1424 &nbsp;
1425 &nbsp;
1426 &nbsp;
1427 &nbsp;
1428 &nbsp;
1429 &nbsp;
1430 &nbsp;
1431 &nbsp;
1432 &nbsp;
1433 &nbsp;
1434 &nbsp;
1435 &nbsp;
1436 &nbsp;
1437 &nbsp;
1438 &nbsp;
1439 &nbsp;
1440 &nbsp;
1441 &nbsp;
1442 &nbsp;
1443 &nbsp;
1444 &nbsp;
1445 &nbsp;
1446 &nbsp;
1447 &nbsp;
1448 &nbsp;
1449 &nbsp;
1450 &nbsp;
1451 &nbsp;
1452 &nbsp;
1453 &nbsp;
1454 &nbsp;
1455 &nbsp;
1456 &nbsp;
1457 &nbsp;
1458 &nbsp;
1459 &nbsp;
1460 &nbsp;
1461 &nbsp;
1462 &nbsp;
1463 &nbsp;
1464 &nbsp;
1465 &nbsp;
1466 &nbsp;
1467 &nbsp;
1468 &nbsp;
1469 &nbsp;
1470 &nbsp;
1471 &nbsp;
1472 &nbsp;
1473 &nbsp;
1474 &nbsp;
1475 &nbsp;
1476 &nbsp;
1477 &nbsp;
1478 &nbsp;
1479 &nbsp;
1480 &nbsp;
1481 &nbsp;
1482 &nbsp;
1483 &nbsp;
1484 &nbsp;
1485 &nbsp;
1486 &nbsp;
1487 &nbsp;
1488 &nbsp;
1489 &nbsp;
1490 &nbsp;
1491 &nbsp;
1492 &nbsp;
1493 &nbsp;
1494 &nbsp;
1495 &nbsp;
1496 &nbsp;
1497 &nbsp;
1498 &nbsp;
1499 &nbsp;
1500 &nbsp;
1501 &nbsp;
1502 &nbsp;
1503 &nbsp;
1504 &nbsp;
1505 &nbsp;
1506 &nbsp;
1507 &nbsp;
1508 &nbsp;
1509 &nbsp;
1510 &nbsp;
1511 &nbsp;
1512 &nbsp;
1513 &nbsp;
1514 &nbsp;
1515 &nbsp;
1516 &nbsp;
1517 &nbsp;
1518 &nbsp;
1519 &nbsp;
1520 &nbsp;
1521 &nbsp;
1522 &nbsp;
1523 &nbsp;
1524 &nbsp;
1525 &nbsp;
1526 &nbsp;
1527 &nbsp;
1528 &nbsp;
1529 &nbsp;
1530 &nbsp;
1531 &nbsp;
1532 &nbsp;
1533 &nbsp;
1534 &nbsp;
1535 &nbsp;
1536 &nbsp;
1537 &nbsp;
1538 &nbsp;
1539 &nbsp;
1540 &nbsp;
1541 &nbsp;
1542 &nbsp;
1543 &nbsp;
1544 &nbsp;
1545 &nbsp;
1546 &nbsp;
1547 &nbsp;
1548 &nbsp;
1549 &nbsp;
1550 &nbsp;
1551 &nbsp;
1552 &nbsp;
1553 &nbsp;
1554 &nbsp;
1555 &nbsp;
1556 &nbsp;
1557 &nbsp;
1558 &nbsp;
1559 &nbsp;
1560 &nbsp;
1561 &nbsp;
1562 &nbsp;
1563 &nbsp;
1564 &nbsp;
1565 &nbsp;
1566 &nbsp;
1567 &nbsp;
1568 &nbsp;
1569 &nbsp;
1570 &nbsp;
1571 &nbsp;
1572 &nbsp;
1573 &nbsp;
1574 &nbsp;
1575 &nbsp;
1576 &nbsp;
1577 &nbsp;
1578 &nbsp;
1579 &nbsp;
1580 &nbsp;
1581 &nbsp;
1582 &nbsp;
1583 &nbsp;
1584 &nbsp;
1585 &nbsp;
1586 &nbsp;
1587 &nbsp;
1588 &nbsp;
1589 &nbsp;
1590 &nbsp;
1591 &nbsp;
1592 &nbsp;
1593 &nbsp;
1594 &nbsp;
1595 &nbsp;
1596 &nbsp;
1597 &nbsp;
1598 &nbsp;
1599 &nbsp;
1600 &nbsp;
1601 &nbsp;
1602 &nbsp;
1603 &nbsp;
1604 &nbsp;
1605 &nbsp;
1606 &nbsp;
1607 &nbsp;
1608 &nbsp;
1609 &nbsp;
1610 &nbsp;
1611 &nbsp;
1612 &nbsp;
1613 &nbsp;
1614 &nbsp;
1615 &nbsp;
1616 &nbsp;
1617 &nbsp;
1618 &nbsp;
1619 &nbsp;
1620 &nbsp;
1621 &nbsp;
1622 &nbsp;
1623 &nbsp;
1624 &nbsp;
1625 &nbsp;
1626 &nbsp;
1627 &nbsp;
1628 &nbsp;
1629 &nbsp;
1630 &nbsp;
1631 &nbsp;
1632 &nbsp;
1633 &nbsp;
1634 &nbsp;
1635 &nbsp;
1636 &nbsp;
1637 &nbsp;
1638 &nbsp;
1639 &nbsp;
1640 &nbsp;
1641 &nbsp;
1642 &nbsp;
1643 &nbsp;
1644 &nbsp;
1645 &nbsp;
1646 &nbsp;
1647 &nbsp;
1648 &nbsp;
1649 &nbsp;
1650 &nbsp;
1651 &nbsp;
1652 &nbsp;
1653 &nbsp;
1654 &nbsp;
1655 &nbsp;
1656 &nbsp;
1657 &nbsp;
1658 &nbsp;
1659 &nbsp;
1660 &nbsp;
1661 &nbsp;
1662 &nbsp;
1663 &nbsp;
1664 &nbsp;
1665 &nbsp;
1666 &nbsp;
1667 &nbsp;
1668 &nbsp;
1669 &nbsp;
1670 &nbsp;
1671 &nbsp;
1672 &nbsp;
1673 &nbsp;
1674 &nbsp;
1675 &nbsp;
1676 &nbsp;
1677 &nbsp;
1678 &nbsp;
1679 &nbsp;
1680 &nbsp;
1681 &nbsp;
1682 &nbsp;
1683 &nbsp;
1684 &nbsp;
1685 &nbsp;
1686 &nbsp;
1687 &nbsp;
1688 &nbsp;
1689 &nbsp;
1690 &nbsp;
1691 &nbsp;
1692 &nbsp;
1693 &nbsp;
1694 &nbsp;
1695 &nbsp;
1696 &nbsp;
1697 &nbsp;
1698 &nbsp;
1699 &nbsp;
1700 &nbsp;
1701 &nbsp;
1702 &nbsp;
1703 &nbsp;
1704 &nbsp;
1705 &nbsp;
1706 &nbsp;
1707 &nbsp;
1708 &nbsp;
1709 &nbsp;
1710 &nbsp;
1711 &nbsp;
1712 &nbsp;
1713 &nbsp;
1714 &nbsp;
1715 &nbsp;
1716 &nbsp;
1717 &nbsp;
1718 &nbsp;
1719 &nbsp;
1720 &nbsp;
1721 &nbsp;
1722 &nbsp;
1723 &nbsp;
1724 &nbsp;
1725 &nbsp;
1726 &nbsp;
1727 &nbsp;
1728 &nbsp;
1729 &nbsp;
1730 &nbsp;
1731 &nbsp;
1732 &nbsp;
1733 &nbsp;
1734 &nbsp;
1735 &nbsp;
1736 &nbsp;
1737 &nbsp;
1738 &nbsp;
1739 &nbsp;
1740 &nbsp;
1741 &nbsp;
1742 &nbsp;
1743 &nbsp;
1744 &nbsp;
1745 &nbsp;
1746 &nbsp;
1747 &nbsp;
1748 &nbsp;
1749 &nbsp;
1750 &nbsp;
1751 &nbsp;
1752 &nbsp;
1753 &nbsp;
1754 &nbsp;
1755 &nbsp;
1756 &nbsp;
1757 &nbsp;
1758 &nbsp;
1759 &nbsp;
1760 &nbsp;
1761 &nbsp;
1762 &nbsp;
1763 &nbsp;
1764 &nbsp;
1765 &nbsp;
1766 &nbsp;
1767 &nbsp;
1768 &nbsp;
1769 &nbsp;
1770 &nbsp;
1771 &nbsp;
1772 &nbsp;
1773 &nbsp;
1774 &nbsp;
1775 &nbsp;
1776 &nbsp;
1777 &nbsp;
1778 &nbsp;
1779 &nbsp;
1780 &nbsp;
1781 &nbsp;
1782 &nbsp;
1783 &nbsp;
1784 &nbsp;
1785 &nbsp;
1786 &nbsp;
1787 &nbsp;
1788 &nbsp;
1789 &nbsp;
1790 &nbsp;
1791 &nbsp;
1792 &nbsp;
1793 &nbsp;
1794 &nbsp;
1795 &nbsp;
1796 &nbsp;
1797 &nbsp;
1798 &nbsp;
1799 &nbsp;
1800 &nbsp;
1801 &nbsp;
1802 &nbsp;
1803 &nbsp;
1804 &nbsp;
1805 &nbsp;
1806 &nbsp;
1807 &nbsp;
1808 &nbsp;
1809 &nbsp;
1810 &nbsp;
1811 &nbsp;
1812 &nbsp;
1813 &nbsp;
1814 &nbsp;
1815 &nbsp;
1816 &nbsp;
1817 &nbsp;
1818 &nbsp;
1819 &nbsp;
1820 &nbsp;
1821 &nbsp;
1822 &nbsp;
1823 &nbsp;
1824 &nbsp;
1825 &nbsp;
1826 &nbsp;
1827 &nbsp;
1828 &nbsp;
1829 &nbsp;
1830 &nbsp;
1831 &nbsp;
1832 &nbsp;
1833 &nbsp;
1834 &nbsp;
1835 &nbsp;
1836 &nbsp;
1837 &nbsp;
1838 &nbsp;
1839 &nbsp;
1840 &nbsp;
1841 &nbsp;
1842 &nbsp;
1843 &nbsp;
1844 &nbsp;
1845 &nbsp;
1846 &nbsp;
1847 &nbsp;
1848 &nbsp;
1849 &nbsp;
1850 &nbsp;
1851 &nbsp;
1852 &nbsp;
1853 &nbsp;
1854 &nbsp;
1855 &nbsp;
1856 &nbsp;
1857 &nbsp;
1858 &nbsp;
1859 &nbsp;
1860 &nbsp;
1861 &nbsp;
1862 &nbsp;
1863 &nbsp;
1864 &nbsp;
1865 &nbsp;
1866 &nbsp;
1867 &nbsp;
1868 &nbsp;
1869 &nbsp;
1870 &nbsp;
1871 &nbsp;
1872 &nbsp;
1873 &nbsp;
1874 &nbsp;
1875 &nbsp;
1876 &nbsp;
1877 &nbsp;
1878 &nbsp;
1879 &nbsp;
1880 &nbsp;
1881 &nbsp;
1882 &nbsp;
1883 &nbsp;
1884 &nbsp;
1885 &nbsp;
1886 &nbsp;
1887 &nbsp;
1888 &nbsp;
1889 &nbsp;
1890 &nbsp;
1891 &nbsp;
1892 &nbsp;
1893 &nbsp;
1894 &nbsp;
1895 &nbsp;
1896 &nbsp;
1897 &nbsp;
1898 &nbsp;
1899 &nbsp;
1900 &nbsp;
1901 &nbsp;
1902 &nbsp;
1903 &nbsp;
1904 &nbsp;
1905 &nbsp;
1906 &nbsp;
1907 &nbsp;
1908 &nbsp;
1909 &nbsp;
1910 &nbsp;
1911 &nbsp;
1912 &nbsp;
1913 &nbsp;
1914 &nbsp;
1915 &nbsp;
1916 &nbsp;
1917 &nbsp;
1918 &nbsp;
1919 &nbsp;
1920 &nbsp;
1921 &nbsp;
1922 &nbsp;
1923 &nbsp;
1924 &nbsp;
1925 &nbsp;
1926 &nbsp;
1927 &nbsp;
1928 &nbsp;
1929 &nbsp;
1930 &nbsp;
1931 &nbsp;
1932 &nbsp;
1933 &nbsp;
1934 &nbsp;
1935 &nbsp;
1936 &nbsp;
1937 &nbsp;
1938 &nbsp;
1939 &nbsp;
1940 &nbsp;
1941 &nbsp;
1942 &nbsp;
1943 &nbsp;
1944 &nbsp;
1945 &nbsp;
1946 &nbsp;
1947 &nbsp;
1948 &nbsp;
1949 &nbsp;
1950 &nbsp;
1951 &nbsp;
1952 &nbsp;
1953 &nbsp;
1954 &nbsp;
1955 &nbsp;
1956 &nbsp;
1957 &nbsp;
1958 &nbsp;
1959 &nbsp;
1960 &nbsp;
1961 &nbsp;
1962 &nbsp;
1963 &nbsp;
1964 &nbsp;
1965 &nbsp;
1966 &nbsp;
1967 &nbsp;
1968 &nbsp;
1969 &nbsp;
1970 &nbsp;
1971 &nbsp;
1972 &nbsp;
1973 &nbsp;
1974 &nbsp;
1975 &nbsp;
1976 &nbsp;
1977 &nbsp;
1978 &nbsp;
1979 &nbsp;
1980 &nbsp;
1981 &nbsp;
1982 &nbsp;
1983 &nbsp;
1984 &nbsp;
1985 &nbsp;
1986 &nbsp;
1987 &nbsp;
1988 &nbsp;
1989 &nbsp;
1990 &nbsp;
1991 &nbsp;
1992 &nbsp;
1993 &nbsp;
1994 &nbsp;
1995 &nbsp;
1996 &nbsp;
1997 &nbsp;
1998 &nbsp;
1999 &nbsp;
2000 &nbsp;
2001 &nbsp;
2002 &nbsp;
2003 &nbsp;
2004 &nbsp;
2005 &nbsp;
2006 &nbsp;
2007 &nbsp;
2008 &nbsp;
2009 &nbsp;
2010 &nbsp;
2011 &nbsp;
2012 &nbsp;
2013 &nbsp;
2014 &nbsp;
2015 &nbsp;
2016 &nbsp;
2017 &nbsp;
2018 &nbsp;
2019 &nbsp;
2020 &nbsp;
2021 &nbsp;
2022 &nbsp;
2023 &nbsp;
2024 &nbsp;
2025 &nbsp;
2026 &nbsp;
2027 &nbsp;
2028 &nbsp;
2029 &nbsp;
2030 &nbsp;
2031 &nbsp;
2032 &nbsp;
2033 &nbsp;
2034 &nbsp;
2035 &nbsp;
2036 &nbsp;
2037 &nbsp;
2038 &nbsp;
2039 &nbsp;
2040 &nbsp;
2041 &nbsp;
2042 &nbsp;
2043 &nbsp;
2044 &nbsp;
2045 &nbsp;
2046 &nbsp;
2047 &nbsp;
2048 &nbsp;
2049 &nbsp;
2050 &nbsp;
2051 &nbsp;
2052 &nbsp;
2053 &nbsp;
2054 &nbsp;
2055 &nbsp;
2056 &nbsp;
2057 &nbsp;
2058 &nbsp;
2059 &nbsp;
2060 &nbsp;
2061 &nbsp;
2062 &nbsp;
2063 &nbsp;
2064 &nbsp;
2065 &nbsp;
2066 &nbsp;
2067 &nbsp;
2068 &nbsp;
2069 &nbsp;
2070 &nbsp;
2071 &nbsp;
2072 &nbsp;
2073 &nbsp;
2074 &nbsp;
2075 &nbsp;
2076 &nbsp;
2077 &nbsp;
2078 &nbsp;
2079 &nbsp;
2080 &nbsp;
2081 &nbsp;
2082 &nbsp;
2083 &nbsp;
2084 &nbsp;
2085 &nbsp;
2086 &nbsp;
2087 &nbsp;
2088 &nbsp;
2089 &nbsp;
2090 &nbsp;
2091 &nbsp;
2092 &nbsp;
2093 &nbsp;
2094 &nbsp;
2095 &nbsp;
2096 &nbsp;
2097 &nbsp;
2098 &nbsp;
2099 &nbsp;
2100 &nbsp;
2101 &nbsp;
2102 &nbsp;
2103 &nbsp;
2104 &nbsp;
2105 &nbsp;
2106 &nbsp;
2107 &nbsp;
2108 &nbsp;
2109 &nbsp;
2110 &nbsp;
2111 &nbsp;
2112 &nbsp;
2113 &nbsp;
2114 &nbsp;
2115 &nbsp;
2116 &nbsp;
2117 &nbsp;
2118 &nbsp;
2119 &nbsp;
2120 &nbsp;
2121 &nbsp;
2122 &nbsp;
2123 &nbsp;
2124 &nbsp;
2125 &nbsp;
2126 &nbsp;
2127 &nbsp;
2128 &nbsp;
2129 &nbsp;
2130 &nbsp;
2131 &nbsp;
2132 &nbsp;
2133 &nbsp;
2134 &nbsp;
2135 &nbsp;
2136 &nbsp;
2137 &nbsp;
2138 &nbsp;
2139 &nbsp;
2140 &nbsp;
2141 &nbsp;
2142 &nbsp;
2143 &nbsp;
2144 &nbsp;
2145 &nbsp;
2146 &nbsp;
2147 &nbsp;
2148 &nbsp;
2149 &nbsp;
2150 &nbsp;
2151 &nbsp;
2152 &nbsp;
2153 &nbsp;
2154 &nbsp;
2155 &nbsp;
2156 &nbsp;
2157 &nbsp;
2158 &nbsp;
2159 &nbsp;
2160 &nbsp;
2161 &nbsp;
2162 &nbsp;
2163 &nbsp;
2164 &nbsp;
2165 &nbsp;
2166 &nbsp;
2167 &nbsp;
2168 &nbsp;
2169 &nbsp;
2170 &nbsp;
2171 &nbsp;
2172 &nbsp;
2173 &nbsp;
2174 &nbsp;
2175 &nbsp;
2176 &nbsp;
2177 &nbsp;
2178 &nbsp;
2179 &nbsp;
2180 &nbsp;
2181 &nbsp;
2182 &nbsp;
2183 &nbsp;
2184 &nbsp;
2185 &nbsp;
2186 &nbsp;
2187 &nbsp;
2188 &nbsp;
2189 &nbsp;
2190 &nbsp;
2191 &nbsp;
2192 &nbsp;
2193 &nbsp;
2194 &nbsp;
2195 &nbsp;
2196 &nbsp;
2197 &nbsp;
2198 &nbsp;
2199 &nbsp;
2200 &nbsp;
2201 &nbsp;
2202 &nbsp;
2203 &nbsp;
2204 &nbsp;
2205 &nbsp;
2206 &nbsp;
2207 &nbsp;
2208 &nbsp;
2209 &nbsp;
2210 &nbsp;
2211 &nbsp;
2212 &nbsp;
2213 &nbsp;
2214 &nbsp;
2215 &nbsp;
2216 &nbsp;
2217 &nbsp;
2218 &nbsp;
2219 &nbsp;
2220 &nbsp;
2221 &nbsp;
2222 &nbsp;
2223 &nbsp;
2224 &nbsp;
2225 &nbsp;
2226 &nbsp;
2227 &nbsp;
2228 &nbsp;
2229 &nbsp;
2230 &nbsp;
2231 &nbsp;
2232 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># imports...
</span><span class="noop"># ...standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import modeltools
</span><span class="hit">from hydpy.cythons import modelutils
</span><span class="noop"># ...model specifc
</span><span class="hit">from hydpy.models.hland.hland_constants import FIELD, FOREST, GLACIER, ILAKE
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_tc_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Adjust the measured air temperature to the altitude of the
</span><span class="noop">    individual zones.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.TCAlt`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ZoneZ`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ZRelT`
</span><span class="noop">
</span><span class="noop">    Required input sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_inputs.T`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.TC`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`TC = T - TCAlt \\cdot (ZoneZ-ZRelT)`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Prepare two zones, the first one lying at the reference
</span><span class="noop">        height and the second one 200 meters above:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(2); zrelt(2.); zonez(2., 4.)
</span><span class="noop">
</span><span class="noop">        Applying the usual temperature lapse rate of 0.6°C/100m does
</span><span class="noop">        not affect the temperature of the first zone but reduces the
</span><span class="noop">        temperature of the second zone by 1.2°C:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; tcalt(.6)
</span><span class="noop">        &gt;&gt;&gt; inputs.t = 5.
</span><span class="noop">        &gt;&gt;&gt; model.calc_tc_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.tc
</span><span class="noop">        tc(5.0, 3.8)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    inp = self.sequences.inputs.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        flu.tc[k] = inp.t-con.tcalt[k]*(con.zonez[k]-con.zrelt)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_tmean_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the areal mean temperature of the subbasin.
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_derived.RelZoneArea`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.TC`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.TMean`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Prepare sized zones, the first one beeing twice as large
</span><span class="noop">        as the second one:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(2)
</span><span class="noop">        &gt;&gt;&gt; derived.relzonearea(2./3., 1./3.)
</span><span class="noop">
</span><span class="noop">        With temperature values of 5°C and 8°C  of the respective zones,
</span><span class="noop">        the mean temperature is 6°C:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.tc = 5., 8.
</span><span class="noop">        &gt;&gt;&gt; model.calc_tmean_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.tmean
</span><span class="noop">        tmean(6.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    flu.tmean = 0.
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        flu.tmean += der.relzonearea[k]*flu.tc[k]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_fracrain_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Determine the temperature dependend fraction of (liquid) rainfall
</span><span class="noop">    and (total) precipitation.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.TT`,
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.TTInt`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.TC`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.FracRain`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`FracRain = \\frac{TC-(TT-\\frac{TTInt}{2})}{TTInt}`
</span><span class="noop">
</span><span class="noop">    Restriction:
</span><span class="noop">      :math:`0 \\leq FracRain \\leq 1`
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        The threshold temperature of seven zones is 0°C and the corresponding
</span><span class="noop">        temperature intervall of mixed precipitation 2°C:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(7)
</span><span class="noop">        &gt;&gt;&gt; tt(0.)
</span><span class="noop">        &gt;&gt;&gt; ttint(2.)
</span><span class="noop">
</span><span class="noop">        The fraction of rainfall is zero below -1°C, is one above 1°C and
</span><span class="noop">        increases linearly in between:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.tc = -10., -1., -.5, 0., .5, 1., 10.
</span><span class="noop">        &gt;&gt;&gt; model.calc_fracrain_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.fracrain
</span><span class="noop">        fracrain(0.0, 0.0, 0.25, 0.5, 0.75, 1.0, 1.0)
</span><span class="noop">
</span><span class="noop">        Note the special case of a zero temperature intervall.  With a
</span><span class="noop">        actual temperature beeing equal to the threshold temperature, the
</span><span class="noop">        rainfall fraction is one:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; ttint(0.)
</span><span class="noop">        &gt;&gt;&gt; model.calc_fracrain_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.fracrain
</span><span class="noop">        fracrain(0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        if flu.tc[k] &gt;= (con.tt[k]+con.ttint[k]/2.):
</span><span class="hit">            flu.fracrain[k] = 1.
</span><span class="hit">        elif flu.tc[k] &lt;= (con.tt[k]-con.ttint[k]/2.):
</span><span class="hit">            flu.fracrain[k] = 0.
</span><span class="noop">        else:
</span><span class="hit">            flu.fracrain[k] = ((flu.tc[k]-(con.tt[k]-con.ttint[k]/2.)) /
</span><span class="noop">                               con.ttint[k])
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_rfc_sfc_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the corrected fractions rainfall/snowfall and total
</span><span class="noop">    precipitation.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.RfCF`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.SfCF`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.RfC`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.SfC`
</span><span class="noop">
</span><span class="noop">    Basic equations:
</span><span class="noop">      :math:`RfC = RfCF \\cdot FracRain` \n
</span><span class="noop">      :math:`SfC = SfCF \\cdot (1 - FracRain)`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Assume five zones with different temperatures and hence
</span><span class="noop">        different fractions of rainfall and total precipitation:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(5)
</span><span class="noop">        &gt;&gt;&gt; fluxes.fracrain = 0., .25, .5, .75, 1.
</span><span class="noop">
</span><span class="noop">        With no rainfall and no snowfall correction (implied by the
</span><span class="noop">        respective factors beeing one), the corrected fraction related
</span><span class="noop">        to rainfall is identical with the original fraction and the
</span><span class="noop">        corrected fraction related to snowfall behaves opposite:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; rfcf(1.)
</span><span class="noop">        &gt;&gt;&gt; sfcf(1.)
</span><span class="noop">        &gt;&gt;&gt; model.calc_rfc_sfc_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.rfc
</span><span class="noop">        rfc(0.0, 0.25, 0.5, 0.75, 1.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.sfc
</span><span class="noop">        sfc(1.0, 0.75, 0.5, 0.25, 0.0)
</span><span class="noop">
</span><span class="noop">        With a negative rainfall correction of 20% and a positive
</span><span class="noop">        snowfall correction of 20 % the corrected fractions are:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; rfcf(0.8)
</span><span class="noop">        &gt;&gt;&gt; sfcf(1.2)
</span><span class="noop">        &gt;&gt;&gt; model.calc_rfc_sfc_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.rfc
</span><span class="noop">        rfc(0.0, 0.2, 0.4, 0.6, 0.8)
</span><span class="noop">        &gt;&gt;&gt; fluxes.sfc
</span><span class="noop">        sfc(1.2, 0.9, 0.6, 0.3, 0.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        flu.rfc[k] = flu.fracrain[k]*con.rfcf[k]
</span><span class="hit">        flu.sfc[k] = (1.-flu.fracrain[k])*con.sfcf[k]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_pc_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Apply the precipitation correction factors and adjust precipitation
</span><span class="noop">    to the altitude of the individual zones.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.PCorr`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.PCAlt`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ZoneZ`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ZRelP`
</span><span class="noop">
</span><span class="noop">    Required input sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_inputs.P`
</span><span class="noop">
</span><span class="noop">    Required flux sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.RfC`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.SfC`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.PC`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Five zones are at an elevation of 200 m.  A precipitation value
</span><span class="noop">        of 5 mm has been measured at a gauge at an elevation of 300 m:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(5)
</span><span class="noop">        &gt;&gt;&gt; zrelp(2.)
</span><span class="noop">        &gt;&gt;&gt; zonez(3.)
</span><span class="noop">        &gt;&gt;&gt; inputs.p = 5.
</span><span class="noop">
</span><span class="noop">        Basic equation:
</span><span class="noop">          :math:`PC = P \\cdot PCorr
</span><span class="noop">          \\cdot (1+PCAlt \\cdot (ZoneZ-ZRelP))
</span><span class="noop">          \\cdot (RfC + SfC)`
</span><span class="noop">
</span><span class="noop">        The first four zones illustrate the individual precipitation
</span><span class="noop">        corrections due to the general precipitation correction factor
</span><span class="noop">        (first zone), the altitude correction (second zone), the rainfall
</span><span class="noop">        related correction factor (third zone), and the snowfall related
</span><span class="noop">        correction factor (fourth zone):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; pcorr(1.3, 1.0, 1.0, 1.0, 1.3)
</span><span class="noop">        &gt;&gt;&gt; pcalt(0.0, 0.1, 0.0, 0.0, 0.1)
</span><span class="noop">        &gt;&gt;&gt; fluxes.rfc = 0.5, 0.5, 0.4, 0.5, 0.4
</span><span class="noop">        &gt;&gt;&gt; fluxes.sfc = 0.5, 0.5, 0.5, 0.7, 0.7
</span><span class="noop">        &gt;&gt;&gt; model.calc_pc_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.pc
</span><span class="noop">        pc(6.5, 5.5, 4.5, 6.0, 7.865)
</span><span class="noop">
</span><span class="noop">        The fifth zone illustrates the interaction between all corrections
</span><span class="noop">        --- note that each correction (except the first one) is based the
</span><span class="noop">        corrected precipitation value determined beforehand.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    inp = self.sequences.inputs.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        flu.pc[k] = inp.p*con.pcorr[k]
</span><span class="hit">        flu.pc[k] *= 1.+con.pcalt[k]*(con.zonez[k]-con.zrelp)
</span><span class="hit">        flu.pc[k] *= flu.rfc[k]+flu.sfc[k]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_ep_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Adjust potential norm evaporation to the actual temperature.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ETF`
</span><span class="noop">
</span><span class="noop">    Required input sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_inputs.EPN`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_inputs.TN`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.TMean`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.EP`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`EP = EPN \\cdot (1 + ETF \\cdot (TMean - TN))`
</span><span class="noop">
</span><span class="noop">    Restriction:
</span><span class="noop">      :math:`0 \leq EP \leq 2 \\cdot EPN`
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Assume four zones with different values of the temperature
</span><span class="noop">        related factor for the adjustment of evaporation (the
</span><span class="noop">        negative value of the first zone is not meaningful, but used
</span><span class="noop">        for illustration purporses):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(4)
</span><span class="noop">        &gt;&gt;&gt; etf(-0.5, 0.0, 0.1, 0.5)
</span><span class="noop">        &gt;&gt;&gt; inputs.tn = 20.
</span><span class="noop">        &gt;&gt;&gt; inputs.epn = 2.
</span><span class="noop">
</span><span class="noop">        With mean temperature equal to norm temperature, actual
</span><span class="noop">        (uncorrected) evaporation is equal to norm evaporation:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.tmean = 20.
</span><span class="noop">        &gt;&gt;&gt; model.calc_ep_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.ep
</span><span class="noop">        ep(2.0, 2.0, 2.0, 2.0)
</span><span class="noop">
</span><span class="noop">        With mean temperature 5°C higher than norm temperature, potential
</span><span class="noop">        evaporation is increased by 1 mm for the third zone, which
</span><span class="noop">        possesses a very common adjustment factor.  For the first zone,
</span><span class="noop">        potential evaporation is 0 mm (which is the smallest value
</span><span class="noop">        allowed), and for the fourth zone it is the double value of the
</span><span class="noop">        norm evaporation (which is the largest value allowed):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.tmean  = 25.
</span><span class="noop">        &gt;&gt;&gt; model.calc_ep_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.ep
</span><span class="noop">        ep(0.0, 2.0, 3.0, 4.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    inp = self.sequences.inputs.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        flu.ep[k] = inp.epn*(1.+con.etf[k]*(flu.tmean-inp.tn))
</span><span class="hit">        flu.ep[k] = min(max(flu.ep[k], 0.), 2.*inp.epn)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_epc_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Apply the evaporation correction factors and adjust evaporation
</span><span class="noop">    to the altitude of the individual zones.
</span><span class="noop">
</span><span class="noop">    Calculate the areal mean of (uncorrected) potential evaporation
</span><span class="noop">    for the subbasin, adjust it to the individual zones in accordance
</span><span class="noop">    with their heights and perform some corrections, among which one
</span><span class="noop">    depends on the actual precipitation.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ECorr`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ECAlt`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ZoneZ`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ZRelE`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.EPF`
</span><span class="noop">
</span><span class="noop">    Required flux sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.EP`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.PC`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.EPC`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`EPC = EP \\cdot ECorr
</span><span class="noop">      \\cdot (1+ECAlt \\cdot (ZoneZ-ZRelE))
</span><span class="noop">      \\cdot exp(-EPF \\cdot PC)`
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Four zones are at an elevation of 200 m.  A (uncorrected)
</span><span class="noop">        potential evaporation value of 2 mm and a (corrected) precipitation
</span><span class="noop">        value of 5 mm have been determined for each zone beforehand:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(4)
</span><span class="noop">        &gt;&gt;&gt; zrele(2.)
</span><span class="noop">        &gt;&gt;&gt; zonez(3.)
</span><span class="noop">        &gt;&gt;&gt; fluxes.ep = 2.
</span><span class="noop">        &gt;&gt;&gt; fluxes.pc = 5.
</span><span class="noop">
</span><span class="noop">        The first three zones  illustrate the individual evaporation
</span><span class="noop">        corrections due to the general evaporation correction factor
</span><span class="noop">        (first zone), the altitude correction (second zone), the
</span><span class="noop">        precipitation related correction (third zone):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; ecorr(1.3, 1.0, 1.0, 1.3)
</span><span class="noop">        &gt;&gt;&gt; ecalt(0.0, 0.1, 0.0, 0.1)
</span><span class="noop">        &gt;&gt;&gt; epf(0.0, 0.0, -numpy.log(.7)/10., -numpy.log(.7)/10.)
</span><span class="noop">        &gt;&gt;&gt; model.calc_epc_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.epc
</span><span class="noop">        epc(2.6, 1.8, 1.4, 1.638)
</span><span class="noop">
</span><span class="noop">        The fourth zone illustrates the interaction between all corrections
</span><span class="noop">        --- note that each correction (except the first one) is based the
</span><span class="noop">        corrected evaporation value determined beforehand.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        flu.epc[k] = (flu.ep[k]*con.ecorr[k] *
</span><span class="noop">                      (1. - con.ecalt[k]*(con.zonez[k]-con.zrele)))
</span><span class="hit">        flu.epc[k] *= modelutils.exp(-con.epf[k]*flu.pc[k])
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_tf_ic_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate throughfall and update the interception storage
</span><span class="noop">    accordingly.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.IcMax`
</span><span class="noop">
</span><span class="noop">    Required flux sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.PC`
</span><span class="noop">
</span><span class="noop">    Calculated fluxes sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.TF`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_states.Ic`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`TF = \\Bigl \\lbrace
</span><span class="noop">      {
</span><span class="noop">      {PC \\ | \\ Ic = IcMax}
</span><span class="noop">      \\atop
</span><span class="noop">      {0 \\ | \\ Ic &lt; IcMax}
</span><span class="noop">      }`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Initialize six zones of different types.  Assume a
</span><span class="noop">        generall maximum interception capacity of 2 mm. All zones receive
</span><span class="noop">        a 0.5 mm input of precipitation:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(6)
</span><span class="noop">        &gt;&gt;&gt; zonetype(GLACIER, ILAKE, FIELD, FOREST, FIELD, FIELD)
</span><span class="noop">        &gt;&gt;&gt; icmax(2.)
</span><span class="noop">        &gt;&gt;&gt; fluxes.pc = .5
</span><span class="noop">        &gt;&gt;&gt; states.ic = 0., 0., 0., 0., 1., 2.
</span><span class="noop">        &gt;&gt;&gt; model.calc_tf_ic_v1()
</span><span class="noop">
</span><span class="noop">        For glaciers (first zone) and internal lakes (second zone) the
</span><span class="noop">        interception routine does not apply.  Hence, all precipitation is
</span><span class="noop">        routed as throughfall. For fields and forests, the interception
</span><span class="noop">        routine is identical (usually, only larger capacities for forests
</span><span class="noop">        are assumed, due to their higher leaf area index).  Hence, the
</span><span class="noop">        results of the third and the second zone are equal.  The last
</span><span class="noop">        three zones demonstrate, that all precipitation is stored until
</span><span class="noop">        the interception capacity is reached; afterwards, all precepitation
</span><span class="noop">        is routed as throughfall.  Initial storage reduces the effective
</span><span class="noop">        capacity of the respective simulation step:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.ic
</span><span class="noop">        ic(0.0, 0.0, 0.5, 0.5, 1.5, 2.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.tf
</span><span class="noop">        tf(0.5, 0.5, 0.0, 0.0, 0.0, 0.5)
</span><span class="noop">
</span><span class="noop">        A zero precipitation example:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.pc = 0.
</span><span class="noop">        &gt;&gt;&gt; states.ic = 0., 0., 0., 0., 1., 2.
</span><span class="noop">        &gt;&gt;&gt; model.calc_tf_ic_v1()
</span><span class="noop">        &gt;&gt;&gt; states.ic
</span><span class="noop">        ic(0.0, 0.0, 0.0, 0.0, 1.0, 2.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.tf
</span><span class="noop">        tf(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">
</span><span class="noop">        A high precipitation example:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.pc = 5.
</span><span class="noop">        &gt;&gt;&gt; states.ic = 0., 0., 0., 0., 1., 2.
</span><span class="noop">        &gt;&gt;&gt; model.calc_tf_ic_v1()
</span><span class="noop">        &gt;&gt;&gt; states.ic
</span><span class="noop">        ic(0.0, 0.0, 2.0, 2.0, 2.0, 2.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.tf
</span><span class="noop">        tf(5.0, 5.0, 3.0, 3.0, 4.0, 5.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        if (con.zonetype[k] == FIELD) or (con.zonetype[k] == FOREST):
</span><span class="hit">            flu.tf[k] = max(flu.pc[k]-(con.icmax[k]-sta.ic[k]), 0.)
</span><span class="hit">            sta.ic[k] += flu.pc[k]-flu.tf[k]
</span><span class="noop">        else:
</span><span class="hit">            flu.tf[k] = flu.pc[k]
</span><span class="hit">            sta.ic[k] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_ei_ic_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate interception evaporation and update the interception
</span><span class="noop">    storage accordingly.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">
</span><span class="noop">    Required flux sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.EPC`
</span><span class="noop">
</span><span class="noop">    Calculated fluxes sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.EI`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_states.Ic`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`EI = \\Bigl \\lbrace
</span><span class="noop">      {
</span><span class="noop">      {EPC \\ | \\ Ic &gt; 0}
</span><span class="noop">      \\atop
</span><span class="noop">      {0 \\ | \\ Ic = 0}
</span><span class="noop">      }`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Initialize six zones of different types.  For all zones
</span><span class="noop">        a (corrected) potential evaporation of 0.5 mm is given:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(6)
</span><span class="noop">        &gt;&gt;&gt; zonetype(GLACIER, ILAKE, FIELD, FOREST, FIELD, FIELD)
</span><span class="noop">        &gt;&gt;&gt; fluxes.epc = .5
</span><span class="noop">        &gt;&gt;&gt; states.ic = 0., 0., 0., 0., 1., 2.
</span><span class="noop">        &gt;&gt;&gt; model.calc_ei_ic_v1()
</span><span class="noop">
</span><span class="noop">        For glaciers (first zone) and internal lakes (second zone) the
</span><span class="noop">        interception routine does not apply.  Hence, no interception
</span><span class="noop">        evaporation can occur.  For fields and forests, the interception
</span><span class="noop">        routine is identical (usually, only larger capacities for forests
</span><span class="noop">        are assumed, due to their higher leaf area index).  Hence, the
</span><span class="noop">        results of the third and the second zone are equal.  The last
</span><span class="noop">        three zones demonstrate, that all interception evaporation is equal
</span><span class="noop">        to potential evaporation until the interception storage is empty;
</span><span class="noop">        afterwards, interception evaporation is zero:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.ic
</span><span class="noop">        ic(0.0, 0.0, 0.0, 0.0, 0.5, 1.5)
</span><span class="noop">        &gt;&gt;&gt; fluxes.ei
</span><span class="noop">        ei(0.0, 0.0, 0.0, 0.0, 0.5, 0.5)
</span><span class="noop">
</span><span class="noop">        A zero evaporation example:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.epc = 0.
</span><span class="noop">        &gt;&gt;&gt; states.ic = 0., 0., 0., 0., 1., 2.
</span><span class="noop">        &gt;&gt;&gt; model.calc_ei_ic_v1()
</span><span class="noop">        &gt;&gt;&gt; states.ic
</span><span class="noop">        ic(0.0, 0.0, 0.0, 0.0, 1.0, 2.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.ei
</span><span class="noop">        ei(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">
</span><span class="noop">        A high evaporation example:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.epc = 5.
</span><span class="noop">        &gt;&gt;&gt; states.ic = 0., 0., 0., 0., 1., 2.
</span><span class="noop">        &gt;&gt;&gt; model.calc_ei_ic_v1()
</span><span class="noop">        &gt;&gt;&gt; states.ic
</span><span class="noop">        ic(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.ei
</span><span class="noop">        ei(0.0, 0.0, 0.0, 0.0, 1.0, 2.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        if (con.zonetype[k] == FIELD) or (con.zonetype[k] == FOREST):
</span><span class="hit">            flu.ei[k] = min(flu.epc[k], sta.ic[k])
</span><span class="hit">            sta.ic[k] -= flu.ei[k]
</span><span class="noop">        else:
</span><span class="hit">            flu.ei[k] = 0.
</span><span class="hit">            sta.ic[k] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_sp_wc_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Add throughfall to the snow layer.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">
</span><span class="noop">    Required flux sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.TF`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.RfC`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.SfC`
</span><span class="noop">
</span><span class="noop">    Updated state sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_states.WC`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_states.SP`
</span><span class="noop">
</span><span class="noop">    Basic equations:
</span><span class="noop">      :math:`\\frac{dSP}{dt} = TF \\cdot \\frac{SfC}{SfC+RfC}` \n
</span><span class="noop">      :math:`\\frac{dWC}{dt} = TF \\cdot \\frac{RfC}{SfC+RfC}`
</span><span class="noop">
</span><span class="noop">    Exemples:
</span><span class="noop">        Consider the following setting, in which eight zones of
</span><span class="noop">        different type receive a throughfall of 10mm:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(8)
</span><span class="noop">        &gt;&gt;&gt; zonetype(ILAKE, GLACIER, FIELD, FOREST, FIELD, FIELD, FIELD, FIELD)
</span><span class="noop">        &gt;&gt;&gt; fluxes.tf = 10.
</span><span class="noop">        &gt;&gt;&gt; fluxes.sfc = .5, .5, .5, .5, .2, .8, 1., 4.
</span><span class="noop">        &gt;&gt;&gt; fluxes.rfc = .5, .5, .5, .5, .8, .2, 4., 1.
</span><span class="noop">        &gt;&gt;&gt; states.sp = 0.
</span><span class="noop">        &gt;&gt;&gt; states.wc = 0.
</span><span class="noop">        &gt;&gt;&gt; model.calc_sp_wc_v1()
</span><span class="noop">        &gt;&gt;&gt; states.sp
</span><span class="noop">        sp(0.0, 5.0, 5.0, 5.0, 2.0, 8.0, 2.0, 8.0)
</span><span class="noop">        &gt;&gt;&gt; states.wc
</span><span class="noop">        wc(0.0, 5.0, 5.0, 5.0, 8.0, 2.0, 8.0, 2.0)
</span><span class="noop">
</span><span class="noop">        The snow routine does not apply for internal lakes, which is why
</span><span class="noop">        both  the ice storage and the water storage of the first zone
</span><span class="noop">        remain unchanged.  The snow routine is identical for glaciers,
</span><span class="noop">        fields and forests in the current context, which is why the
</span><span class="noop">        results of the second, third, and fourth zone are equal.  The
</span><span class="noop">        last four zones illustrate that the corrected snowfall fraction
</span><span class="noop">        as well as the corrected rainfall fraction are applied in a
</span><span class="noop">        relative manner, as the total amount of water yield has been
</span><span class="noop">        corrected in the interception module already.
</span><span class="noop">
</span><span class="noop">        When both factors are zero, the neither the water nor the ice
</span><span class="noop">        content of the snow layer changes:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.sfc = 0.
</span><span class="noop">        &gt;&gt;&gt; fluxes.rfc = 0.
</span><span class="noop">        &gt;&gt;&gt; states.sp = 2.
</span><span class="noop">        &gt;&gt;&gt; states.wc = 0.
</span><span class="noop">        &gt;&gt;&gt; model.calc_sp_wc_v1()
</span><span class="noop">        &gt;&gt;&gt; states.sp
</span><span class="noop">        sp(0.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0)
</span><span class="noop">        &gt;&gt;&gt; states.wc
</span><span class="noop">        wc(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        if con.zonetype[k] != ILAKE:
</span><span class="hit">            if (flu.rfc[k]+flu.sfc[k]) &gt; 0.:
</span><span class="hit">                sta.wc[k] += flu.tf[k]*flu.rfc[k]/(flu.rfc[k]+flu.sfc[k])
</span><span class="hit">                sta.sp[k] += flu.tf[k]*flu.sfc[k]/(flu.rfc[k]+flu.sfc[k])
</span><span class="noop">        else:
</span><span class="hit">            sta.wc[k] = 0.
</span><span class="hit">            sta.sp[k] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_melt_sp_wc_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate melting of the ice content within the snow layer and
</span><span class="noop">    update both the snow layers ice and the water content.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.CFMax`
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_derived.TTM`
</span><span class="noop">
</span><span class="noop">    Required flux sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.TC`
</span><span class="noop">
</span><span class="noop">    Calculated fluxes sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.Melt`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_states.SP`
</span><span class="noop">
</span><span class="noop">    Updatet state sequence:
</span><span class="noop">        :class:`~hydpy.models.hland.hland_states.WC`
</span><span class="noop">
</span><span class="noop">    Basic equations:
</span><span class="noop">      :math:`\\frac{dSP}{dt} = - Melt` \n
</span><span class="noop">      :math:`\\frac{dWC}{dt} = + Melt` \n
</span><span class="noop">      :math:`Melt = min(cfmax \\cdot (TC-TTM), SP)` \n
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Six zones are initialized with the same threshold
</span><span class="noop">        temperature and degree day factor, but  with different zone types
</span><span class="noop">        and initial ice contents:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(6)
</span><span class="noop">        &gt;&gt;&gt; zonetype(ILAKE, GLACIER, FIELD, FOREST, FIELD, FIELD)
</span><span class="noop">        &gt;&gt;&gt; cfmax(4.)
</span><span class="noop">        &gt;&gt;&gt; derived.ttm = 2.
</span><span class="noop">        &gt;&gt;&gt; states.sp = 0., 10., 10., 10., 5., 0.
</span><span class="noop">        &gt;&gt;&gt; states.wc = 2.
</span><span class="noop">
</span><span class="noop">        Note that the assumed length of the simulation step is only a
</span><span class="noop">        half day.  Hence the effective value of the degree day factor
</span><span class="noop">        is not 4 but 2:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; cfmax
</span><span class="noop">        cfmax(4.0)
</span><span class="noop">        &gt;&gt;&gt; cfmax.values
</span><span class="noop">        array([ 2.,  2.,  2.,  2.,  2.,  2.])
</span><span class="noop">
</span><span class="noop">        When the actual temperature is equal to the threshold
</span><span class="noop">        temperature for melting and refreezing, no melting  occurs
</span><span class="noop">        and the states remain unchanged:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.tc = 2.
</span><span class="noop">        &gt;&gt;&gt; model.calc_melt_sp_wc_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.melt
</span><span class="noop">        melt(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.sp
</span><span class="noop">        sp(0.0, 10.0, 10.0, 10.0, 5.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.wc
</span><span class="noop">        wc(0.0, 2.0, 2.0, 2.0, 2.0, 2.0)
</span><span class="noop">
</span><span class="noop">        The same holds true for an actual temperature lower than the
</span><span class="noop">        threshold temperature:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.sp = 0., 10., 10., 10., 5., 0.
</span><span class="noop">        &gt;&gt;&gt; states.wc = 2.
</span><span class="noop">        &gt;&gt;&gt; fluxes.tc = -1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_melt_sp_wc_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.melt
</span><span class="noop">        melt(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.sp
</span><span class="noop">        sp(0.0, 10.0, 10.0, 10.0, 5.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.wc
</span><span class="noop">        wc(0.0, 2.0, 2.0, 2.0, 2.0, 2.0)
</span><span class="noop">
</span><span class="noop">        With an actual temperature 3°C above the threshold temperature,
</span><span class="noop">        melting can occur. Actual melting is consistent with potential
</span><span class="noop">        melting, except for the first zone, which is an internal lake,
</span><span class="noop">        and the last two zones, for which potential melting exceeds the
</span><span class="noop">        available frozen water content of the snow layer:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.sp = 0., 10., 10., 10., 5., 0.
</span><span class="noop">        &gt;&gt;&gt; states.wc = 2.
</span><span class="noop">        &gt;&gt;&gt; fluxes.tc = 5.
</span><span class="noop">        &gt;&gt;&gt; model.calc_melt_sp_wc_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.melt
</span><span class="noop">        melt(0.0, 6.0, 6.0, 6.0, 5.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.sp
</span><span class="noop">        sp(0.0, 4.0, 4.0, 4.0, 0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.wc
</span><span class="noop">        wc(0.0, 8.0, 8.0, 8.0, 7.0, 2.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        if con.zonetype[k] != ILAKE:
</span><span class="hit">            if flu.tc[k] &gt; der.ttm[k]:
</span><span class="hit">                flu.melt[k] = min(con.cfmax[k] *
</span><span class="noop">                                  (flu.tc[k]-der.ttm[k]), sta.sp[k])
</span><span class="hit">                sta.sp[k] -= flu.melt[k]
</span><span class="hit">                sta.wc[k] += flu.melt[k]
</span><span class="noop">            else:
</span><span class="hit">                flu.melt[k] = 0.
</span><span class="noop">        else:
</span><span class="hit">            flu.melt[k] = 0.
</span><span class="hit">            sta.wc[k] = 0.
</span><span class="hit">            sta.sp[k] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_refr_sp_wc_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate refreezing of the water content within the snow layer and
</span><span class="noop">    update both the snow layers ice and the water content.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.CFMax`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.CFR`
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_derived.TTM`
</span><span class="noop">
</span><span class="noop">    Required flux sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.TC`
</span><span class="noop">
</span><span class="noop">    Calculated fluxes sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.Refr`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_states.WC`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_states.SP`
</span><span class="noop">
</span><span class="noop">    Basic equations:
</span><span class="noop">      :math:`\\frac{dSP}{dt} =  + Refr` \n
</span><span class="noop">      :math:`\\frac{dWC}{dt} =  - Refr` \n
</span><span class="noop">      :math:`Refr = min(cfr \\cdot cfmax \\cdot (TTM-TC), WC)`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Six zones are initialized with the same threshold
</span><span class="noop">        temperature, degree day factor and refreezing coefficient, but
</span><span class="noop">        with different zone types and initial states:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(6)
</span><span class="noop">        &gt;&gt;&gt; zonetype(ILAKE, GLACIER, FIELD, FOREST, FIELD, FIELD)
</span><span class="noop">        &gt;&gt;&gt; cfmax(4.)
</span><span class="noop">        &gt;&gt;&gt; cfr(.1)
</span><span class="noop">        &gt;&gt;&gt; derived.ttm = 2.
</span><span class="noop">        &gt;&gt;&gt; states.sp = 2.
</span><span class="noop">        &gt;&gt;&gt; states.wc = 0., 1., 1., 1., .5, 0.
</span><span class="noop">
</span><span class="noop">        Note that the assumed length of the simulation step is only
</span><span class="noop">        a half day.  Hence the effective value of the degree day
</span><span class="noop">        factor is not 4 but 2:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; cfmax
</span><span class="noop">        cfmax(4.0)
</span><span class="noop">        &gt;&gt;&gt; cfmax.values
</span><span class="noop">        array([ 2.,  2.,  2.,  2.,  2.,  2.])
</span><span class="noop">
</span><span class="noop">        When the actual temperature is equal to the threshold
</span><span class="noop">        temperature for melting and refreezing, neither no refreezing
</span><span class="noop">        occurs and the states remain unchanged:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.tc = 2.
</span><span class="noop">        &gt;&gt;&gt; model.calc_refr_sp_wc_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.refr
</span><span class="noop">        refr(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.sp
</span><span class="noop">        sp(0.0, 2.0, 2.0, 2.0, 2.0, 2.0)
</span><span class="noop">        &gt;&gt;&gt; states.wc
</span><span class="noop">        wc(0.0, 1.0, 1.0, 1.0, 0.5, 0.0)
</span><span class="noop">
</span><span class="noop">        The same holds true for an actual temperature higher than the
</span><span class="noop">        threshold temperature:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.sp = 2.
</span><span class="noop">        &gt;&gt;&gt; states.wc = 0., 1., 1., 1., .5, 0.
</span><span class="noop">        &gt;&gt;&gt; fluxes.tc = 2.
</span><span class="noop">        &gt;&gt;&gt; model.calc_refr_sp_wc_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.refr
</span><span class="noop">        refr(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.sp
</span><span class="noop">        sp(0.0, 2.0, 2.0, 2.0, 2.0, 2.0)
</span><span class="noop">        &gt;&gt;&gt; states.wc
</span><span class="noop">        wc(0.0, 1.0, 1.0, 1.0, 0.5, 0.0)
</span><span class="noop">
</span><span class="noop">        With an actual temperature 3°C above the threshold temperature,
</span><span class="noop">        only melting can occur. Actual melting is consistent with
</span><span class="noop">        potential melting, except for the first zone, which is an
</span><span class="noop">        internal lake, and the last two zones, for which potential
</span><span class="noop">        melting exceeds the available frozen water content of the
</span><span class="noop">        snow layer:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.sp = 2.
</span><span class="noop">        &gt;&gt;&gt; states.wc = 0., 1., 1., 1., .5, 0.
</span><span class="noop">        &gt;&gt;&gt; fluxes.tc = 5.
</span><span class="noop">        &gt;&gt;&gt; model.calc_refr_sp_wc_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.refr
</span><span class="noop">        refr(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.sp
</span><span class="noop">        sp(0.0, 2.0, 2.0, 2.0, 2.0, 2.0)
</span><span class="noop">        &gt;&gt;&gt; states.wc
</span><span class="noop">        wc(0.0, 1.0, 1.0, 1.0, 0.5, 0.0)
</span><span class="noop">
</span><span class="noop">        With an actual temperature 3°C below the threshold temperature,
</span><span class="noop">        refreezing can occur. Actual refreezing is consistent with
</span><span class="noop">        potential refreezing, except for the first zone, which is an
</span><span class="noop">        internal lake, and the last two zones, for which potential
</span><span class="noop">        refreezing exceeds the available liquid water content of the
</span><span class="noop">        snow layer:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.sp = 2.
</span><span class="noop">        &gt;&gt;&gt; states.wc = 0., 1., 1., 1., .5, 0.
</span><span class="noop">        &gt;&gt;&gt; fluxes.tc = -1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_refr_sp_wc_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.refr
</span><span class="noop">        refr(0.0, 0.6, 0.6, 0.6, 0.5, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.sp
</span><span class="noop">        sp(0.0, 2.6, 2.6, 2.6, 2.5, 2.0)
</span><span class="noop">        &gt;&gt;&gt; states.wc
</span><span class="noop">        wc(0.0, 0.4, 0.4, 0.4, 0.0, 0.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        if con.zonetype[k] != ILAKE:
</span><span class="hit">            if flu.tc[k] &lt; der.ttm[k]:
</span><span class="hit">                flu.refr[k] = min(con.cfr[k]*con.cfmax[k] *
</span><span class="noop">                                  (der.ttm[k]-flu.tc[k]), sta.wc[k])
</span><span class="hit">                sta.sp[k] += flu.refr[k]
</span><span class="hit">                sta.wc[k] -= flu.refr[k]
</span><span class="noop">            else:
</span><span class="hit">                flu.refr[k] = 0.
</span><span class="noop">
</span><span class="noop">        else:
</span><span class="hit">            flu.refr[k] = 0.
</span><span class="hit">            sta.wc[k] = 0.
</span><span class="hit">            sta.sp[k] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_in_wc_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the actual water release from the snow layer due to the
</span><span class="noop">    exceedance of the snow layers capacity for (liquid) water.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.WHC`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_states.SP`
</span><span class="noop">
</span><span class="noop">    Required flux sequence
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.TF`
</span><span class="noop">
</span><span class="noop">    Calculated fluxes sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.In_`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_states.WC`
</span><span class="noop">
</span><span class="noop">    Basic equations:
</span><span class="noop">      :math:`\\frac{dWC}{dt} = -In` \n
</span><span class="noop">      :math:`-In = max(WC - WHC \\cdot SP, 0)`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Initialize six zones of different types and frozen water
</span><span class="noop">        contents of the snow layer and set the relative water holding
</span><span class="noop">        capacity to 20% of the respective frozen water content:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(6)
</span><span class="noop">        &gt;&gt;&gt; zonetype(ILAKE, GLACIER, FIELD, FOREST, FIELD, FIELD)
</span><span class="noop">        &gt;&gt;&gt; whc(.2)
</span><span class="noop">        &gt;&gt;&gt; states.sp = 0., 10., 10., 10., 5., 0.
</span><span class="noop">
</span><span class="noop">        Also set the actual value of stand precipitation to 5 mm/d:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.tf = 5.
</span><span class="noop">
</span><span class="noop">        When there is no (liquid) water content in the snow layer, no water
</span><span class="noop">        can be released:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.wc = 0.
</span><span class="noop">        &gt;&gt;&gt; model.calc_in_wc_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.in_
</span><span class="noop">        in_(5.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.wc
</span><span class="noop">        wc(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">
</span><span class="noop">        When there is a (liquid) water content in the snow layer, the water
</span><span class="noop">        release depends on the frozen water content.  Note the special
</span><span class="noop">        cases of the first zone beeing an internal lake, for which the snow
</span><span class="noop">        routine does not apply, and of the last zone, which has no ice
</span><span class="noop">        content and thus effectively not really a snow layer:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.wc = 5.
</span><span class="noop">        &gt;&gt;&gt; model.calc_in_wc_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.in_
</span><span class="noop">        in_(5.0, 3.0, 3.0, 3.0, 4.0, 5.0)
</span><span class="noop">        &gt;&gt;&gt; states.wc
</span><span class="noop">        wc(0.0, 2.0, 2.0, 2.0, 1.0, 0.0)
</span><span class="noop">
</span><span class="noop">        When the relative water holding capacity is assumed to be zero,
</span><span class="noop">        all liquid water is released:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; whc(0.)
</span><span class="noop">        &gt;&gt;&gt; states.wc = 5.
</span><span class="noop">        &gt;&gt;&gt; model.calc_in_wc_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.in_
</span><span class="noop">        in_(5.0, 5.0, 5.0, 5.0, 5.0, 5.0)
</span><span class="noop">        &gt;&gt;&gt; states.wc
</span><span class="noop">        wc(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">
</span><span class="noop">        Note that for the single lake zone, stand precipitation is
</span><span class="noop">        directly passed to `in_` in all three examples.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        if con.zonetype[k] != ILAKE:
</span><span class="hit">            flu.in_[k] = max(sta.wc[k]-con.whc[k]*sta.sp[k], 0.)
</span><span class="hit">            sta.wc[k] -= flu.in_[k]
</span><span class="noop">        else:
</span><span class="hit">            flu.in_[k] = flu.tf[k]
</span><span class="hit">            sta.wc[k] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_glmelt_in_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate melting from glaciers which are actually not covered by
</span><span class="noop">    a snow layer and add it to the water release of the snow module.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.GMelt`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_states.SP`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.TC`
</span><span class="noop">
</span><span class="noop">    Calculated fluxes sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.GlMelt`
</span><span class="noop">
</span><span class="noop">    Updated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.In_`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">
</span><span class="noop">      :math:`GlMelt = \\Bigl \\lbrace
</span><span class="noop">      {
</span><span class="noop">      {max(GMelt \\cdot (TC-TTM), 0) \\ | \\ SP = 0}
</span><span class="noop">      \\atop
</span><span class="noop">      {0 \\ | \\ SP &gt; 0}
</span><span class="noop">      }`
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Seven zones are prepared, but glacier melting occurs only
</span><span class="noop">        in the fourth one, as the first three zones are no glaciers, the
</span><span class="noop">        fifth zone is covered by a snow layer and the actual temperature
</span><span class="noop">        of the last two zones is not above the threshold temperature:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(7)
</span><span class="noop">        &gt;&gt;&gt; zonetype(FIELD, FOREST, ILAKE, GLACIER, GLACIER, GLACIER, GLACIER)
</span><span class="noop">        &gt;&gt;&gt; gmelt(4.)
</span><span class="noop">        &gt;&gt;&gt; derived.ttm(2.)
</span><span class="noop">        &gt;&gt;&gt; states.sp = 0., 0., 0., 0., .1, 0., 0.
</span><span class="noop">        &gt;&gt;&gt; fluxes.tc = 3., 3., 3., 3., 3., 2., 1.
</span><span class="noop">        &gt;&gt;&gt; fluxes.in_ = 3.
</span><span class="noop">        &gt;&gt;&gt; model.calc_glmelt_in_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.glmelt
</span><span class="noop">        glmelt(0.0, 0.0, 0.0, 2.0, 0.0, 0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.in_
</span><span class="noop">        in_(3.0, 3.0, 3.0, 5.0, 3.0, 3.0, 3.0)
</span><span class="noop">
</span><span class="noop">        Note that the assumed length of the simulation step is only
</span><span class="noop">        a half day. Hence the effective value of the degree day factor
</span><span class="noop">        is not 4 but 2:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; gmelt
</span><span class="noop">        gmelt(4.0)
</span><span class="noop">        &gt;&gt;&gt; gmelt.values
</span><span class="noop">        array([ 2.,  2.,  2.,  2.,  2.,  2.,  2.])
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        if ((con.zonetype[k] == GLACIER) and
</span><span class="noop">                (sta.sp[k] &lt;= 0.) and (flu.tc[k] &gt; der.ttm[k])):
</span><span class="hit">            flu.glmelt[k] = con.gmelt[k]*(flu.tc[k]-der.ttm[k])
</span><span class="hit">            flu.in_[k] += flu.glmelt[k]
</span><span class="noop">        else:
</span><span class="hit">            flu.glmelt[k] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_r_sm_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate effective precipitation and update soil moisture.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.FC`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.Beta`
</span><span class="noop">
</span><span class="noop">    Required fluxes sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.In_`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.R`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_states.SM`
</span><span class="noop">
</span><span class="noop">    Basic equations:
</span><span class="noop">      :math:`\\frac{dSM}{dt} = IN - R` \n
</span><span class="noop">      :math:`R = IN \\cdot \\left(\\frac{SM}{FC}\\right)^{Beta}`
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Initialize six zones of different types.  The field
</span><span class="noop">        capacity of all fields and forests is set to 200mm, the input
</span><span class="noop">        of each zone is 10mm:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(6)
</span><span class="noop">        &gt;&gt;&gt; zonetype(ILAKE, GLACIER, FIELD, FOREST, FIELD, FIELD)
</span><span class="noop">        &gt;&gt;&gt; fc(200.)
</span><span class="noop">        &gt;&gt;&gt; fluxes.in_ = 10.
</span><span class="noop">
</span><span class="noop">        With a common nonlinearity parameter value of 2, a relative
</span><span class="noop">        soil moisture of 50%  (zones three and four) results in a
</span><span class="noop">        discharge coefficient of 25%. For a soil completely dried
</span><span class="noop">        (zone five) or completely saturated (one six) the discharge
</span><span class="noop">        coefficient does not depend on the nonlinearity parameter and
</span><span class="noop">        is 0% and 100% respectively.  Glaciers and internal lakes also
</span><span class="noop">        always route 100% of their input as effective precipitation:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; beta(2.)
</span><span class="noop">        &gt;&gt;&gt; states.sm = 0., 0., 100., 100., 0., 200.
</span><span class="noop">        &gt;&gt;&gt; model.calc_r_sm_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.r
</span><span class="noop">        r(10.0, 10.0, 2.5, 2.5, 0.0, 10.0)
</span><span class="noop">        &gt;&gt;&gt; states.sm
</span><span class="noop">        sm(0.0, 0.0, 107.5, 107.5, 10.0, 200.0)
</span><span class="noop">
</span><span class="noop">        Through decreasing the nonlinearity parameter, the discharge
</span><span class="noop">        coefficient increases.  A parameter value of zero leads to a
</span><span class="noop">        discharge coefficient of 100% for any soil moisture:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; beta(0.)
</span><span class="noop">        &gt;&gt;&gt; states.sm = 0., 0., 100., 100., 0., 200.
</span><span class="noop">        &gt;&gt;&gt; model.calc_r_sm_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.r
</span><span class="noop">        r(10.0, 10.0, 10.0, 10.0, 10.0, 10.0)
</span><span class="noop">        &gt;&gt;&gt; states.sm
</span><span class="noop">        sm(0.0, 0.0, 100.0, 100.0, 0.0, 200.0)
</span><span class="noop">
</span><span class="noop">        With zero field capacity, the discharge coefficient also always
</span><span class="noop">        equates to 100%:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fc(0.)
</span><span class="noop">        &gt;&gt;&gt; beta(2.)
</span><span class="noop">        &gt;&gt;&gt; states.sm = 0.
</span><span class="noop">        &gt;&gt;&gt; model.calc_r_sm_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.r
</span><span class="noop">        r(10.0, 10.0, 10.0, 10.0, 10.0, 10.0)
</span><span class="noop">        &gt;&gt;&gt; states.sm
</span><span class="noop">        sm(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        if (con.zonetype[k] == FIELD) or (con.zonetype[k] == FOREST):
</span><span class="hit">            if con.fc[k] &gt; 0.:
</span><span class="hit">                flu.r[k] = flu.in_[k]*(sta.sm[k]/con.fc[k])**con.beta[k]
</span><span class="hit">                flu.r[k] = max(flu.r[k], sta.sm[k]+flu.in_[k]-con.fc[k])
</span><span class="noop">            else:
</span><span class="hit">                flu.r[k] = flu.in_[k]
</span><span class="hit">            sta.sm[k] += flu.in_[k]-flu.r[k]
</span><span class="noop">        else:
</span><span class="hit">            flu.r[k] = flu.in_[k]
</span><span class="hit">            sta.sm[k] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_cf_sm_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate capillary flow and update soil moisture.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.FC`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.CFlux`
</span><span class="noop">
</span><span class="noop">    Required fluxes sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.R`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_states.UZ`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.CF`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_states.SM`
</span><span class="noop">
</span><span class="noop">    Basic equations:
</span><span class="noop">      :math:`\\frac{dSM}{dt} = CF` \n
</span><span class="noop">      :math:`CF = CFLUX \\cdot (1 - \\frac{SM}{FC})`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Initialize six zones of different types.  The field
</span><span class="noop">        capacity of als fields and forests is set to 200mm, the maximum
</span><span class="noop">        capillary flow rate is 4mm/d:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(6)
</span><span class="noop">        &gt;&gt;&gt; zonetype(ILAKE, GLACIER, FIELD, FOREST, FIELD, FIELD)
</span><span class="noop">        &gt;&gt;&gt; fc(200.)
</span><span class="noop">        &gt;&gt;&gt; cflux(4.)
</span><span class="noop">
</span><span class="noop">        Note that the assumed length of the simulation step is only
</span><span class="noop">        a half day.  Hence the maximum capillary flow per simulation
</span><span class="noop">        step is 2 instead of 4:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; cflux
</span><span class="noop">        cflux(4.0)
</span><span class="noop">        &gt;&gt;&gt; cflux.values
</span><span class="noop">        array([ 2.,  2.,  2.,  2.,  2.,  2.])
</span><span class="noop">
</span><span class="noop">        For fields and forests, the actual capillary return flow depends
</span><span class="noop">        on the relative soil moisture deficite, if either the upper zone
</span><span class="noop">        layer provides enough water...
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.r = 0.
</span><span class="noop">        &gt;&gt;&gt; states.sm = 0., 0., 100., 100., 0., 200.
</span><span class="noop">        &gt;&gt;&gt; states.uz = 20.
</span><span class="noop">        &gt;&gt;&gt; model.calc_cf_sm_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.cf
</span><span class="noop">        cf(0.0, 0.0, 1.0, 1.0, 2.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.sm
</span><span class="noop">        sm(0.0, 0.0, 101.0, 101.0, 2.0, 200.0)
</span><span class="noop">
</span><span class="noop">        ...our enough effective precipitation is generated, which can be
</span><span class="noop">        rerouted directly:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; cflux(4.)
</span><span class="noop">        &gt;&gt;&gt; fluxes.r = 10.
</span><span class="noop">        &gt;&gt;&gt; states.sm = 0., 0., 100., 100., 0., 200.
</span><span class="noop">        &gt;&gt;&gt; states.uz = 0.
</span><span class="noop">        &gt;&gt;&gt; model.calc_cf_sm_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.cf
</span><span class="noop">        cf(0.0, 0.0, 1.0, 1.0, 2.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.sm
</span><span class="noop">        sm(0.0, 0.0, 101.0, 101.0, 2.0, 200.0)
</span><span class="noop">
</span><span class="noop">        If the upper zone layer is empty and no effective precipitation is
</span><span class="noop">        generated, capillary flow is zero:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; cflux(4.)
</span><span class="noop">        &gt;&gt;&gt; fluxes.r = 0.
</span><span class="noop">        &gt;&gt;&gt; states.sm = 0., 0., 100., 100., 0., 200.
</span><span class="noop">        &gt;&gt;&gt; states.uz = 0.
</span><span class="noop">        &gt;&gt;&gt; model.calc_cf_sm_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.cf
</span><span class="noop">        cf(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.sm
</span><span class="noop">        sm(0.0, 0.0, 100.0, 100.0, 0.0, 200.0)
</span><span class="noop">
</span><span class="noop">        Here an example, where both the upper zone layer and effective
</span><span class="noop">        precipitation provide water for the capillary flow, but less then
</span><span class="noop">        the maximum flow rate times the relative soil moisture:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; cflux(4.)
</span><span class="noop">        &gt;&gt;&gt; fluxes.r = 0.1
</span><span class="noop">        &gt;&gt;&gt; states.sm = 0., 0., 100., 100., 0., 200.
</span><span class="noop">        &gt;&gt;&gt; states.uz = 0.2
</span><span class="noop">        &gt;&gt;&gt; model.calc_cf_sm_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.cf
</span><span class="noop">        cf(0.0, 0.0, 0.3, 0.3, 0.3, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.sm
</span><span class="noop">        sm(0.0, 0.0, 100.3, 100.3, 0.3, 200.0)
</span><span class="noop">
</span><span class="noop">        Even unrealistic high maximum capillary flow rates do not result
</span><span class="noop">        in overfilled soils:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; cflux(1000.)
</span><span class="noop">        &gt;&gt;&gt; fluxes.r = 200.
</span><span class="noop">        &gt;&gt;&gt; states.sm = 0., 0., 100., 100., 0., 200.
</span><span class="noop">        &gt;&gt;&gt; states.uz = 200.
</span><span class="noop">        &gt;&gt;&gt; model.calc_cf_sm_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.cf
</span><span class="noop">        cf(0.0, 0.0, 100.0, 100.0, 200.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.sm
</span><span class="noop">        sm(0.0, 0.0, 200.0, 200.0, 200.0, 200.0)
</span><span class="noop">
</span><span class="noop">        For (unrealistic) soils with zero field capacity, capillary flow
</span><span class="noop">        is always zero:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fc(0.)
</span><span class="noop">        &gt;&gt;&gt; states.sm = 0.
</span><span class="noop">        &gt;&gt;&gt; model.calc_cf_sm_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.cf
</span><span class="noop">        cf(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.sm
</span><span class="noop">        sm(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        if (con.zonetype[k] == FIELD) or (con.zonetype[k] == FOREST):
</span><span class="hit">            if con.fc[k] &gt; 0.:
</span><span class="hit">                flu.cf[k] = con.cflux[k]*(1.-sta.sm[k]/con.fc[k])
</span><span class="hit">                flu.cf[k] = min(flu.cf[k], sta.uz+flu.r[k])
</span><span class="hit">                flu.cf[k] = min(flu.cf[k], con.fc[k]-sta.sm[k])
</span><span class="noop">            else:
</span><span class="hit">                flu.cf[k] = 0.
</span><span class="hit">            sta.sm[k] += flu.cf[k]
</span><span class="noop">        else:
</span><span class="hit">            flu.cf[k] = 0.
</span><span class="hit">            sta.sm[k] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_ea_sm_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate soil evaporation and update soil moisture.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.FC`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.LP`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ERed`
</span><span class="noop">
</span><span class="noop">    Required fluxes sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.EPC`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.EI`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_states.SP`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.EA`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_states.SM`
</span><span class="noop">
</span><span class="noop">    Basic equations:
</span><span class="noop">      :math:`\\frac{dSM}{dt} = - EA` \n
</span><span class="noop">      :math:`EA_{temp} = \\biggl \\lbrace
</span><span class="noop">      {
</span><span class="noop">      {EPC \\cdot min\\left(\\frac{SM}{LP \\cdot FC}, 1\\right)
</span><span class="noop">      \\ | \\ SP = 0}
</span><span class="noop">      \\atop
</span><span class="noop">      {0 \\ | \\ SP &gt; 0}
</span><span class="noop">      }` \n
</span><span class="noop">      :math:`EA = EA_{temp} - max(ERED \\cdot (EA_{temp} + EI - EPC), 0)`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Initialize seven zones of different types.  The field capacity
</span><span class="noop">         of all fields and forests is set to 200mm, potential evaporation
</span><span class="noop">         and interception evaporation are 2mm and 1mm respectively:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(7)
</span><span class="noop">        &gt;&gt;&gt; zonetype(ILAKE, GLACIER, FIELD, FOREST, FIELD, FIELD, FIELD)
</span><span class="noop">        &gt;&gt;&gt; fc(200.)
</span><span class="noop">        &gt;&gt;&gt; lp(.0, .0, .5, .5, .0, .8, 1.)
</span><span class="noop">        &gt;&gt;&gt; ered(0.)
</span><span class="noop">        &gt;&gt;&gt; fluxes.epc = 2.
</span><span class="noop">        &gt;&gt;&gt; fluxes.ei = 1.
</span><span class="noop">        &gt;&gt;&gt; states.sp = 0.
</span><span class="noop">
</span><span class="noop">        Only fields and forests include soils; for glaciers and zones (the
</span><span class="noop">        first two zones) no soil evaporation is performed.  For fields and
</span><span class="noop">        forests, the underlying calculations are the same. In the following
</span><span class="noop">        example, the relative soil moisture is 50% in all field and forest
</span><span class="noop">        zones.  Hence, differences in soil evaporation are related to the
</span><span class="noop">        different soil evaporation parameter values only:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.sm = 100.
</span><span class="noop">        &gt;&gt;&gt; model.calc_ea_sm_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.ea
</span><span class="noop">        ea(0.0, 0.0, 2.0, 2.0, 2.0, 1.25, 1.0)
</span><span class="noop">        &gt;&gt;&gt; states.sm
</span><span class="noop">        sm(0.0, 0.0, 98.0, 98.0, 98.0, 98.75, 99.0)
</span><span class="noop">
</span><span class="noop">        In the last example, evaporation values of 2mm have been calculated
</span><span class="noop">        for some zones despite the fact, that these 2mm added to the actual
</span><span class="noop">        interception evaporation of 1mm exceed potential evaporation.  This
</span><span class="noop">        behaviour can be reduced...
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.sm = 100.
</span><span class="noop">        &gt;&gt;&gt; ered(.5)
</span><span class="noop">        &gt;&gt;&gt; model.calc_ea_sm_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.ea
</span><span class="noop">        ea(0.0, 0.0, 1.5, 1.5, 1.5, 1.125, 1.0)
</span><span class="noop">        &gt;&gt;&gt; states.sm
</span><span class="noop">        sm(0.0, 0.0, 98.5, 98.5, 98.5, 98.875, 99.0)
</span><span class="noop">
</span><span class="noop">        ...or be completely excluded:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.sm = 100.
</span><span class="noop">        &gt;&gt;&gt; ered(1.)
</span><span class="noop">        &gt;&gt;&gt; model.calc_ea_sm_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.ea
</span><span class="noop">        ea(0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0)
</span><span class="noop">        &gt;&gt;&gt; states.sm
</span><span class="noop">        sm(0.0, 0.0, 99.0, 99.0, 99.0, 99.0, 99.0)
</span><span class="noop">
</span><span class="noop">        Any occurence of a snow layer suppresses soil evaporation
</span><span class="noop">        completely:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.sp = 0.01
</span><span class="noop">        &gt;&gt;&gt; states.sm = 100.
</span><span class="noop">        &gt;&gt;&gt; model.calc_ea_sm_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.ea
</span><span class="noop">        ea(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.sm
</span><span class="noop">        sm(0.0, 0.0, 100.0, 100.0, 100.0, 100.0, 100.0)
</span><span class="noop">
</span><span class="noop">        For (unrealistic) soils with zero field capacity, soil evaporation
</span><span class="noop">        is always zero:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fc(0.)
</span><span class="noop">        &gt;&gt;&gt; states.sm = 0.
</span><span class="noop">        &gt;&gt;&gt; model.calc_ea_sm_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.ea
</span><span class="noop">        ea(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.sm
</span><span class="noop">        sm(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        if (con.zonetype[k] == FIELD) or (con.zonetype[k] == FOREST):
</span><span class="hit">            if sta.sp[k] &lt;= 0.:
</span><span class="hit">                if (con.lp[k]*con.fc[k]) &gt; 0.:
</span><span class="hit">                    flu.ea[k] = flu.epc[k]*sta.sm[k]/(con.lp[k]*con.fc[k])
</span><span class="hit">                    flu.ea[k] = min(flu.ea[k], flu.epc[k])
</span><span class="noop">                else:
</span><span class="hit">                    flu.ea[k] = flu.epc[k]
</span><span class="hit">                flu.ea[k] -= max(con.ered[k] *
</span><span class="noop">                                 (flu.ea[k]+flu.ei[k]-flu.epc[k]), 0.)
</span><span class="hit">                flu.ea[k] = min(flu.ea[k], sta.sm[k])
</span><span class="noop">            else:
</span><span class="hit">                flu.ea[k] = 0.
</span><span class="hit">            sta.sm[k] -= flu.ea[k]
</span><span class="noop">        else:
</span><span class="hit">            flu.ea[k] = 0.
</span><span class="hit">            sta.sm[k] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_inuz_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Accumulate the total inflow into the upper zone layer.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">
</span><span class="noop">    Required derived parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_derived.RelLandZoneArea`
</span><span class="noop">
</span><span class="noop">    Required fluxes sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.R`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.CF`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.InUZ`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`InUZ = R - CF`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Initialize three zones of different relative `land sizes`
</span><span class="noop">        (area related to the total size of the subbasin except lake areas):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(3)
</span><span class="noop">        &gt;&gt;&gt; zonetype(FIELD, ILAKE, GLACIER)
</span><span class="noop">        &gt;&gt;&gt; derived.rellandzonearea = 2./3., 0., 1./3.
</span><span class="noop">        &gt;&gt;&gt; fluxes.r = 6., 0., 2.
</span><span class="noop">        &gt;&gt;&gt; fluxes.cf = 2., 0., 1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_inuz_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.inuz
</span><span class="noop">        inuz(3.0)
</span><span class="noop">
</span><span class="noop">        Internal lakes do not contribute to the upper zone layer.  Hence
</span><span class="noop">        for a subbasin consisting only of interal lakes a zero input
</span><span class="noop">        value would be calculated:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; zonetype(ILAKE, ILAKE, ILAKE)
</span><span class="noop">        &gt;&gt;&gt; model.calc_inuz_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.inuz
</span><span class="noop">        inuz(0.0)
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    flu.inuz = 0.
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        if con.zonetype[k] != ILAKE:
</span><span class="hit">            flu.inuz += der.rellandzonearea[k]*(flu.r[k]-flu.cf[k])
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_contriarea_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Determine the relative size of the contributing area of the whole
</span><span class="noop">    subbasin.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.RespArea`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.FC`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.Beta`
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">    :class:`~hydpy.models.hland.hland_derived.RelSoilArea`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_states.SM`
</span><span class="noop">
</span><span class="noop">    Calculated fluxes sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.ContriArea`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`ContriArea = \\left( \\frac{SM}{FC} \\right)^{Beta}`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Four zones are initialized, but only the first two zones
</span><span class="noop">        of type field and forest are taken into account in the calculation
</span><span class="noop">        of the relative contributing area of the catchment (even, if also
</span><span class="noop">        glaciers contribute to the inflow of the upper zone layer):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(4)
</span><span class="noop">        &gt;&gt;&gt; zonetype(FIELD, FOREST, GLACIER, ILAKE)
</span><span class="noop">        &gt;&gt;&gt; beta(2.)
</span><span class="noop">        &gt;&gt;&gt; fc(200.)
</span><span class="noop">        &gt;&gt;&gt; resparea(True)
</span><span class="noop">        &gt;&gt;&gt; derived.relsoilarea(.5)
</span><span class="noop">        &gt;&gt;&gt; derived.relsoilzonearea(1./3., 2./3., 0., 0.)
</span><span class="noop">
</span><span class="noop">        With a relative soil moisture of 100% in the whole subbasin, the
</span><span class="noop">        contributing area is also estimated as 100%,...
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.sm = 200.
</span><span class="noop">        &gt;&gt;&gt; model.calc_contriarea_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.contriarea
</span><span class="noop">        contriarea(1.0)
</span><span class="noop">
</span><span class="noop">        ...and relative soil moistures of 0% result in an contributing
</span><span class="noop">        area of 0%:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.sm = 0.
</span><span class="noop">        &gt;&gt;&gt; model.calc_contriarea_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.contriarea
</span><span class="noop">        contriarea(0.0)
</span><span class="noop">
</span><span class="noop">        With the given value 2 of the nonlinearity parameter Beta, soil
</span><span class="noop">        moisture of 50% results in a contributing area estimate of 25%:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.sm = 100.
</span><span class="noop">        &gt;&gt;&gt; model.calc_contriarea_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.contriarea
</span><span class="noop">        contriarea(0.25)
</span><span class="noop">
</span><span class="noop">        Setting the response area option to False,...
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; resparea(False)
</span><span class="noop">        &gt;&gt;&gt; model.calc_contriarea_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.contriarea
</span><span class="noop">        contriarea(1.0)
</span><span class="noop">
</span><span class="noop">        ... setting the soil area (total area of all field and forest
</span><span class="noop">        zones in the subbasin) to zero...,
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; resparea(True)
</span><span class="noop">        &gt;&gt;&gt; derived.relsoilarea(0.)
</span><span class="noop">        &gt;&gt;&gt; model.calc_contriarea_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.contriarea
</span><span class="noop">        contriarea(1.0)
</span><span class="noop">
</span><span class="noop">        ...or setting all field capacities to zero...
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.relsoilarea(.5)
</span><span class="noop">        &gt;&gt;&gt; fc(0.)
</span><span class="noop">        &gt;&gt;&gt; states.sm = 0.
</span><span class="noop">        &gt;&gt;&gt; model.calc_contriarea_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.contriarea
</span><span class="noop">        contriarea(1.0)
</span><span class="noop">
</span><span class="noop">        ...leads to contributing area values of 100%.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    if con.resparea and (der.relsoilarea &gt; 0.):
</span><span class="hit">        flu.contriarea = 0.
</span><span class="hit">        for k in range(con.nmbzones):
</span><span class="hit">            if (con.zonetype[k] == FIELD) or (con.zonetype[k] == FOREST):
</span><span class="hit">                if con.fc[k] &gt; 0.:
</span><span class="hit">                    flu.contriarea += (der.relsoilzonearea[k] *
</span><span class="noop">                                       (sta.sm[k]/con.fc[k])**con.beta[k])
</span><span class="noop">                else:
</span><span class="hit">                    flu.contriarea += der.relsoilzonearea[k]
</span><span class="noop">    else:
</span><span class="hit">        flu.contriarea = 1.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_q0_perc_uz_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Perform the upper zone layer routine which determines percolation
</span><span class="noop">    to the lower zone layer and the fast response of the hland model.
</span><span class="noop">    Note that the system behaviour of this method depends strongly on the
</span><span class="noop">    specifications of the options :class:`RespArea` and :class:`RecStep`.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.RecStep`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.PercMax`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.K`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.Alpha`
</span><span class="noop">
</span><span class="noop">    Required derived parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.DT`
</span><span class="noop">
</span><span class="noop">    Required fluxes sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.InUZ`
</span><span class="noop">
</span><span class="noop">    Used Aide sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_aides.Perc`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_aides.Q0`
</span><span class="noop">
</span><span class="noop">    Calculated fluxes sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.Perc`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.Q0`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_states.UZ`
</span><span class="noop">
</span><span class="noop">    Basic equations:
</span><span class="noop">      :math:`\\frac{dUZ}{dt} = InUZ - Perc - Q0` \n
</span><span class="noop">      :math:`Perc = PercMax \\cdot ContriArea` \n
</span><span class="noop">      :math:`Q0 = \\left( \\frac{UZ}{ContriArea} \\right)^{1+Alpha}`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        The upper zone layer routine is an exception compared to
</span><span class="noop">        the other routines of the HydPy-H-Land model, regarding its
</span><span class="noop">        consideration of numerical accuracy.  To increase the accuracy of
</span><span class="noop">        the numerical integration of the underlying ordinary differential
</span><span class="noop">        equation, each simulation step can be devided into substeps, which
</span><span class="noop">        are all solved with first order accuracy.  In the first example,
</span><span class="noop">        this option is omitted through setting the RecStep parameter to one:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; recstep(2)
</span><span class="noop">        &gt;&gt;&gt; derived.dt = 1./recstep
</span><span class="noop">        &gt;&gt;&gt; percmax(2.)
</span><span class="noop">        &gt;&gt;&gt; alpha(1.)
</span><span class="noop">        &gt;&gt;&gt; k(2.)
</span><span class="noop">        &gt;&gt;&gt; fluxes.contriarea = 1.
</span><span class="noop">        &gt;&gt;&gt; fluxes.inuz = 0.
</span><span class="noop">        &gt;&gt;&gt; states.uz = 1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_q0_perc_uz_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.perc
</span><span class="noop">        perc(1.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.q0
</span><span class="noop">        q0(0.0)
</span><span class="noop">        &gt;&gt;&gt; states.uz
</span><span class="noop">        uz(0.0)
</span><span class="noop">
</span><span class="noop">        Due to the sequential calculation of the upper zone routine, the
</span><span class="noop">        upper zone storage is drained completely through percolation and
</span><span class="noop">        no water is left for fast discharge response.  By dividing the
</span><span class="noop">        simulation step in 100 substeps, the results are quite different:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; recstep(200)
</span><span class="noop">        &gt;&gt;&gt; derived.dt = 1./recstep
</span><span class="noop">        &gt;&gt;&gt; states.uz = 1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_q0_perc_uz_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.perc
</span><span class="noop">        perc(0.786934)
</span><span class="noop">        &gt;&gt;&gt; fluxes.q0
</span><span class="noop">        q0(0.213066)
</span><span class="noop">        &gt;&gt;&gt; states.uz
</span><span class="noop">        uz(0.0)
</span><span class="noop">
</span><span class="noop">        Note that the assumed length of the simulation step is only a
</span><span class="noop">        half day. Hence the effective values of the maximum percolation
</span><span class="noop">        rate and the storage coefficient is not 2 but 1:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; percmax
</span><span class="noop">        percmax(2.0)
</span><span class="noop">        &gt;&gt;&gt; k
</span><span class="noop">        k(2.0)
</span><span class="noop">        &gt;&gt;&gt; percmax.value
</span><span class="noop">        1.0
</span><span class="noop">        &gt;&gt;&gt; k.value
</span><span class="noop">        1.0
</span><span class="noop">
</span><span class="noop">        By decreasing the contributing area one decreases percolation but
</span><span class="noop">        increases fast discharge response:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.contriarea = .5
</span><span class="noop">        &gt;&gt;&gt; states.uz = 1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_q0_perc_uz_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.perc
</span><span class="noop">        perc(0.434108)
</span><span class="noop">        &gt;&gt;&gt; fluxes.q0
</span><span class="noop">        q0(0.565892)
</span><span class="noop">        &gt;&gt;&gt; states.uz
</span><span class="noop">        uz(0.0)
</span><span class="noop">
</span><span class="noop">        Resetting RecStep leads to more transparent results.  Note that, due
</span><span class="noop">        to the large value of the storage coefficient and the low accuracy
</span><span class="noop">        of the numerical approximation, direct discharge drains the rest of
</span><span class="noop">        the upper zone storage:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; recstep(2)
</span><span class="noop">        &gt;&gt;&gt; derived.dt = 1./recstep
</span><span class="noop">        &gt;&gt;&gt; states.uz = 1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_q0_perc_uz_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.perc
</span><span class="noop">        perc(0.5)
</span><span class="noop">        &gt;&gt;&gt; fluxes.q0
</span><span class="noop">        q0(0.5)
</span><span class="noop">        &gt;&gt;&gt; states.uz
</span><span class="noop">        uz(0.0)
</span><span class="noop">
</span><span class="noop">        Applying a more reasonable storage coefficient results in:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; k(.5)
</span><span class="noop">        &gt;&gt;&gt; states.uz = 1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_q0_perc_uz_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.perc
</span><span class="noop">        perc(0.5)
</span><span class="noop">        &gt;&gt;&gt; fluxes.q0
</span><span class="noop">        q0(0.25)
</span><span class="noop">        &gt;&gt;&gt; states.uz
</span><span class="noop">        uz(0.25)
</span><span class="noop">
</span><span class="noop">        Adding an input of 0.3 mm results the same percolation value (which,
</span><span class="noop">        in the given example, is determined by the maximum percolation rate
</span><span class="noop">        only), but in an increases value of the direct response (which
</span><span class="noop">        always depends on the actual upper zone storage directly):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.inuz = .3
</span><span class="noop">        &gt;&gt;&gt; states.uz = 1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_q0_perc_uz_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.perc
</span><span class="noop">        perc(0.5)
</span><span class="noop">        &gt;&gt;&gt; fluxes.q0
</span><span class="noop">        q0(0.64)
</span><span class="noop">        &gt;&gt;&gt; states.uz
</span><span class="noop">        uz(0.16)
</span><span class="noop">
</span><span class="noop">        Due to the same reasons, another increase in numerical accuracy has
</span><span class="noop">        no impact on percolation but decreases the direct response in the
</span><span class="noop">        given example:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; recstep(200)
</span><span class="noop">        &gt;&gt;&gt; derived.dt = 1./recstep
</span><span class="noop">        &gt;&gt;&gt; states.uz = 1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_q0_perc_uz_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.perc
</span><span class="noop">        perc(0.5)
</span><span class="noop">        &gt;&gt;&gt; fluxes.q0
</span><span class="noop">        q0(0.421708)
</span><span class="noop">        &gt;&gt;&gt; states.uz
</span><span class="noop">        uz(0.378292)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    aid = self.sequences.aides.fastaccess
</span><span class="hit">    flu.perc = 0.
</span><span class="hit">    flu.q0 = 0.
</span><span class="hit">    for jdx in range(con.recstep):
</span><span class="noop">        # First state update related to the upper zone input.
</span><span class="hit">        sta.uz += der.dt*flu.inuz
</span><span class="noop">        # Second state update related to percolation.
</span><span class="hit">        aid.perc = min(der.dt*con.percmax*flu.contriarea, sta.uz)
</span><span class="hit">        sta.uz -= aid.perc
</span><span class="hit">        flu.perc += aid.perc
</span><span class="noop">        # Third state update related to fast runoff response.
</span><span class="hit">        if sta.uz &gt; 0.:
</span><span class="hit">            if flu.contriarea &gt; 0.:
</span><span class="hit">                aid.q0 = (der.dt*con.k *
</span><span class="noop">                          (sta.uz/flu.contriarea)**(1.+con.alpha))
</span><span class="hit">                aid.q0 = min(aid.q0, sta.uz)
</span><span class="noop">            else:
</span><span class="miss">                aid.q0 = sta.uz
</span><span class="hit">            sta.uz -= aid.q0
</span><span class="hit">            flu.q0 += aid.q0
</span><span class="noop">        else:
</span><span class="hit">            aid.q0 = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_lz_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Update the lower zone layer in accordance with percolation from
</span><span class="noop">    upper groundwater to lower groundwater and/or in accordance with
</span><span class="noop">    lake precipitation.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">
</span><span class="noop">    Required derived parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.RelLandArea`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.RelZoneArea`
</span><span class="noop">
</span><span class="noop">    Required fluxes sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.PC`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.Perc`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_states.LZ`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`\\frac{dLZ}{dt} = Perc + Pc`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        At first, a subbasin with two field zones is assumed (the zones
</span><span class="noop">        could be of type forest or glacier as well).  In such zones,
</span><span class="noop">        precipitation does not fall directly into the lower zone layer,
</span><span class="noop">        hence the given precipitation of 2mm has no impact.  Only
</span><span class="noop">        the actual percolation from the upper zone layer (underneath
</span><span class="noop">        both field zones) is added to the lower zone storage:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(2)
</span><span class="noop">        &gt;&gt;&gt; zonetype(FIELD, FIELD)
</span><span class="noop">        &gt;&gt;&gt; derived.rellandarea = 1.
</span><span class="noop">        &gt;&gt;&gt; derived.relzonearea = 2./3., 1./3.
</span><span class="noop">        &gt;&gt;&gt; fluxes.perc = 2.
</span><span class="noop">        &gt;&gt;&gt; fluxes.pc = 5.
</span><span class="noop">        &gt;&gt;&gt; states.lz = 10.
</span><span class="noop">        &gt;&gt;&gt; model.calc_lz_v1()
</span><span class="noop">        &gt;&gt;&gt; states.lz
</span><span class="noop">        lz(12.0)
</span><span class="noop">
</span><span class="noop">        If the second zone is an internal lake, its precipitation falls
</span><span class="noop">        on the lower zone layer directly.  Note that only 5/3mm
</span><span class="noop">        precipitation are added, due to the relative size of the
</span><span class="noop">        internal lake within the subbasin. Percolation from the upper
</span><span class="noop">        zone layer increases the lower zone storage only by two thirds
</span><span class="noop">        of its original value, due to the larger spatial extend of
</span><span class="noop">        the lower zone layer:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; zonetype(FIELD, ILAKE)
</span><span class="noop">        &gt;&gt;&gt; derived.rellandarea = 2./3.
</span><span class="noop">        &gt;&gt;&gt; derived.relzonearea = 2./3., 1./3.
</span><span class="noop">        &gt;&gt;&gt; states.lz = 10.
</span><span class="noop">        &gt;&gt;&gt; model.calc_lz_v1()
</span><span class="noop">        &gt;&gt;&gt; states.lz
</span><span class="noop">        lz(13.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    sta.lz += der.rellandarea*flu.perc
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        if con.zonetype[k] == ILAKE:
</span><span class="hit">            sta.lz += der.relzonearea[k]*flu.pc[k]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_el_lz_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate lake evaporation.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">        :class:`~hydpy.models.hland.hland_control.NmbZones`
</span><span class="noop">        :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">        :class:`~hydpy.models.hland.hland_control.TTIce`
</span><span class="noop">
</span><span class="noop">    Required derived parameters:
</span><span class="noop">        :class:`~hydpy.models.hland.hland_control.RelZoneArea`
</span><span class="noop">
</span><span class="noop">    Required fluxes sequences:
</span><span class="noop">        :class:`~hydpy.models.hland.hland_fluxes.TC`
</span><span class="noop">        :class:`~hydpy.models.hland.hland_fluxes.EPC`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">        :class:`~hydpy.models.hland.hland_states.LZ`
</span><span class="noop">
</span><span class="noop">    Basic equations:
</span><span class="noop">        :math:`\\frac{dLZ}{dt} = -EL` \n
</span><span class="noop">        :math:`EL = \\Bigl \\lbrace
</span><span class="noop">        {
</span><span class="noop">        {EPC \\ | \\ TC &gt; TTIce}
</span><span class="noop">        \\atop
</span><span class="noop">        {0 \\ | \\ TC \\leq TTIce}
</span><span class="noop">        }`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Six zones of the same size are initialized.  The first three
</span><span class="noop">        zones are no internal lakes, they can not exhibit any lake
</span><span class="noop">        evaporation.  Of the last three zones, which are internal lakes,
</span><span class="noop">        only the last one evaporates water.  For zones five and six,
</span><span class="noop">        evaporation is suppressed due to an assumed ice layer, whenever
</span><span class="noop">        the associated theshold temperature is not exceeded:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(6)
</span><span class="noop">        &gt;&gt;&gt; zonetype(FIELD, FOREST, GLACIER, ILAKE, ILAKE, ILAKE)
</span><span class="noop">        &gt;&gt;&gt; ttice(-1.)
</span><span class="noop">        &gt;&gt;&gt; derived.relzonearea = 1./6.
</span><span class="noop">        &gt;&gt;&gt; fluxes.epc = .6
</span><span class="noop">        &gt;&gt;&gt; fluxes.tc = 0., 0., 0., 0., -1., -2.
</span><span class="noop">        &gt;&gt;&gt; states.lz = 10.
</span><span class="noop">        &gt;&gt;&gt; model.calc_el_lz_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.el
</span><span class="noop">        el(0.0, 0.0, 0.0, 0.6, 0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.lz
</span><span class="noop">        lz(9.9)
</span><span class="noop">
</span><span class="noop">        Note that internal lakes always contain water.  Hence, the
</span><span class="noop">        HydPy-H-Land model allows for negative values of the lower
</span><span class="noop">        zone storage:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.lz = .05
</span><span class="noop">        &gt;&gt;&gt; model.calc_el_lz_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.el
</span><span class="noop">        el(0.0, 0.0, 0.0, 0.6, 0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; states.lz
</span><span class="noop">        lz(-0.05)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    for k in range(con.nmbzones):
</span><span class="hit">        if (con.zonetype[k] == ILAKE) and (flu.tc[k] &gt; con.ttice[k]):
</span><span class="hit">            flu.el[k] = flu.epc[k]
</span><span class="hit">            sta.lz -= der.relzonearea[k]*flu.el[k]
</span><span class="noop">        else:
</span><span class="hit">            flu.el[k] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_q1_lz_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the slow response of the lower zone layer.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">        :class:`~hydpy.models.hland.hland_control.K4`
</span><span class="noop">        :class:`~hydpy.models.hland.hland_control.Gamma`
</span><span class="noop">
</span><span class="noop">    Calculated fluxes sequence:
</span><span class="noop">        :class:`~hydpy.models.hland.hland_fluxes.Q1`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">        :class:`~hydpy.models.hland.hland_states.LZ`
</span><span class="noop">
</span><span class="noop">    Basic equations:
</span><span class="noop">        :math:`\\frac{dLZ}{dt} = -Q1` \n
</span><span class="noop">        :math:`Q1 = \\Bigl \\lbrace
</span><span class="noop">        {
</span><span class="noop">        {K4 \\cdot LZ^{1+Gamma} \\ | \\ LZ &gt; 0}
</span><span class="noop">        \\atop
</span><span class="noop">        {0 \\ | \\ LZ\\leq 0}
</span><span class="noop">        }`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        As long as the lower zone storage is negative...
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; k4(.2)
</span><span class="noop">        &gt;&gt;&gt; gamma(0.)
</span><span class="noop">        &gt;&gt;&gt; states.lz = -2.
</span><span class="noop">        &gt;&gt;&gt; model.calc_q1_lz_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.q1
</span><span class="noop">        q1(0.0)
</span><span class="noop">        &gt;&gt;&gt; states.lz
</span><span class="noop">        lz(-2.0)
</span><span class="noop">
</span><span class="noop">        ...or zero, no slow discharge response occurs:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.lz = 0.
</span><span class="noop">        &gt;&gt;&gt; model.calc_q1_lz_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.q1
</span><span class="noop">        q1(0.0)
</span><span class="noop">        &gt;&gt;&gt; states.lz
</span><span class="noop">        lz(0.0)
</span><span class="noop">
</span><span class="noop">        For storage values above zero the linear...
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.lz = 2.
</span><span class="noop">        &gt;&gt;&gt; model.calc_q1_lz_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.q1
</span><span class="noop">        q1(0.2)
</span><span class="noop">        &gt;&gt;&gt; states.lz
</span><span class="noop">        lz(1.8)
</span><span class="noop">
</span><span class="noop">        ...or nonlinear storage routing equation applies:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; gamma(1.)
</span><span class="noop">        &gt;&gt;&gt; states.lz = 2.
</span><span class="noop">        &gt;&gt;&gt; model.calc_q1_lz_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.q1
</span><span class="noop">        q1(0.4)
</span><span class="noop">        &gt;&gt;&gt; states.lz
</span><span class="noop">        lz(1.6)
</span><span class="noop">
</span><span class="noop">        Note that the assumed length of the simulation step is only a
</span><span class="noop">        half day. Hence the effective value of the storage coefficient
</span><span class="noop">        is not 0.2 but 0.1:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; k4
</span><span class="noop">        k4(0.2)
</span><span class="noop">        &gt;&gt;&gt; k4.value
</span><span class="noop">        0.1
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    if sta.lz &gt; 0.:
</span><span class="hit">        flu.q1 = con.k4*sta.lz**(1.+con.gamma)
</span><span class="noop">    else:
</span><span class="hit">        flu.q1 = 0.
</span><span class="hit">    sta.lz -= flu.q1
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_inuh_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the unit hydrograph input.
</span><span class="noop">
</span><span class="noop">    Required derived parameters:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_derived.RelLandArea`
</span><span class="noop">
</span><span class="noop">    Required flux sequences:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.Q0`
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.Q1`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.InUH`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">        :math:`InUH = Q0 + Q1`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">        The unit hydrographs receives base flow from the whole subbasin
</span><span class="noop">        and direct flow from zones of type field, forest and glacier only.
</span><span class="noop">        In the following example, these occupy only one half of the
</span><span class="noop">        subbasin, which is why the partial input of q0 is halved:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; derived.rellandarea = 0.5
</span><span class="noop">        &gt;&gt;&gt; fluxes.q0 = 4.
</span><span class="noop">        &gt;&gt;&gt; fluxes.q1 = 1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_inuh_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.inuh
</span><span class="noop">        inuh(3.0)
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    flu.inuh = der.rellandarea*flu.q0+flu.q1
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_outuh_quh_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the unit hydrograph output (convolution).
</span><span class="noop">
</span><span class="noop">    Required derived parameters:
</span><span class="noop">        :class:`~hydpy.models.hland.hland_derived.UH`
</span><span class="noop">        :class:`~hydpy.models.hland.hland_derived.NmbUH`
</span><span class="noop">
</span><span class="noop">    Required flux sequences:
</span><span class="noop">        :class:`~hydpy.models.hland.hland_fluxes.Q0`
</span><span class="noop">        :class:`~hydpy.models.hland.hland_fluxes.Q1`
</span><span class="noop">        :class:`~hydpy.models.hland.hland_fluxes.InUH`
</span><span class="noop">
</span><span class="noop">    Updated log sequence:
</span><span class="noop">        :class:`~hydpy.models.hland.hland_logs.QUH`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">        :class:`~hydpy.models.hland.hland_fluxes.OutUH`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Prepare a unit hydrograph with only three ordinates ---
</span><span class="noop">        representing a fast catchment response compared to the selected
</span><span class="noop">        step size:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; derived.nmbuh = 3
</span><span class="noop">        &gt;&gt;&gt; derived.uh.shape = derived.nmbuh
</span><span class="noop">        &gt;&gt;&gt; derived.uh = 0.3, 0.5, 0.2
</span><span class="noop">        &gt;&gt;&gt; logs.quh.shape = 3
</span><span class="noop">        &gt;&gt;&gt; logs.quh = 1., 3., 0.
</span><span class="noop">
</span><span class="noop">        Without new input, the actual output is simply the first value
</span><span class="noop">        stored in the logging sequence and the values of the logging
</span><span class="noop">        sequence are shifted to the left:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.inuh = 0.
</span><span class="noop">        &gt;&gt;&gt; model.calc_outuh_quh_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.outuh
</span><span class="noop">        outuh(1.0)
</span><span class="noop">        &gt;&gt;&gt; logs.quh
</span><span class="noop">        quh(3.0, 0.0, 0.0)
</span><span class="noop">
</span><span class="noop">        With an new input of 4mm, the actual output consists of the first
</span><span class="noop">        value stored in the logging sequence and the input value
</span><span class="noop">        multiplied with the first unit hydrograph ordinate.  The updated
</span><span class="noop">        logging sequence values result from the multiplication of the
</span><span class="noop">        input values and the remaining ordinates:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.inuh = 4.
</span><span class="noop">        &gt;&gt;&gt; model.calc_outuh_quh_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.outuh
</span><span class="noop">        outuh(4.2)
</span><span class="noop">        &gt;&gt;&gt; logs.quh
</span><span class="noop">        quh(2.0, 0.8, 0.0)
</span><span class="noop">
</span><span class="noop">        The next example demonstates the updating of non empty logging
</span><span class="noop">        sequence:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.inuh = 4.
</span><span class="noop">        &gt;&gt;&gt; model.calc_outuh_quh_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.outuh
</span><span class="noop">        outuh(3.2)
</span><span class="noop">        &gt;&gt;&gt; logs.quh
</span><span class="noop">        quh(2.8, 0.8, 0.0)
</span><span class="noop">
</span><span class="noop">        A unit hydrograph with only one ordinate results in the direct
</span><span class="noop">        routing of the input:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.nmbuh = 1
</span><span class="noop">        &gt;&gt;&gt; derived.uh.shape = derived.nmbuh
</span><span class="noop">        &gt;&gt;&gt; derived.uh = 1.
</span><span class="noop">        &gt;&gt;&gt; fluxes.inuh = 0.
</span><span class="noop">        &gt;&gt;&gt; logs.quh.shape = 1
</span><span class="noop">        &gt;&gt;&gt; logs.quh = 0.
</span><span class="noop">        &gt;&gt;&gt; model.calc_outuh_quh_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.outuh
</span><span class="noop">        outuh(0.0)
</span><span class="noop">        &gt;&gt;&gt; logs.quh
</span><span class="noop">        quh(0.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.inuh = 4.
</span><span class="noop">        &gt;&gt;&gt; model.calc_outuh_quh()
</span><span class="noop">        &gt;&gt;&gt; fluxes.outuh
</span><span class="noop">        outuh(4.0)
</span><span class="noop">        &gt;&gt;&gt; logs.quh
</span><span class="noop">        quh(0.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    log = self.sequences.logs.fastaccess
</span><span class="hit">    flu.outuh = der.uh[0]*flu.inuh+log.quh[0]
</span><span class="hit">    for jdx in range(1, der.nmbuh):
</span><span class="hit">        log.quh[jdx-1] = der.uh[jdx]*flu.inuh+log.quh[jdx]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qt_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calcutate the total discharge after possible abstractions.
</span><span class="noop">
</span><span class="noop">    Required control parameter:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_control.Abstr`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.OutUH`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.hland.hland_fluxes.QT`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">        :math:`QT = max(OutUH - Abstr, 0)`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Trying to abstract less then available, as much as available and
</span><span class="noop">        less then available results in:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; abstr(2.)
</span><span class="noop">        &gt;&gt;&gt; fluxes.outuh = 2.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qt_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qt
</span><span class="noop">        qt(1.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.outuh = 1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qt_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qt
</span><span class="noop">        qt(0.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.outuh = .5
</span><span class="noop">        &gt;&gt;&gt; model.calc_qt_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qt
</span><span class="noop">        qt(0.0)
</span><span class="noop">
</span><span class="noop">        Note that &#34;negative abstractions&#34; are allowed:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; abstr(-2.)
</span><span class="noop">        &gt;&gt;&gt; fluxes.outuh = 1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qt_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qt
</span><span class="noop">        qt(2.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    flu.qt = max(flu.outuh-con.abstr, 0.)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def update_outlets_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Update the outlet link sequence.&#34;&#34;&#34;
</span><span class="miss">    der = self.parameters.derived.fastaccess
</span><span class="miss">    flu = self.sequences.fluxes.fastaccess
</span><span class="miss">    out = self.sequences.outlets.fastaccess
</span><span class="miss">    out.q[0] += der.qfactor*flu.qt
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Model(modeltools.Model):
</span><span class="noop">    &#34;&#34;&#34;The HydPy-H-Land base model.&#34;&#34;&#34;
</span><span class="hit">    _RUNMETHODS = (calc_tc_v1,
</span><span class="noop">                   calc_tmean_v1,
</span><span class="noop">                   calc_fracrain_v1,
</span><span class="noop">                   calc_rfc_sfc_v1,
</span><span class="noop">                   calc_pc_v1,
</span><span class="noop">                   calc_ep_v1,
</span><span class="noop">                   calc_epc_v1,
</span><span class="noop">                   calc_tf_ic_v1,
</span><span class="noop">                   calc_ei_ic_v1,
</span><span class="noop">                   calc_sp_wc_v1,
</span><span class="noop">                   calc_melt_sp_wc_v1,
</span><span class="noop">                   calc_refr_sp_wc_v1,
</span><span class="noop">                   calc_glmelt_in_v1,
</span><span class="noop">                   calc_in_wc_v1,
</span><span class="noop">                   calc_r_sm_v1,
</span><span class="noop">                   calc_cf_sm_v1,
</span><span class="noop">                   calc_ea_sm_v1,
</span><span class="noop">                   calc_inuz_v1,
</span><span class="noop">                   calc_contriarea_v1,
</span><span class="noop">                   calc_q0_perc_uz_v1,
</span><span class="noop">                   calc_lz_v1,
</span><span class="noop">                   calc_el_lz_v1,
</span><span class="noop">                   calc_q1_lz_v1,
</span><span class="noop">                   calc_inuh_v1,
</span><span class="noop">                   calc_outuh_quh_v1,
</span><span class="noop">                   calc_qt_v1,
</span><span class="noop">                   update_outlets_v1)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_outlets.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_outlets.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Q(sequencetools.LinkSequence):
</span><span class="noop">    &#34;&#34;&#34;Runoff [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class OutletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Downstream link sequences of the hland model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Q,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_parameters.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_parameters.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...third party
</span><span class="hit">import numpy
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import parametertools
</span><span class="noop"># ...model specific
</span><span class="hit">from hydpy.models.hland.hland_constants import FIELD, FOREST, ILAKE, GLACIER
</span><span class="hit">from hydpy.models.hland.hland_constants import CONSTANTS
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MultiParameter(parametertools.ZipParameter):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling parameters of the HydPy-H-Land model
</span><span class="noop">    (potentially) handling multiple values.
</span><span class="noop">
</span><span class="noop">    Due to inheriting from :class:`~hydpy.core.parametertools.ZipParameter`,
</span><span class="noop">    additional keyword zipping functionality is offered.  The optional
</span><span class="noop">    `kwargs` are checked for the keywords `field`, `forest`, `glacier`,
</span><span class="noop">    `ilake,` and `default`.  If available, the respective values are used to
</span><span class="noop">    define the values of those 1-dimensional arrays, whose entries are related
</span><span class="noop">    to the different zone types. Also the method
</span><span class="noop">    :func:`~MultiParameter.compressrepr` tries to find compressed string
</span><span class="noop">    representations based on the mentioned zone types.
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        Prepare a :class:`MultiParameter` instance:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland.hland_parameters import MultiParameter
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; mp = MultiParameter()
</span><span class="noop">        &gt;&gt;&gt; mp.DIM, mp.TYPE, mp.TIME = 1, float, None
</span><span class="noop">        &gt;&gt;&gt; mp.subpars = control
</span><span class="noop">
</span><span class="noop">        Usually, one would indirectly define its shape through parameter
</span><span class="noop">        :class:`~hydpy.models.hland.hland_control.NmbZones`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; mp.shape
</span><span class="noop">        Traceback (most recent call last):
</span><span class="noop">        ...
</span><span class="noop">        RuntimeError: Shape information for parameter `multiparameter` can only be retrieved after it has been defined.  You can do this manually, but usually it is done automatically by defining the value of parameter `nmbzones` first in each parameter control file.
</span><span class="noop">
</span><span class="noop">        But here it is set manually to the value 5 for representing
</span><span class="noop">        five different zone types:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; zonetype.shape = 5
</span><span class="noop">        &gt;&gt;&gt; zonetype(FIELD, FOREST, GLACIER, ILAKE, FIELD)
</span><span class="noop">        &gt;&gt;&gt; mp.shape = 5
</span><span class="noop">
</span><span class="noop">        Assign values to all four zone types explicitely:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; mp(field=2., forest=1., glacier=4., ilake=3.)
</span><span class="noop">        &gt;&gt;&gt; mp
</span><span class="noop">        multiparameter(field=2.0, forest=1.0, glacier=4.0, ilake=3.0)
</span><span class="noop">        &gt;&gt;&gt; mp.values
</span><span class="noop">        array([ 2.,  1.,  4.,  3.,  2.])
</span><span class="noop">
</span><span class="noop">        Specify a default value for all zone types not included in the
</span><span class="noop">        keyword list:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; mp(field=2., forest=1., default=9.)
</span><span class="noop">        &gt;&gt;&gt; mp
</span><span class="noop">        multiparameter(field=2.0, forest=1.0, glacier=9.0, ilake=9.0)
</span><span class="noop">        &gt;&gt;&gt; mp.values
</span><span class="noop">        array([ 2.,  1.,  9.,  9.,  2.])
</span><span class="noop">
</span><span class="noop">        If no default value is given, numpys `nan` is applied:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; mp(field=2., forest=1.)
</span><span class="noop">        &gt;&gt;&gt; mp
</span><span class="noop">        multiparameter(field=2.0, forest=1.0, glacier=nan, ilake=nan)
</span><span class="noop">        &gt;&gt;&gt; mp.values
</span><span class="noop">        array([  2.,   1.,  nan,  nan,   2.])
</span><span class="noop">
</span><span class="noop">        Of course, the usual value assignments remain unaffected:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; mp.values = 5.
</span><span class="noop">        &gt;&gt;&gt; mp
</span><span class="noop">        multiparameter(5.0)
</span><span class="noop">        &gt;&gt;&gt; mp.values
</span><span class="noop">        array([ 5.,  5.,  5.,  5.,  5.])
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; mp.values = 5., 4., 3., 2., 1.
</span><span class="noop">        &gt;&gt;&gt; mp
</span><span class="noop">        multiparameter(5.0, 4.0, 3.0, 2.0, 1.0)
</span><span class="noop">        &gt;&gt;&gt; mp.values
</span><span class="noop">        array([ 5.,  4.,  3.,  2.,  1.])
</span><span class="noop">
</span><span class="noop">    Another feature of :class:`MultiParameter` is that it relates the property
</span><span class="noop">    :func:`~MultiParameter.verifymask` to the defined zone types.
</span><span class="noop">    This requires the definition of the class attribute
</span><span class="noop">    :const:`~MultiParameter.REQUIRED_VALUES` for :class:`MultiParameter`
</span><span class="noop">    subclasses.
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        When values for all zone types are required, all entries of the
</span><span class="noop">        verification mask are `True`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; mp.REQUIRED_VALUES = (FIELD, FOREST, GLACIER, ILAKE)
</span><span class="noop">        &gt;&gt;&gt; mp.verifymask
</span><span class="noop">        array([ True,  True,  True,  True,  True], dtype=bool)
</span><span class="noop">
</span><span class="noop">        When values for field and forest zones are required only, the
</span><span class="noop">        entries related to glacier and ilake zones are `False`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; mp.REQUIRED_VALUES = (FIELD, FOREST)
</span><span class="noop">        &gt;&gt;&gt; mp.verifymask
</span><span class="noop">        array([ True,  True, False, False,  True], dtype=bool)
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    REQUIRED_VALUES = (FIELD, FOREST, GLACIER, ILAKE)
</span><span class="hit">    MODEL_CONSTANTS = CONSTANTS
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def refparameter(self):
</span><span class="noop">        &#34;&#34;&#34;Alias for the associated instance of
</span><span class="noop">        :class:`~hydpy.models.hland.hland_control.ZoneType`.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return self.subpars.pars.control.zonetype
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def shapeparameter(self):
</span><span class="noop">        &#34;&#34;&#34;Alias for the associated instance of
</span><span class="noop">        :class:`~hydpy.models.lland.lland_control.NmbZones`.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return self.subpars.pars.control.nmbzones
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MultiParameterSoil(MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling parameters of the hland model (potentially)
</span><span class="noop">    handling multiple values relevant for `soil zones` (and interception).
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    REQUIRED_VALUES = (FIELD, FOREST)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MultiParameterLand(MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling parameters of the hland model (potentially)
</span><span class="noop">    handling multiple values relevant for all `land zones`.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    REQUIRED_VALUES = (FIELD, FOREST, GLACIER)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MultiParameterLake(MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling parameters of the hland model (potentially)
</span><span class="noop">    handling multiple values relevant for `lake zones` only.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    REQUIRED_VALUES = (ILAKE,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MultiParameterGlacier(MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling parameters of the hland model (potentially)
</span><span class="noop">    handling multiple values relevant for `glacier zones` only.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    REQUIRED_VALUES = (GLACIER,)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MultiParameterNoGlacier(MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling parameters of the hland model (potentially)
</span><span class="noop">    handling multiple values relevant for `glacier free zones` only.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    REQUIRED_VALUES = (FIELD, FOREST, ILAKE)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Parameters(parametertools.Parameters):
</span><span class="noop">    &#34;&#34;&#34;All parameters of the hland model.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="noop">        &#34;&#34;&#34;Determine the values of the parameters handled by
</span><span class="noop">        :class:`DerivedParameters` based on the values of the parameters
</span><span class="noop">        handled by :class:`ControlParameters`.  The results of the different
</span><span class="noop">        methods are not interdependend, meaning their order could be changed.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        self.calc_relzonearea()
</span><span class="miss">        self.calc_landzonearea()
</span><span class="miss">        self.calc_soilarea()
</span><span class="miss">        self.calc_ttm()
</span><span class="miss">        self.calc_dt()
</span><span class="miss">        self.calc_nmbuh_uh()
</span><span class="miss">        self.calc_qfactor()
</span><span class="noop">
</span><span class="hit">    def calc_relzonearea(self):
</span><span class="noop">        &#34;&#34;&#34;Calculate the relative areas of all zones within the subbasin.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.ZoneArea`
</span><span class="noop">
</span><span class="noop">        Calculated derived parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_derived.RelZoneArea`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">
</span><span class="noop">            With one single zone, its relative area is one by definition:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; nmbzones(1)
</span><span class="noop">            &gt;&gt;&gt; zonearea(1111.)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_relzonearea()
</span><span class="noop">            &gt;&gt;&gt; derived.relzonearea
</span><span class="noop">            relzonearea(1.0)
</span><span class="noop">
</span><span class="noop">            An example for three zones of different sizes:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; nmbzones(3)
</span><span class="noop">            &gt;&gt;&gt; zonearea(1., 3., 2.)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_relzonearea()
</span><span class="noop">            &gt;&gt;&gt; derived.relzonearea
</span><span class="noop">            relzonearea(0.166667, 0.5, 0.333333)
</span><span class="noop">
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.control
</span><span class="hit">        der = self.derived
</span><span class="hit">        der.relzonearea(con.zonearea/sum(con.zonearea))
</span><span class="noop">
</span><span class="hit">    def calc_landzonearea(self):
</span><span class="noop">        &#34;&#34;&#34;Calculate the fraction of the summed area of all &#34;land zones&#34;
</span><span class="noop">        (of type FIELD, FOREST, or ILAKE) and the total subbasin area, and
</span><span class="noop">        calculate the fractions of all &#34;land zones&#34; and the total &#34;land area&#34;
</span><span class="noop">        of the subbasin.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.Area`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.ZoneArea`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">
</span><span class="noop">        Calculated derived parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_derived.RelLandArea`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_derived.RelLandZoneArea`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">
</span><span class="noop">            With all zones beeing &#34;land zones&#34;, the relative land area is
</span><span class="noop">            one by definition and the relative &#34;land zone&#34; areas are in
</span><span class="noop">            accordance with the original zone areas:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; nmbzones(3)
</span><span class="noop">            &gt;&gt;&gt; zonetype(FIELD, FOREST, GLACIER)
</span><span class="noop">            &gt;&gt;&gt; area(100.)
</span><span class="noop">            &gt;&gt;&gt; zonearea(25., 25., 50.)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_landzonearea()
</span><span class="noop">            &gt;&gt;&gt; derived.rellandarea
</span><span class="noop">            rellandarea(1.0)
</span><span class="noop">            &gt;&gt;&gt; derived.rellandzonearea
</span><span class="noop">            rellandzonearea(field=0.25, forest=0.25, glacier=0.5)
</span><span class="noop">
</span><span class="noop">            With one zone beeing a lake zone, the relative &#34;land area&#34; is
</span><span class="noop">            decreased and the relative &#34;land zone&#34; areas are increased ---
</span><span class="noop">            except the one related to the internal lake, which is set to zero:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; zonetype(FIELD, FOREST, ILAKE)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_landzonearea()
</span><span class="noop">            &gt;&gt;&gt; derived.rellandarea
</span><span class="noop">            rellandarea(0.5)
</span><span class="noop">            &gt;&gt;&gt; derived.rellandzonearea
</span><span class="noop">            rellandzonearea(field=0.5, forest=0.5, ilake=0.0)
</span><span class="noop">
</span><span class="noop">            With all zones beeing lake zones, all relative areas are zero:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; zonetype(ILAKE, ILAKE, ILAKE)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_landzonearea()
</span><span class="noop">            &gt;&gt;&gt; derived.rellandarea
</span><span class="noop">            rellandarea(0.0)
</span><span class="noop">            &gt;&gt;&gt; derived.rellandzonearea
</span><span class="noop">            rellandzonearea(0.0)
</span><span class="noop">
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.control
</span><span class="hit">        der = self.derived
</span><span class="hit">        landzonearea = con.zonearea.copy()
</span><span class="hit">        landzonearea[con.zonetype == ILAKE] = 0.
</span><span class="hit">        landarea = numpy.sum(landzonearea)
</span><span class="hit">        if landarea &gt; 0.:
</span><span class="hit">            der.rellandzonearea(landzonearea/landarea)
</span><span class="noop">        else:
</span><span class="hit">            der.rellandzonearea(0.)
</span><span class="hit">        der.rellandarea(landarea/con.area)
</span><span class="noop">
</span><span class="hit">    def calc_soilarea(self):
</span><span class="noop">        &#34;&#34;&#34;Calculate the fraction of the summed area of all &#34;soil zones&#34;
</span><span class="noop">        (of type FIELD or FOREST) and the total subbasin area, and
</span><span class="noop">        calculate the fractions of all &#34;soil zones&#34; and the total &#34;soil area&#34;
</span><span class="noop">        of the subbasin.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.Area`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.ZoneArea`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.ZoneType`
</span><span class="noop">
</span><span class="noop">        Calculated derived parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_derived.RelSoilArea`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_derived.RelSoilZoneArea`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">
</span><span class="noop">            With all zones beeing &#34;soil zones&#34;, the relative land area is
</span><span class="noop">            one by definition and the relative &#34;soil zone&#34; areas are in
</span><span class="noop">            accordance with the original zone areas:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; nmbzones(4)
</span><span class="noop">            &gt;&gt;&gt; zonetype(FIELD, FOREST, FIELD, FOREST)
</span><span class="noop">            &gt;&gt;&gt; area(100.)
</span><span class="noop">            &gt;&gt;&gt; zonearea(25., 25., 25., 25.)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_soilarea()
</span><span class="noop">            &gt;&gt;&gt; derived.relsoilarea
</span><span class="noop">            relsoilarea(1.0)
</span><span class="noop">            &gt;&gt;&gt; derived.relsoilzonearea
</span><span class="noop">            relsoilzonearea(0.25)
</span><span class="noop">
</span><span class="noop">            With one zone beeing a lake zone one one zone beeing a glacier
</span><span class="noop">            zone, the relative &#34;soil area&#34; is decreased and the relative
</span><span class="noop">            &#34;soil zone&#34; areas are increased --- except the ones related to
</span><span class="noop">            the internal lake and the glacier, which are set to zero:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; zonetype(FIELD, FOREST, GLACIER, ILAKE)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_soilarea()
</span><span class="noop">            &gt;&gt;&gt; derived.relsoilarea
</span><span class="noop">            relsoilarea(0.5)
</span><span class="noop">            &gt;&gt;&gt; derived.relsoilzonearea
</span><span class="noop">            relsoilzonearea(field=0.5, forest=0.5, glacier=0.0, ilake=0.0)
</span><span class="noop">
</span><span class="noop">            With all zones beeing lake or glacier zones, all relative areas
</span><span class="noop">            are zero:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; zonetype(GLACIER, GLACIER, ILAKE, ILAKE)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_soilarea()
</span><span class="noop">            &gt;&gt;&gt; derived.relsoilarea
</span><span class="noop">            relsoilarea(0.0)
</span><span class="noop">            &gt;&gt;&gt; derived.relsoilzonearea
</span><span class="noop">            relsoilzonearea(0.0)
</span><span class="noop">
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.control
</span><span class="hit">        der = self.derived
</span><span class="hit">        soilzonearea = con.zonearea.copy()
</span><span class="hit">        soilzonearea[con.zonetype == GLACIER] = 0.
</span><span class="hit">        soilzonearea[con.zonetype == ILAKE] = 0.
</span><span class="hit">        soilarea = numpy.sum(soilzonearea)
</span><span class="hit">        if soilarea &gt; 0.:
</span><span class="hit">            der.relsoilzonearea(soilzonearea/soilarea)
</span><span class="noop">        else:
</span><span class="hit">            der.relsoilzonearea(0.)
</span><span class="hit">        der.relsoilarea(soilarea/con.area)
</span><span class="noop">
</span><span class="hit">    def calc_ttm(self):
</span><span class="noop">        &#34;&#34;&#34;Calculate the threshold temperature for melting and refreezing.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.TT`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.DTTM`
</span><span class="noop">
</span><span class="noop">        Calculated derived parameter:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_derived.TTM`
</span><span class="noop">
</span><span class="noop">        Basic equation:
</span><span class="noop">          :math:`TTM = TT+DTTM`
</span><span class="noop">
</span><span class="noop">        Example:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; nmbzones(1)
</span><span class="noop">            &gt;&gt;&gt; tt(1.)
</span><span class="noop">            &gt;&gt;&gt; dttm(-2.)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_ttm()
</span><span class="noop">            &gt;&gt;&gt; derived.ttm
</span><span class="noop">            ttm(-1.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.control
</span><span class="hit">        der = self.derived
</span><span class="hit">        der.ttm(con.tt+con.dttm)
</span><span class="noop">
</span><span class="hit">    def calc_dt(self):
</span><span class="noop">        &#34;&#34;&#34;Determine the relative time step size for solving the upper
</span><span class="noop">        zone layer routine.
</span><span class="noop">
</span><span class="noop">        Required control parameter:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.RecStep`
</span><span class="noop">
</span><span class="noop">        Calculated derived parameter:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_derived.DT`
</span><span class="noop">
</span><span class="noop">        Basic equation:
</span><span class="noop">          :math:`DT = \\frac{1}{RecStep}`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">            &gt;&gt;&gt; recstep(2.)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_dt()
</span><span class="noop">            &gt;&gt;&gt; derived.dt
</span><span class="noop">            dt(1.0)
</span><span class="noop">            &gt;&gt;&gt; recstep(10.)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_dt()
</span><span class="noop">            &gt;&gt;&gt; derived.dt
</span><span class="noop">            dt(0.2)
</span><span class="noop">
</span><span class="noop">            Note that the value assigned to recstep is related to the given
</span><span class="noop">            parameter step size of one day.  The actually applied recstep of
</span><span class="noop">            the last example is:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; recstep.value
</span><span class="noop">            5
</span><span class="noop">
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.control
</span><span class="hit">        der = self.derived
</span><span class="hit">        der.dt(1./con.recstep)
</span><span class="noop">
</span><span class="hit">    def calc_qfactor(self):
</span><span class="noop">        &#34;&#34;&#34;Determine the factor for converting values of
</span><span class="noop">        :class:`~hydpy.models.hland.hland_fluxes.QT` [mm/T] to values of
</span><span class="noop">        :class:`~hydpy.models.hland.hland_outlets.Q` [m³/s].
</span><span class="noop">
</span><span class="noop">        Required control parameter:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.Area`
</span><span class="noop">
</span><span class="noop">        Required property of
</span><span class="noop">        :class:`~hydpy.core.parametertools.Parameter`:
</span><span class="noop">
</span><span class="noop">          :attr:`~hydpy.core.parametertools.Parameter.seconds`
</span><span class="noop">
</span><span class="noop">        Calculated derived parameter:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_derived.QFactor`
</span><span class="noop">
</span><span class="noop">        Example:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">            &gt;&gt;&gt; area(50.)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_qfactor()
</span><span class="noop">            &gt;&gt;&gt; derived.qfactor
</span><span class="noop">            qfactor(1.157407)
</span><span class="noop">
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.control
</span><span class="hit">        der = self.derived
</span><span class="hit">        der.qfactor(con.area*1000./der.qfactor.simulationstep.seconds)
</span><span class="noop">
</span><span class="hit">    def calc_nmbuh_uh(self):
</span><span class="noop">        &#34;&#34;&#34;Calculate the ordinates of the triangle unit hydrograph.
</span><span class="noop">
</span><span class="noop">        Note that also the shape of sequence
</span><span class="noop">        :class:`~hydpy.models.hland.hland_logs.QUH` is defined in accordance
</span><span class="noop">        with :class:`~hydpy.models.hland.hland_derived.NmbUH`.
</span><span class="noop">
</span><span class="noop">        Required control parameter:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_control.MaxBaz`
</span><span class="noop">
</span><span class="noop">        Calculated derived parameters:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_derived.NmbUH`
</span><span class="noop">          :class:`~hydpy.models.hland.hland_derived.UH`
</span><span class="noop">
</span><span class="noop">        Prepared log sequence:
</span><span class="noop">          :class:`~hydpy.models.hland.hland_logs.QUH`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">
</span><span class="noop">            MaxBaz determines the end point of the triangle.  A value of
</span><span class="noop">            MaxBaz beeing not larger than the simulation step size is
</span><span class="noop">            identical with applying no unit hydrograph at all:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">            &gt;&gt;&gt; maxbaz(0.)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_nmbuh_uh()
</span><span class="noop">            &gt;&gt;&gt; derived.nmbuh
</span><span class="noop">            nmbuh(1)
</span><span class="noop">            &gt;&gt;&gt; logs.quh.shape
</span><span class="noop">            (1,)
</span><span class="noop">            &gt;&gt;&gt; derived.uh
</span><span class="noop">            uh(1.0)
</span><span class="noop">
</span><span class="noop">            Note that, due to difference of the parameter and the simulation
</span><span class="noop">            step size in the given example, the largest assignement resulting
</span><span class="noop">            in a `inactive` unit hydrograph is 1/2:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; maxbaz(0.5)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_nmbuh_uh()
</span><span class="noop">            &gt;&gt;&gt; derived.nmbuh
</span><span class="noop">            nmbuh(1)
</span><span class="noop">            &gt;&gt;&gt; logs.quh.shape
</span><span class="noop">            (1,)
</span><span class="noop">            &gt;&gt;&gt; derived.uh
</span><span class="noop">            uh(1.0)
</span><span class="noop">
</span><span class="noop">            When MaxBaz is in accordance with two simulation steps, both
</span><span class="noop">            unit hydrograph ordinats must be 1/2, due to symmetry of the
</span><span class="noop">            triangle:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; maxbaz(1.)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_nmbuh_uh()
</span><span class="noop">            &gt;&gt;&gt; derived.nmbuh
</span><span class="noop">            nmbuh(2)
</span><span class="noop">            &gt;&gt;&gt; logs.quh.shape
</span><span class="noop">            (2,)
</span><span class="noop">            &gt;&gt;&gt; derived.uh
</span><span class="noop">            uh(0.5)
</span><span class="noop">
</span><span class="noop">            A MaxBaz value in accordance with three simulation steps results
</span><span class="noop">            --- when expressed as fractions --- in the ordinate values 2/9,
</span><span class="noop">            5/9, and 2/9:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; maxbaz(1.5)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_nmbuh_uh()
</span><span class="noop">            &gt;&gt;&gt; derived.nmbuh
</span><span class="noop">            nmbuh(3)
</span><span class="noop">            &gt;&gt;&gt; logs.quh.shape
</span><span class="noop">            (3,)
</span><span class="noop">            &gt;&gt;&gt; derived.uh
</span><span class="noop">            uh(0.222222, 0.555556, 0.222222)
</span><span class="noop">
</span><span class="noop">            And a final example, where the end of the triangle lies within
</span><span class="noop">            a simulation step, resulting in the fractions 8/49, 23/49, 16/49,
</span><span class="noop">            and 2/49:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; maxbaz(1.75)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_nmbuh_uh()
</span><span class="noop">            &gt;&gt;&gt; derived.nmbuh
</span><span class="noop">            nmbuh(4)
</span><span class="noop">            &gt;&gt;&gt; logs.quh.shape
</span><span class="noop">            (4,)
</span><span class="noop">            &gt;&gt;&gt; derived.uh
</span><span class="noop">            uh(0.163265, 0.469388, 0.326531, 0.040816)
</span><span class="noop">
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.control
</span><span class="hit">        der = self.derived
</span><span class="hit">        log = self.model.sequences.logs
</span><span class="noop">        # Determine UH parameters...
</span><span class="hit">        if con.maxbaz &lt;= 1.:
</span><span class="noop">            # ...when MaxBaz smaller than or equal to the simulation time step.
</span><span class="hit">            der.nmbuh = 1
</span><span class="hit">            der.uh.shape = 1
</span><span class="hit">            der.uh(1.)
</span><span class="hit">            log.quh.shape = 1
</span><span class="noop">        else:
</span><span class="noop">            # ...when MaxBaz is greater than the simulation time step.
</span><span class="noop">            # Define some shortcuts for the following calculations.
</span><span class="hit">            full = con.maxbaz.value
</span><span class="noop">            # Now comes a terrible trick due to rounding problems coming from
</span><span class="noop">            # the conversation of the SMHI parameter set to the HydPy
</span><span class="noop">            # parameter set.  Time to get rid of it...
</span><span class="hit">            if (full % 1.) &lt; 1e-4:
</span><span class="hit">                full //= 1.
</span><span class="hit">            full_f = int(numpy.floor(full))
</span><span class="hit">            full_c = int(numpy.ceil(full))
</span><span class="hit">            half = full/2.
</span><span class="hit">            half_f = int(numpy.floor(half))
</span><span class="hit">            half_c = int(numpy.ceil(half))
</span><span class="hit">            full_2 = full**2.
</span><span class="noop">            # Calculate the triangle ordinate(s)...
</span><span class="hit">            der.nmbuh(full_c)
</span><span class="hit">            der.uh.shape = full_c
</span><span class="hit">            log.quh.shape = full_c
</span><span class="noop">            # ...of the rising limb.
</span><span class="hit">            points = numpy.arange(1, half_f+1)
</span><span class="hit">            der.uh[:half_f] = (2.*points-1.)/(2.*full_2)
</span><span class="noop">            # ...around the peak (if it exists).
</span><span class="hit">            if numpy.mod(half, 1.) != 0.:
</span><span class="hit">                der.uh[half_f] = \
</span><span class="noop">                    ((half_c-half)/full +
</span><span class="noop">                     (2*half**2.-half_f**2.-half_c**2.)/(2.*full_2))
</span><span class="noop">            # ...of the falling limb (eventually except the last one).
</span><span class="hit">            points = numpy.arange(half_c+1., full_f+1.)
</span><span class="hit">            der.uh[half_c:full_f] = 1./full-(2.*points-1.)/(2.*full_2)
</span><span class="noop">            # ...at the end (if not already done).
</span><span class="hit">            if numpy.mod(full, 1.) != 0.:
</span><span class="hit">                der.uh[full_f] = ((full-full_f)/full -
</span><span class="noop">                                  (full_2-full_f**2.)/(2.*full_2))
</span><span class="noop">            # Normalize the ordinates.
</span><span class="hit">            der.uh(der.uh/numpy.sum(der.uh))
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_states.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hland/hland_states.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="hit">from hydpy.models.hland.hland_constants import ILAKE
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Ic(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Interception storage [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (0., None)
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="noop">        &#34;&#34;&#34;Trim upper values in accordance with :math:`IC \\leq ICMAX`.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(5)
</span><span class="noop">        &gt;&gt;&gt; icmax(2.)
</span><span class="noop">        &gt;&gt;&gt; states.ic(-1.,0., 1., 2., 3.)
</span><span class="noop">        &gt;&gt;&gt; states.ic
</span><span class="noop">        ic(0.0, 0.0, 1.0, 2.0, 2.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if upper is None:
</span><span class="hit">            control = self.subseqs.seqs.model.parameters.control
</span><span class="hit">            upper = control.icmax
</span><span class="hit">        sequencetools.StateSequence.trim(self, lower, upper)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class SP(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Frozen water stored in the snow layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (None, None)
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="noop">        &#34;&#34;&#34;Trim values in accordance with :math:`WC \\leq WHC \\cdot SP`.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(7)
</span><span class="noop">        &gt;&gt;&gt; whc(.1)
</span><span class="noop">        &gt;&gt;&gt; states.wc.values = -1., 0., 1., -1., 0., .5, 1.
</span><span class="noop">        &gt;&gt;&gt; states.sp(-1., 0., 0., 5., 5., 5., 5.)
</span><span class="noop">        &gt;&gt;&gt; states.sp
</span><span class="noop">        sp(0.0, 0.0, 10.0, 5.0, 5.0, 5.0, 10.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        whc = self.subseqs.seqs.model.parameters.control.whc
</span><span class="hit">        wc = self.subseqs.wc
</span><span class="hit">        if lower is None:
</span><span class="hit">            if wc.values is not None:
</span><span class="hit">                lower = numpy.clip(wc/whc, 0., numpy.inf)
</span><span class="noop">            else:
</span><span class="miss">                lower = 0.
</span><span class="hit">        sequencetools.StateSequence.trim(self, lower, upper)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class WC(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Liquid water content of the snow layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (0., None)
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="noop">        &#34;&#34;&#34;Trim values in accordance with :math:`WC \\leq WHC \\cdot SP`.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(7)
</span><span class="noop">        &gt;&gt;&gt; whc(.1)
</span><span class="noop">        &gt;&gt;&gt; states.sp = 0., 0., 0., 5., 5., 5., 5.
</span><span class="noop">        &gt;&gt;&gt; states.wc(-1., 0., 1., -1., 0., .5, 1.)
</span><span class="noop">        &gt;&gt;&gt; states.wc
</span><span class="noop">        wc(0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.5)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        whc = self.subseqs.seqs.model.parameters.control.whc
</span><span class="hit">        sp = self.subseqs.sp
</span><span class="hit">        if (upper is None) and (sp.values is not None):
</span><span class="hit">            upper = whc*sp
</span><span class="hit">        sequencetools.StateSequence.trim(self, lower, upper)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class SM(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Soil moisture [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (0., None)
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="noop">        &#34;&#34;&#34;Trim values in accordance with :math:`SM \\leq FC`.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(5)
</span><span class="noop">        &gt;&gt;&gt; fc(200.)
</span><span class="noop">        &gt;&gt;&gt; states.sm(-100.,0., 100., 200., 300.)
</span><span class="noop">        &gt;&gt;&gt; states.sm
</span><span class="noop">        sm(0.0, 0.0, 100.0, 200.0, 200.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if upper is None:
</span><span class="hit">            upper = self.subseqs.seqs.model.parameters.control.fc
</span><span class="hit">        sequencetools.StateSequence.trim(self, lower, upper)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class UZ(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Storage in the upper zone layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class LZ(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Storage in the lower zone layer [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (None, None)
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="noop">        &#34;&#34;&#34;Trim negative value whenever there is no internal lake within
</span><span class="noop">        the respective subbasin.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nmbzones(2)
</span><span class="noop">        &gt;&gt;&gt; zonetype(FIELD, ILAKE)
</span><span class="noop">        &gt;&gt;&gt; states.lz(-1.)
</span><span class="noop">        &gt;&gt;&gt; states.lz
</span><span class="noop">        lz(-1.0)
</span><span class="noop">        &gt;&gt;&gt; zonetype(FIELD, FOREST)
</span><span class="noop">        &gt;&gt;&gt; states.lz(-1.0)
</span><span class="noop">        &gt;&gt;&gt; states.lz
</span><span class="noop">        lz(0.0)
</span><span class="noop">        &gt;&gt;&gt; states.lz(1.)
</span><span class="noop">        &gt;&gt;&gt; states.lz
</span><span class="noop">        lz(1.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if upper is None:
</span><span class="hit">            control = self.subseqs.seqs.model.parameters.control
</span><span class="hit">            if not any(control.zonetype == ILAKE):
</span><span class="hit">                lower = 0.
</span><span class="hit">        sequencetools.StateSequence.trim(self, lower, upper)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class StateSequences(sequencetools.StateSequences):
</span><span class="noop">    &#34;&#34;&#34;State sequences of the HydPy-H-Land model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Ic, SP, WC, SM, UZ, LZ)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream/__init__.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream/__init__.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;The HydPy-H-Stream model is an very simple routing approach.  More
</span><span class="noop">precisely, it is a simplification of the Muskingum approach, which
</span><span class="noop">itself can be seen as a naive finite difference solution of the
</span><span class="noop">routing problem.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core.modelimports import *
</span><span class="noop"># ...from hstream
</span><span class="hit">from hydpy.models.hstream.hstream_parameters import Parameters
</span><span class="hit">from hydpy.models.hstream.hstream_control import ControlParameters
</span><span class="hit">from hydpy.models.hstream.hstream_derived import DerivedParameters
</span><span class="hit">from hydpy.models.hstream.hstream_states import StateSequences
</span><span class="hit">from hydpy.models.hstream.hstream_inlets import InletSequences
</span><span class="hit">from hydpy.models.hstream.hstream_outlets import OutletSequences
</span><span class="hit">from hydpy.models.hstream.hstream_model import Model
</span><span class="noop">
</span><span class="hit">autodoc_basemodel()
</span><span class="hit">tester = Tester()
</span><span class="hit">cythonizer = Cythonizer()
</span><span class="hit">cythonizer.complete()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream/hstream_control.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream/hstream_control.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import parametertools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Lag(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Time lag between inflow and outflow [T].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Damp(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Damping of the hydrograph [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., 1.)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ControlParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Control parameters of hstream, directly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (Lag, Damp)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream/hstream_derived.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream/hstream_derived.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import parametertools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class NmbSegments(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Number of river segments [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, int, None, (0, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class C1(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;First coefficient of the muskingum working formula [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., .5)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class C2(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Second coefficient of the muskingum working formula [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., 1.)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class C3(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Third coefficient of the muskingum working formula [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., .5)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class DerivedParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Derived parameters of hstream, indirectly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (NmbSegments, C1, C2, C3)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream/hstream_inlets.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream/hstream_inlets.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Q(sequencetools.LinkSequence):
</span><span class="noop">    &#34;&#34;&#34;Runoff [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class InletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Upstream link sequences of the hstream model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Q,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream/hstream_model.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream/hstream_model.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import modeltools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qjoints_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Apply the routing equation.
</span><span class="noop">
</span><span class="noop">    Required derived parameters:
</span><span class="noop">      :class:`~hydpy.models.hstream.hstream_derived.NmbSegments`
</span><span class="noop">      :class:`~hydpy.models.hstream.hstream_derived.C1`
</span><span class="noop">      :class:`~hydpy.models.hstream.hstream_derived.C2`
</span><span class="noop">      :class:`~hydpy.models.hstream.hstream_derived.C3`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">      :class:`~hydpy.models.hstream.hstream_states.QJoints`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`Q_{space+1,time+1} =
</span><span class="noop">      c1 \\cdot Q_{space,time+1} +
</span><span class="noop">      c2 \\cdot Q_{space,time} +
</span><span class="noop">      c3 \\cdot Q_{space+1,time}`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        Firstly, define a reach divided into 4 segments:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.hstream import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; derived.nmbsegments(4)
</span><span class="noop">        &gt;&gt;&gt; states.qjoints.shape = 5
</span><span class="noop">
</span><span class="noop">        Zero damping is achieved through the following coefficients:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.c1(0.)
</span><span class="noop">        &gt;&gt;&gt; derived.c2(1.)
</span><span class="noop">        &gt;&gt;&gt; derived.c3(0.)
</span><span class="noop">
</span><span class="noop">        For initialization, assume a base flow of 2m³/s:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.qjoints.old = 2.
</span><span class="noop">        &gt;&gt;&gt; states.qjoints.new = 2.
</span><span class="noop">
</span><span class="noop">        Through successive assignements of different discharge values
</span><span class="noop">        to the upper junction one can see, that these discharge values
</span><span class="noop">        are simply shifted from each junction to the respective lower
</span><span class="noop">        junction at each time step:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.qjoints[0] = 5.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qjoints_v1()
</span><span class="noop">        &gt;&gt;&gt; model.new2old()
</span><span class="noop">        &gt;&gt;&gt; states.qjoints
</span><span class="noop">        qjoints(5.0, 2.0, 2.0, 2.0, 2.0)
</span><span class="noop">        &gt;&gt;&gt; states.qjoints[0] = 8.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qjoints_v1()
</span><span class="noop">        &gt;&gt;&gt; model.new2old()
</span><span class="noop">        &gt;&gt;&gt; states.qjoints
</span><span class="noop">        qjoints(8.0, 5.0, 2.0, 2.0, 2.0)
</span><span class="noop">        &gt;&gt;&gt; states.qjoints[0] = 6.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qjoints_v1()
</span><span class="noop">        &gt;&gt;&gt; model.new2old()
</span><span class="noop">        &gt;&gt;&gt; states.qjoints
</span><span class="noop">        qjoints(6.0, 8.0, 5.0, 2.0, 2.0)
</span><span class="noop">
</span><span class="noop">        With the maximum damping allowed, the values of the derived
</span><span class="noop">        parameters are:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.c1(.5)
</span><span class="noop">        &gt;&gt;&gt; derived.c2(.0)
</span><span class="noop">        &gt;&gt;&gt; derived.c3(.5)
</span><span class="noop">
</span><span class="noop">        Assuming again a base flow of 2m³/s and the same input values
</span><span class="noop">        results in:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.qjoints.old = 2.
</span><span class="noop">        &gt;&gt;&gt; states.qjoints.new = 2.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.qjoints[0] = 5.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qjoints_v1()
</span><span class="noop">        &gt;&gt;&gt; model.new2old()
</span><span class="noop">        &gt;&gt;&gt; states.qjoints
</span><span class="noop">        qjoints(5.0, 3.5, 2.75, 2.375, 2.1875)
</span><span class="noop">        &gt;&gt;&gt; states.qjoints[0] = 8.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qjoints_v1()
</span><span class="noop">        &gt;&gt;&gt; model.new2old()
</span><span class="noop">        &gt;&gt;&gt; states.qjoints
</span><span class="noop">        qjoints(8.0, 5.75, 4.25, 3.3125, 2.75)
</span><span class="noop">        &gt;&gt;&gt; states.qjoints[0] = 6.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qjoints_v1()
</span><span class="noop">        &gt;&gt;&gt; model.new2old()
</span><span class="noop">        &gt;&gt;&gt; states.qjoints
</span><span class="noop">        qjoints(6.0, 5.875, 5.0625, 4.1875, 3.46875)
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    new = self.sequences.states.fastaccess_new
</span><span class="hit">    old = self.sequences.states.fastaccess_old
</span><span class="hit">    for j in range(der.nmbsegments):
</span><span class="hit">        new.qjoints[j+1] = (der.c1*new.qjoints[j] +
</span><span class="noop">                            der.c2*old.qjoints[j] +
</span><span class="noop">                            der.c3*old.qjoints[j+1])
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def update_inlets_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Assign the actual value of the inlet sequence to the upper joint
</span><span class="noop">    of the subreach upstream.&#34;&#34;&#34;
</span><span class="miss">    sta = self.sequences.states.fastaccess
</span><span class="miss">    inl = self.sequences.inlets.fastaccess
</span><span class="miss">    sta.qjoints[0] = inl.q[0]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def update_outlets_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Assing the actual value of the lower joint of of the subreach
</span><span class="noop">    downstream to the outlet sequence.&#34;&#34;&#34;
</span><span class="miss">    der = self.parameters.derived.fastaccess
</span><span class="miss">    sta = self.sequences.states.fastaccess
</span><span class="miss">    out = self.sequences.outlets.fastaccess
</span><span class="miss">    out.q[0] += sta.qjoints[der.nmbsegments]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Model(modeltools.Model):
</span><span class="noop">    &#34;&#34;&#34;The HydPy-H-Stream model.&#34;&#34;&#34;
</span><span class="hit">    _RUNMETHODS = (calc_qjoints_v1,
</span><span class="noop">                   update_inlets_v1,
</span><span class="noop">                   update_outlets_v1)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream/hstream_outlets.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream/hstream_outlets.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Q(sequencetools.LinkSequence):
</span><span class="noop">    &#34;&#34;&#34;Runoff [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class OutletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Downstream link sequences of the hstream model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Q,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream/hstream_parameters.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream/hstream_parameters.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import parametertools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Parameters(parametertools.Parameters):
</span><span class="noop">    &#34;&#34;&#34;All parameters of the hstream model.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="noop">        &#34;&#34;&#34;Determines the values of the parameters handled by
</span><span class="noop">        :class:`DerivedParameters` based on the values of the parameters.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="miss">        self.calc_nmbsegments()
</span><span class="miss">        self.calc_coefficients()
</span><span class="noop">
</span><span class="hit">    def calc_nmbsegments(self):
</span><span class="noop">        &#34;&#34;&#34;Determines in how many segments the whole reach needs to be
</span><span class="noop">        divided to approximate the desired lag time via integer rounding.
</span><span class="noop">        Adjusts the shape of sequence :class:`QJoints` additionally.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`Lag`
</span><span class="noop">
</span><span class="noop">        Calculated derived parameters:
</span><span class="noop">          :class:`NmbSegments`
</span><span class="noop">
</span><span class="noop">        Prepared state sequence:
</span><span class="noop">          :class:`QJoints`
</span><span class="noop">
</span><span class="noop">        Example:
</span><span class="noop">
</span><span class="noop">            Define a lag time of 1.4 days and a simulation step size of 12
</span><span class="noop">            hours:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hstream import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">            &gt;&gt;&gt; lag(1.4)
</span><span class="noop">
</span><span class="noop">            Then the actual lag value for the simulation step size is 2.8
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; lag
</span><span class="noop">            lag(1.4)
</span><span class="noop">            &gt;&gt;&gt; lag.value
</span><span class="noop">            2.8
</span><span class="noop">
</span><span class="noop">            Through rounding the number of segments is determined:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_nmbsegments()
</span><span class="noop">            &gt;&gt;&gt; derived.nmbsegments
</span><span class="noop">            nmbsegments(3)
</span><span class="noop">
</span><span class="noop">            The number of joints is always the number of segments plus one:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; states.qjoints.shape
</span><span class="noop">            (4,)
</span><span class="noop">
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.control
</span><span class="hit">        der = self.derived
</span><span class="hit">        der.nmbsegments = int(round(con.lag))
</span><span class="hit">        self.model.sequences.states.qjoints.shape = der.nmbsegments+1
</span><span class="noop">
</span><span class="hit">    def calc_coefficients(self):
</span><span class="noop">        &#34;&#34;&#34;Calculates the Muskingum coefficients.
</span><span class="noop">
</span><span class="noop">        Required control parameters:
</span><span class="noop">          :class:`Damp`
</span><span class="noop">
</span><span class="noop">        Calculated derived parameters:
</span><span class="noop">          :class:`C1`
</span><span class="noop">          :class:`C2`
</span><span class="noop">          :class:`C3`
</span><span class="noop">
</span><span class="noop">        Basic equations:
</span><span class="noop">          :math:`c_1 = \\frac{Damp}{1+Damp}`\n
</span><span class="noop">          :math:`c_3 = \\frac{Damp}{1+Damp}`\n
</span><span class="noop">          :math:`c_2 = 1.-c_1-c_3`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">
</span><span class="noop">            If no damping is required, the coeffients are:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.hstream import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; damp(0.)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_coefficients()
</span><span class="noop">            &gt;&gt;&gt; derived.c1, derived.c2, derived.c3
</span><span class="noop">            (c1(0.0), c2(1.0), c3(0.0))
</span><span class="noop">
</span><span class="noop">            The strongest damping is achieved through:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; damp(1.)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_coefficients()
</span><span class="noop">            &gt;&gt;&gt; derived.c1, derived.c2, derived.c3
</span><span class="noop">            (c1(0.5), c2(0.0), c3(0.5))
</span><span class="noop">
</span><span class="noop">            And finally an intermediate example:
</span><span class="noop">
</span><span class="noop">            &gt;&gt;&gt; damp(.25)
</span><span class="noop">            &gt;&gt;&gt; model.parameters.calc_coefficients()
</span><span class="noop">            &gt;&gt;&gt; derived.c1, derived.c2, derived.c3
</span><span class="noop">            (c1(0.2), c2(0.6), c3(0.2))
</span><span class="noop">
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.control
</span><span class="hit">        der = self.derived
</span><span class="hit">        der.c1 = der.c3 = numpy.clip(con.damp/(1.+con.damp), 0., .5)
</span><span class="hit">        der.c2 = numpy.clip(1.-der.c1-der.c3, 0., 1.)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream/hstream_states.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/hstream/hstream_states.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import sys
</span><span class="hit">import warnings
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QJoints(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Runoff at the segment junctions [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (0., None)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args):
</span><span class="miss">        try:
</span><span class="miss">            sequencetools.StateSequence.__call__(self, *args)
</span><span class="miss">        except BaseException:
</span><span class="miss">            message = sys.exc_info()[1]
</span><span class="miss">            sequencetools.StateSequence.__call__(self, numpy.mean(args))
</span><span class="miss">            warnings.warn(&#39;Note that, due to the following problem, the&#39;
</span><span class="noop">                          &#39;affected HydPy-H-Stream model could be initialised &#39;
</span><span class="noop">                          &#39;with an averaged value only: %s&#39; % message)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class StateSequences(sequencetools.StateSequences):
</span><span class="noop">    &#34;&#34;&#34;State sequences of the hstream model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (QJoints,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake/__init__.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake/__init__.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;
</span><span class="noop">The L-Lake model defines the methods and classes required for
</span><span class="noop">performing lake and dam retention processes as implemented in
</span><span class="noop">LARSIM.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core.modelimports import *
</span><span class="noop"># ...from llake
</span><span class="hit">from hydpy.models.llake.llake_control import ControlParameters
</span><span class="hit">from hydpy.models.llake.llake_derived import DerivedParameters
</span><span class="hit">from hydpy.models.llake.llake_fluxes import FluxSequences
</span><span class="hit">from hydpy.models.llake.llake_states import StateSequences
</span><span class="hit">from hydpy.models.llake.llake_inlets import InletSequences
</span><span class="hit">from hydpy.models.llake.llake_outlets import OutletSequences
</span><span class="hit">from hydpy.models.llake.llake_aides import AideSequences
</span><span class="hit">from hydpy.models.llake.llake_model import Model
</span><span class="noop">
</span><span class="hit">autodoc_basemodel()
</span><span class="hit">tester = Tester()
</span><span class="hit">cythonizer = Cythonizer()
</span><span class="hit">cythonizer.complete()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake/llake_aides.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake/llake_aides.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QA(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Seeausfluss (outflow from the lake) [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class VQ(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Hilfsterm (auxiliary term) [m³].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class V(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Wasservolumen (water volume) [m³].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class AideSequences(sequencetools.AideSequences):
</span><span class="noop">    &#34;&#34;&#34;Aide sequences of HydPy-L-Lake.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (QA, VQ, V)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake/llake_control.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake/llake_control.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import parametertools
</span><span class="hit">from hydpy.core import timetools
</span><span class="hit">from hydpy.core import objecttools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class N(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Anzahl Interpolationsstützstellen (number of nodes for the
</span><span class="noop">    interpolation between water state, volume and discharge) [-].
</span><span class="noop">
</span><span class="noop">    Parameter :class:`N` determines the length of all 1- and 2-dimensional
</span><span class="noop">    parameters of HydPy-L-Lake.  This requires that the value of
</span><span class="noop">    the respective :class:`N` instance is set before any of the values
</span><span class="noop">    of these 1- and 2-dimensional parameters are set.  Changing the
</span><span class="noop">    value of the :class:`N` instance necessitates setting their values
</span><span class="noop">    again.
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.llake import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; n(5)
</span><span class="noop">
</span><span class="noop">        For &#34;simple&#34; 1-dimensional parameters, the shape depends on the
</span><span class="noop">        value of :class:`N` only:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; w.shape
</span><span class="noop">        (5,)
</span><span class="noop">
</span><span class="noop">        For time varying parameters (derived from
</span><span class="noop">        :class:`~hydpy.core.parametertools.SeasonalParameter`), it also depends
</span><span class="noop">        on the defined number simulation steps per leap year:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; verzw.shape
</span><span class="noop">        (732,)
</span><span class="noop">        &gt;&gt;&gt; q.shape
</span><span class="noop">        (732, 5)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, int, None, (2, None)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="noop">        &#34;&#34;&#34;The prefered way to pass a value to :class:`N` instances
</span><span class="noop">        within parameter control files.  Sets the shape of the associated
</span><span class="noop">        1- and 2-dimensional parameter objects additionally.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        parametertools.SingleParameter.__call__(self, *args, **kwargs)
</span><span class="hit">        for (_name, subpars) in self.subpars.pars.model.parameters:
</span><span class="hit">            for (name, par) in subpars:
</span><span class="hit">                if name == &#39;toy&#39;:
</span><span class="hit">                    continue
</span><span class="hit">                elif par.NDIM == 1:
</span><span class="hit">                    if isinstance(par, parametertools.SeasonalParameter):
</span><span class="hit">                        par.shape = (0,)
</span><span class="noop">                    else:
</span><span class="hit">                        par.shape = self.value
</span><span class="hit">                elif ((par.NDIM == 2) and
</span><span class="noop">                      isinstance(par, parametertools.SeasonalParameter)):
</span><span class="hit">                    par.shape = (None, self.value)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class W(parametertools.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Wasserstand (water stage) [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class V(parametertools.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Wasservolumen bei vorgegebenem Wasserstand (water volume for a
</span><span class="noop">    given water stage) [m³].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Q(parametertools.SeasonalParameter):
</span><span class="noop">    &#34;&#34;&#34;Üblicher Seeausfluss bei vorgegebenem Wasserstand (sea outlet discharge
</span><span class="noop">    for a given water stage) [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 2, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MaxDT(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Maximale interne Rechenschrittweite (maximum of the internal step size)
</span><span class="noop">    [T].
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        Initialize a llake model and set different time step length for
</span><span class="noop">        parameterstep, simulationstep and maxdt:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.llake import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; maxdt(&#39;1h&#39;)
</span><span class="noop">
</span><span class="noop">        Internally, the value of maxdt is stored in seconds, but in string
</span><span class="noop">        representations it is shown as a :class:`~hydpy.core.timetools.Period`
</span><span class="noop">        string:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; maxdt.value
</span><span class="noop">        3600.0
</span><span class="noop">        &gt;&gt;&gt; maxdt
</span><span class="noop">        maxdt(&#39;1h&#39;)
</span><span class="noop">
</span><span class="noop">        Note that maxdt only defines the maximum internal step size, not the
</span><span class="noop">        one actually used.  Hence, maxdt is e.g. allowed to be larger than the
</span><span class="noop">        actual simulation step size:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; maxdt(&#39;2d&#39;)
</span><span class="noop">        &gt;&gt;&gt; maxdt
</span><span class="noop">        maxdt(&#39;2d&#39;)
</span><span class="noop">
</span><span class="noop">        It is allowed the set the number of seconds directly or modify it
</span><span class="noop">        by mathematical operations:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; maxdt.value = 60.
</span><span class="noop">        &gt;&gt;&gt; maxdt
</span><span class="noop">        maxdt(&#39;1m&#39;)
</span><span class="noop">        &gt;&gt;&gt; maxdt *= 120.
</span><span class="noop">        &gt;&gt;&gt; maxdt
</span><span class="noop">        maxdt(&#39;2h&#39;)
</span><span class="noop">
</span><span class="noop">        However, for the more secure way of calling the object trying to
</span><span class="noop">        pass an argument which cannot be converted to a Period instance
</span><span class="noop">        unambiguously results in an exception:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; maxdt(60.)
</span><span class="noop">        Traceback (most recent call last):
</span><span class="noop">        ...
</span><span class="noop">        ValueError: While trying the set the value of parameter `maxdt` of the lake model handled by element `?`, the following error occured: The supplied argument must be either an instance of `datetime.timedelta` or `str`.  The given arguments type is float. (An example: set `max dt` to 3600 seconds by writing `maxdt(&#34;1h&#34;))
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="hit">        try:
</span><span class="hit">            args = [timetools.Period(args[0]).seconds]
</span><span class="hit">        except BaseException:
</span><span class="hit">            objecttools.augmentexcmessage(
</span><span class="noop">                &#39;While trying the set the value of parameter `maxdt` &#39;
</span><span class="noop">                &#39;of the lake model handled by element `%s`&#39;
</span><span class="noop">                % objecttools.devicename(self),
</span><span class="noop">                &#39;(An example: set `max dt` to 3600 seconds by writing &#39;
</span><span class="noop">                &#39;`maxdt(&#34;1h&#34;))&#39;)
</span><span class="hit">        parametertools.SingleParameter.__call__(self, *args, **kwargs)
</span><span class="noop">
</span><span class="hit">    def __repr__(self):
</span><span class="hit">        try:
</span><span class="hit">            return &#34;%s(&#39;%s&#39;)&#34; % (self.name,
</span><span class="noop">                                 str(timetools.Period.fromseconds(self.value)))
</span><span class="miss">        except BaseException:
</span><span class="miss">            return &#39;%s(?)&#39; % self.name
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MaxDW(parametertools.SeasonalParameter):
</span><span class="noop">    &#34;&#34;&#34;Maximale Absenkgeschwindigkeit (maximum drop in water level) [m/T].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, True, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Verzw(parametertools.SeasonalParameter):
</span><span class="noop">    &#34;&#34;&#34;Zu- oder Abschlag des Seeausflusses (addition to or abstraction from
</span><span class="noop">    the seas outlet discharge) [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ControlParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Control parameters of HydPy-L-Lake, directly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (N, W, V, Q, MaxDT, MaxDW, Verzw)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake/llake_derived.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake/llake_derived.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy.core import parametertools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TOY(parametertools.IndexParameter):
</span><span class="noop">    &#34;&#34;&#34;References the &#34;global&#34; time of the year index array [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, int, None, (0, None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        self.setreference(pub.indexer.timeofyear)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Seconds(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Length of the actual simulation step size in seconds [s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        self.value = self.simulationstep.seconds
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class NmbSubsteps(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Number of the internal simulation steps [-].
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        Initialize a llake model and assume a simulation step size of 12 hours:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.llake import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">
</span><span class="noop">        If the maximum internal step size is also set to 12 hours, there is
</span><span class="noop">        only one internal calculation step per outer simulation step:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; maxdt(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; derived.nmbsubsteps.update()
</span><span class="noop">        &gt;&gt;&gt; derived.nmbsubsteps
</span><span class="noop">        nmbsubsteps(1)
</span><span class="noop">
</span><span class="noop">        Assigning smaller values to `maxdt` increases `nmbstepsize`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; maxdt(&#39;1h&#39;)
</span><span class="noop">        &gt;&gt;&gt; derived.nmbsubsteps.update()
</span><span class="noop">        &gt;&gt;&gt; derived.nmbsubsteps
</span><span class="noop">        nmbsubsteps(12)
</span><span class="noop">
</span><span class="noop">        In case the simulationstep is not a whole multiple of `dwmax`,
</span><span class="noop">        the value of `nmbsubsteps` is rounded up:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; maxdt(&#39;59m&#39;)
</span><span class="noop">        &gt;&gt;&gt; derived.nmbsubsteps.update()
</span><span class="noop">        &gt;&gt;&gt; derived.nmbsubsteps
</span><span class="noop">        nmbsubsteps(13)
</span><span class="noop">
</span><span class="noop">        Even for `maxdt` values exceeding the simulationstep, the value
</span><span class="noop">        of `numbsubsteps` does not become smaller than one:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; maxdt(&#39;2d&#39;)
</span><span class="noop">        &gt;&gt;&gt; derived.nmbsubsteps.update()
</span><span class="noop">        &gt;&gt;&gt; derived.nmbsubsteps
</span><span class="noop">        nmbsubsteps(1)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, int, None, (1, None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        maxdt = self.subpars.pars.control.maxdt
</span><span class="hit">        seconds = self.simulationstep.seconds
</span><span class="hit">        self.value = numpy.ceil(seconds/maxdt)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class VQ(parametertools.SeasonalParameter):
</span><span class="noop">    &#34;&#34;&#34;Hilfsterm (auxiliary term): math:VdtQ = 2 \\cdot + dt \\cdot Q` [m³].
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.llake import *
</span><span class="noop">    &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">    &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">    &gt;&gt;&gt; n(3)
</span><span class="noop">    &gt;&gt;&gt; v(0., 1e5, 1e6)
</span><span class="noop">    &gt;&gt;&gt; q(_1=[0., 1., 2.], _7=[0., 2., 5.])
</span><span class="noop">    &gt;&gt;&gt; maxdt(&#39;12h&#39;)
</span><span class="noop">    &gt;&gt;&gt; derived.seconds.update()
</span><span class="noop">    &gt;&gt;&gt; derived.nmbsubsteps.update()
</span><span class="noop">    &gt;&gt;&gt; derived.vq.update()
</span><span class="noop">    &gt;&gt;&gt; derived.vq
</span><span class="noop">    vq(toy_1_1_0_0_0=[0.0, 243200.0, 2086400.0],
</span><span class="noop">       toy_7_1_0_0_0=[0.0, 286400.0, 2216000.0])
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 2, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        con = self.subpars.pars.control
</span><span class="hit">        der = self.subpars
</span><span class="hit">        for (toy, qs) in con.q:
</span><span class="hit">            setattr(self, str(toy), 2.*con.v+der.seconds/der.nmbsubsteps*qs)
</span><span class="hit">        self.refresh()
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class DerivedParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Derived parameters of HydPy-L-Lake, indirectly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (TOY, Seconds, NmbSubsteps, VQ)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake/llake_fluxes.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake/llake_fluxes.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QZ(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Seezufluss (inflow into the lake) [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QA(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Seeausfluss (outflow from the lake) [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FluxSequences(sequencetools.FluxSequences):
</span><span class="noop">    &#34;&#34;&#34;Flux sequences of HydPy-L-Lake.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (QZ, QA)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake/llake_inlets.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake/llake_inlets.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Q(sequencetools.LinkSequence):
</span><span class="noop">    &#34;&#34;&#34;Abfluss (runoff) [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class InletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Upstream link sequences of HydPy-L-Lake.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Q,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake/llake_model.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake/llake_model.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
677 &nbsp;
678 &nbsp;
679 &nbsp;
680 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># imports...
</span><span class="noop"># ...standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import modeltools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def solve_dv_dt_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Solve the differential equation of HydPy-L.
</span><span class="noop">
</span><span class="noop">    At the moment, HydPy-L only implements a simple numerical solution of
</span><span class="noop">    its underlying ordinary differential equation.  To increase the accuracy
</span><span class="noop">    (or sometimes even to prevent instability) of this approximation, one
</span><span class="noop">    can set the value of parameter
</span><span class="noop">    :class:`~hydpy.models.llake.llake_control.MaxDT` to a value smaller than
</span><span class="noop">    the actual simulation step size.  Method :func:`solve_dv_dt_v1` then
</span><span class="noop">    applies the methods related to the numerical approximation multiple times
</span><span class="noop">    and aggregates the results.
</span><span class="noop">
</span><span class="noop">    Note that the order of convergence is onle only.  It is hard to tell how
</span><span class="noop">    short the internal simulation step needs to be to ensure a certain degree
</span><span class="noop">    of accuracy.  In most cases one hour or very often even one day should be
</span><span class="noop">    sufficient to gain acceptable results.  However, this strongly depends on
</span><span class="noop">    the given water stage-volume-discharge relationship.  Hence it seems
</span><span class="noop">    advisable to always define a few test waves and apply the llake model with
</span><span class="noop">    different :class:`~hydpy.models.llake.llake_control.MaxDT` values.
</span><span class="noop">    Afterwards, select a :class:`~hydpy.models.llake.llake_control.MaxDT`
</span><span class="noop">    value  lower than one which results in acceptable approximations for
</span><span class="noop">    all test waves.  The computation time of the llake mode per substep is
</span><span class="noop">    rather small, so always include a savety factor.
</span><span class="noop">
</span><span class="noop">    Of course, an adaptive step size determination would be much more
</span><span class="noop">    convenient...
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_derived.NmbSubsteps`
</span><span class="noop">
</span><span class="noop">    Used aide sequence:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_aides.V`
</span><span class="noop">      :class:`~hydpy.models.llake.llake_aides.QA`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_states.V`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_fluxes.QA`
</span><span class="noop">
</span><span class="noop">    Note that method :func:`solve_dv_dt_v1` calls the versions of `calc_vq`,
</span><span class="noop">    `interp_qa` and `calc_v_qa` selected by the respective application model.
</span><span class="noop">    Hence, also their parameter and sequence specifications need to be
</span><span class="noop">    considered.
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`\\frac{dV}{dt}= QZ - QA(V)`
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    old = self.sequences.states.fastaccess_old
</span><span class="hit">    new = self.sequences.states.fastaccess_new
</span><span class="hit">    aid = self.sequences.aides.fastaccess
</span><span class="hit">    flu.qa = 0.
</span><span class="hit">    aid.v = old.v
</span><span class="hit">    for i in range(der.nmbsubsteps):
</span><span class="hit">        self.calc_vq()
</span><span class="hit">        self.interp_qa()
</span><span class="hit">        self.calc_v_qa()
</span><span class="hit">        flu.qa += aid.qa
</span><span class="hit">    flu.qa /= der.nmbsubsteps
</span><span class="hit">    new.v = aid.v
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_vq_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the auxiliary term.
</span><span class="noop">
</span><span class="noop">    Required derived parameters:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_derived.Seconds`
</span><span class="noop">      :class:`~hydpy.models.llake.llake_derived.NmbSubsteps`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_fluxes.QZ`
</span><span class="noop">
</span><span class="noop">    Required aide sequence:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_aides.V`
</span><span class="noop">
</span><span class="noop">    Calculated aide sequence:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_aides.VQ`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`VQ = 2 \\cdot V + \\frac{Seconds}{NmbSubsteps} \\cdot QZ`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">
</span><span class="noop">        The following example shows that the auxiliary term `vq` does not
</span><span class="noop">        depend on the (outer) simulation step size but on the (inner)
</span><span class="noop">        calculation step size defined by parameter `maxdt`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.llake import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; maxdt(&#39;6h&#39;)
</span><span class="noop">        &gt;&gt;&gt; derived.seconds.update()
</span><span class="noop">        &gt;&gt;&gt; derived.nmbsubsteps.update()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qz = 2.
</span><span class="noop">        &gt;&gt;&gt; aides.v = 1e5
</span><span class="noop">        &gt;&gt;&gt; model.calc_vq_v1()
</span><span class="noop">        &gt;&gt;&gt; aides.vq
</span><span class="noop">        vq(243200.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    aid = self.sequences.aides.fastaccess
</span><span class="hit">    aid.vq = 2.*aid.v+der.seconds/der.nmbsubsteps*flu.qz
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def interp_qa_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the lake outflow based on linear interpolation.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_control.N`
</span><span class="noop">      :class:`~hydpy.models.llake.llake_control.Q`
</span><span class="noop">
</span><span class="noop">    Required derived parameters:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_derived.TOY`
</span><span class="noop">      :class:`~hydpy.models.llake.llake_derived.VQ`
</span><span class="noop">
</span><span class="noop">    Required aide sequence:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_aides.VQ`
</span><span class="noop">
</span><span class="noop">    Calculated aide sequence:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_aides.QA`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        In preparation for the following examples, define a short simulation
</span><span class="noop">        time period with a simulation step size of 12 hours and initialize
</span><span class="noop">        the required model object:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import pub
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.timetools import Timegrids, Timegrid
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids = Timegrids(Timegrid(&#39;2000.01.01&#39;,
</span><span class="noop">        ...                                    &#39;2000.01.04&#39;,
</span><span class="noop">        ...                                    &#39;12h&#39;))
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.llake import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">
</span><span class="noop">        Next, for the sake of brevity, define a test function:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; def test(*vqs):
</span><span class="noop">        ...     for vq in vqs:
</span><span class="noop">        ...         aides.vq(vq)
</span><span class="noop">        ...         model.interp_qa_v1()
</span><span class="noop">        ...         print(repr(aides.vq), repr(aides.qa))
</span><span class="noop">
</span><span class="noop">        The following three relationships between the auxiliary term `vq` and
</span><span class="noop">        the tabulated discharge `q` are taken as examples.  Each one is valid
</span><span class="noop">        for one of the first three days in January and is defined via five
</span><span class="noop">        nodes:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; n(5)
</span><span class="noop">        &gt;&gt;&gt; derived.toy.update()
</span><span class="noop">        &gt;&gt;&gt; derived.vq(_1_1_6=[0., 1., 2., 2., 3.],
</span><span class="noop">        ...            _1_2_6=[0., 1., 2., 2., 3.],
</span><span class="noop">        ...            _1_3_6=[0., 1., 2., 3., 4.])
</span><span class="noop">        &gt;&gt;&gt; q(_1_1_6=[0., 0., 0., 0., 0.],
</span><span class="noop">        ...   _1_2_6=[0., 2., 5., 6., 9.],
</span><span class="noop">        ...   _1_3_6=[0., 2., 1., 3., 2.])
</span><span class="noop">
</span><span class="noop">        In the first example, discharge does not depend on the actual value
</span><span class="noop">        of the auxiliary term and is always zero:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.idx_sim = pub.timegrids.init[&#39;2000.01.01&#39;]
</span><span class="noop">        &gt;&gt;&gt; test(0., .75, 1., 4./3., 2., 7./3., 3., 10./3.)
</span><span class="noop">        vq(0.0) qa(0.0)
</span><span class="noop">        vq(0.75) qa(0.0)
</span><span class="noop">        vq(1.0) qa(0.0)
</span><span class="noop">        vq(1.333333) qa(0.0)
</span><span class="noop">        vq(2.0) qa(0.0)
</span><span class="noop">        vq(2.333333) qa(0.0)
</span><span class="noop">        vq(3.0) qa(0.0)
</span><span class="noop">        vq(3.333333) qa(0.0)
</span><span class="noop">
</span><span class="noop">        The seconds example demonstrates that relationships are allowed to
</span><span class="noop">        contain jumps, which is the case for the (`vq`,`q`) pairs (2,6) and
</span><span class="noop">        (2,7).  Also it demonstrates that when the highest `vq` value is
</span><span class="noop">        exceeded linear extrapolation based on the two highest (`vq`,`q`)
</span><span class="noop">        pairs is performed:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.idx_sim = pub.timegrids.init[&#39;2000.01.02&#39;]
</span><span class="noop">        &gt;&gt;&gt; test(0., .75, 1., 4./3., 2., 7./3., 3., 10./3.)
</span><span class="noop">        vq(0.0) qa(0.0)
</span><span class="noop">        vq(0.75) qa(1.5)
</span><span class="noop">        vq(1.0) qa(2.0)
</span><span class="noop">        vq(1.333333) qa(3.0)
</span><span class="noop">        vq(2.0) qa(5.0)
</span><span class="noop">        vq(2.333333) qa(7.0)
</span><span class="noop">        vq(3.0) qa(9.0)
</span><span class="noop">        vq(3.333333) qa(10.0)
</span><span class="noop">
</span><span class="noop">        The third example shows that the relationships do not need to be
</span><span class="noop">        arranged monotonously increasing.  Particualarly for the extrapolation
</span><span class="noop">        range, this could result in negative values of `qa`, which is avoided
</span><span class="noop">        by setting it to zero in such cases:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.idx_sim = pub.timegrids.init[&#39;2000.01.03&#39;]
</span><span class="noop">        &gt;&gt;&gt; test(.5, 1.5, 2.5, 3.5, 4.5, 10.)
</span><span class="noop">        vq(0.5) qa(1.0)
</span><span class="noop">        vq(1.5) qa(1.5)
</span><span class="noop">        vq(2.5) qa(2.0)
</span><span class="noop">        vq(3.5) qa(2.5)
</span><span class="noop">        vq(4.5) qa(1.5)
</span><span class="noop">        vq(10.0) qa(0.0)
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    aid = self.sequences.aides.fastaccess
</span><span class="hit">    idx = der.toy[self.idx_sim]
</span><span class="hit">    for jdx in range(1, con.n):
</span><span class="hit">        if der.vq[idx, jdx] &gt;= aid.vq:
</span><span class="hit">            break
</span><span class="hit">    aid.qa = ((aid.vq-der.vq[idx, jdx-1]) *
</span><span class="noop">              (con.q[idx, jdx]-con.q[idx, jdx-1]) /
</span><span class="noop">              (der.vq[idx, jdx]-der.vq[idx, jdx-1]) +
</span><span class="noop">              con.q[idx, jdx-1])
</span><span class="hit">    aid.qa = max(aid.qa, 0.)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_v_qa_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Update the stored water volume based on the equation of continuity.
</span><span class="noop">
</span><span class="noop">    Note that for too high outflow values, which would result in overdraining
</span><span class="noop">    the lake, the outflow is trimmed.
</span><span class="noop">
</span><span class="noop">    Required derived parameters:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_derived.Seconds`
</span><span class="noop">      :class:`~hydpy.models.llake.llake_derived.NmbSubsteps`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_fluxes.QZ`
</span><span class="noop">
</span><span class="noop">    Updated aide sequences:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_aides.QA`
</span><span class="noop">      :class:`~hydpy.models.llake.llake_aides.V`
</span><span class="noop">
</span><span class="noop">    Basic Equation:
</span><span class="noop">      :math:`\\frac{dV}{dt}= QZ - QA`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        Prepare a lake model with an initial storage of 100.000 m³ and an
</span><span class="noop">        inflow of 2 m³/s and a (potential) outflow of 6 m³/s:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.llake import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; maxdt(&#39;6h&#39;)
</span><span class="noop">        &gt;&gt;&gt; derived.seconds.update()
</span><span class="noop">        &gt;&gt;&gt; derived.nmbsubsteps.update()
</span><span class="noop">        &gt;&gt;&gt; aides.v = 1e5
</span><span class="noop">        &gt;&gt;&gt; fluxes.qz = 2.
</span><span class="noop">        &gt;&gt;&gt; aides.qa = 6.
</span><span class="noop">
</span><span class="noop">        Through calling method `calc_v_qa_v1` three times with the same inflow
</span><span class="noop">        and outflow values, the storage is emptied after the second step and
</span><span class="noop">        outflow is equal to inflow after the third step:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.calc_v_qa_v1()
</span><span class="noop">        &gt;&gt;&gt; aides.v
</span><span class="noop">        v(13600.0)
</span><span class="noop">        &gt;&gt;&gt; aides.qa
</span><span class="noop">        qa(6.0)
</span><span class="noop">        &gt;&gt;&gt; model.new2old()
</span><span class="noop">        &gt;&gt;&gt; model.calc_v_qa_v1()
</span><span class="noop">        &gt;&gt;&gt; aides.v
</span><span class="noop">        v(0.0)
</span><span class="noop">        &gt;&gt;&gt; aides.qa
</span><span class="noop">        qa(2.62963)
</span><span class="noop">        &gt;&gt;&gt; model.new2old()
</span><span class="noop">        &gt;&gt;&gt; model.calc_v_qa_v1()
</span><span class="noop">        &gt;&gt;&gt; aides.v
</span><span class="noop">        v(0.0)
</span><span class="noop">        &gt;&gt;&gt; aides.qa
</span><span class="noop">        qa(2.0)
</span><span class="noop">
</span><span class="noop">        Note that the results of method :func:`calc_v_qa_v1` are not based
</span><span class="noop">        depend on the (outer) simulation step size but on the (inner)
</span><span class="noop">        calculation step size defined by parameter `maxdt`.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    aid = self.sequences.aides.fastaccess
</span><span class="hit">    aid.qa = min(aid.qa, flu.qz+der.nmbsubsteps/der.seconds*aid.v)
</span><span class="hit">    aid.v = max(aid.v+der.seconds/der.nmbsubsteps*(flu.qz-aid.qa), 0.)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def interp_w_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the actual water stage based on linear interpolation.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_control.N`
</span><span class="noop">      :class:`~hydpy.models.llake.llake_control.V`
</span><span class="noop">      :class:`~hydpy.models.llake.llake_control.W`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_states.V`
</span><span class="noop">
</span><span class="noop">    Calculated state sequence:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_states.W`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        Prepare a model object:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.llake import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">
</span><span class="noop">        For the sake of brevity, define a test function:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; def test(*vs):
</span><span class="noop">        ...     for v in vs:
</span><span class="noop">        ...         states.v.new = v
</span><span class="noop">        ...         model.interp_w_v1()
</span><span class="noop">        ...         print(repr(states.v), repr(states.w))
</span><span class="noop">
</span><span class="noop">        Define a simple `w`-`v` relationship consisting of three nodes and
</span><span class="noop">        calculate the water stages for different volumes:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; n(3)
</span><span class="noop">        &gt;&gt;&gt; v(0., 2., 4.)
</span><span class="noop">        &gt;&gt;&gt; w(-1., 1., 2.)
</span><span class="noop">
</span><span class="noop">        Perform the interpolation for a few test points:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; test(0., .5, 2., 3., 4., 5.)
</span><span class="noop">        v(0.0) w(-1.0)
</span><span class="noop">        v(0.5) w(-0.5)
</span><span class="noop">        v(2.0) w(1.0)
</span><span class="noop">        v(3.0) w(1.5)
</span><span class="noop">        v(4.0) w(2.0)
</span><span class="noop">        v(5.0) w(2.5)
</span><span class="noop">
</span><span class="noop">        The reference water stage of the relationship can be selected
</span><span class="noop">        arbitrarily.  Even negative water stages are returned, as is
</span><span class="noop">        demonstrated by the first two calculations.  For volumes outside
</span><span class="noop">        the range of the (`v`,`w`) pairs, the outer two highest pairs are
</span><span class="noop">        used for linear extrapolation.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    new = self.sequences.states.fastaccess_new
</span><span class="hit">    for jdx in range(1, con.n):
</span><span class="hit">        if con.v[jdx] &gt;= new.v:
</span><span class="hit">            break
</span><span class="hit">    new.w = ((new.v-con.v[jdx-1]) *
</span><span class="noop">             (con.w[jdx]-con.w[jdx-1]) /
</span><span class="noop">             (con.v[jdx]-con.v[jdx-1]) +
</span><span class="noop">             con.w[jdx-1])
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def interp_v_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the actual water volume based on linear interpolation.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_control.N`
</span><span class="noop">      :class:`~hydpy.models.llake.llake_control.V`
</span><span class="noop">      :class:`~hydpy.models.llake.llake_control.W`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_states.W`
</span><span class="noop">
</span><span class="noop">    Calculated state sequence:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_states.V`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        Prepare a model object:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.llake import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">
</span><span class="noop">        For the sake of brevity, define a test function:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; def test(*ws):
</span><span class="noop">        ...     for w in ws:
</span><span class="noop">        ...         states.w.new = w
</span><span class="noop">        ...         model.interp_v_v1()
</span><span class="noop">        ...         print(repr(states.w), repr(states.v))
</span><span class="noop">
</span><span class="noop">        Define a simple `v`-`w` relationship consisting of three nodes and
</span><span class="noop">        calculate the water stages for different volumes:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; n(3)
</span><span class="noop">        &gt;&gt;&gt; w(-1., 1., 2.)
</span><span class="noop">        &gt;&gt;&gt; v(0., 2., 4.)
</span><span class="noop">
</span><span class="noop">        Perform the interpolation for a few test points:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; test(-1., -.5, 1., 1.5, 2., 2.5)
</span><span class="noop">        w(-1.0) v(0.0)
</span><span class="noop">        w(-0.5) v(0.5)
</span><span class="noop">        w(1.0) v(2.0)
</span><span class="noop">        w(1.5) v(3.0)
</span><span class="noop">        w(2.0) v(4.0)
</span><span class="noop">        w(2.5) v(5.0)
</span><span class="noop">
</span><span class="noop">        The reference water stage of the relationship can be selected
</span><span class="noop">        arbitrarily, hence even the negative water contained in the given
</span><span class="noop">        example is allowed.  For volumes outside the range of the (`w`,`v`)
</span><span class="noop">        pairs, the outer two highest pairs are used for linear extrapolation.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    new = self.sequences.states.fastaccess_new
</span><span class="hit">    for jdx in range(1, con.n):
</span><span class="hit">        if con.w[jdx] &gt;= new.w:
</span><span class="hit">            break
</span><span class="hit">    new.v = ((new.w-con.w[jdx-1]) *
</span><span class="noop">             (con.v[jdx]-con.v[jdx-1]) /
</span><span class="noop">             (con.w[jdx]-con.w[jdx-1]) +
</span><span class="noop">             con.v[jdx-1])
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def corr_dw_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Adjust the water stage drop to the highest value allowed and correct
</span><span class="noop">    the associated fluxes.
</span><span class="noop">
</span><span class="noop">    Note that method :func:`corr_dw_v1` calls the method `interp_v` of the
</span><span class="noop">    respective application model.  Hence the requirements of the actual
</span><span class="noop">    `interp_v` need to be considered additionally.
</span><span class="noop">
</span><span class="noop">    Required control parameter:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_control.MaxDW`
</span><span class="noop">
</span><span class="noop">    Required derived parameters:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_derived.TOY`
</span><span class="noop">      :class:`~hydpy.models.llake.llake_derived.Seconds`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_fluxes.QZ`
</span><span class="noop">
</span><span class="noop">    Updated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_fluxes.QA`
</span><span class="noop">
</span><span class="noop">    Updated state sequences:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_states.W`
</span><span class="noop">      :class:`~hydpy.models.llake.llake_states.V`
</span><span class="noop">
</span><span class="noop">    Basic Restriction:
</span><span class="noop">      :math:`W_{old} - W_{new} \\leq MaxDW`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        In preparation for the following examples, define a short simulation
</span><span class="noop">        time period with a simulation step size of 12 hours and initialize
</span><span class="noop">        the required model object:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import pub
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.timetools import Timegrids, Timegrid
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids = Timegrids(Timegrid(&#39;2000.01.01&#39;,
</span><span class="noop">        ...                                    &#39;2000.01.04&#39;,
</span><span class="noop">        ...                                    &#39;12h&#39;))
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.llake import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; derived.toy.update()
</span><span class="noop">        &gt;&gt;&gt; derived.seconds.update()
</span><span class="noop">
</span><span class="noop">        Select the first half of the second day of January as the simulation
</span><span class="noop">        step relevant for the following examples:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.idx_sim = pub.timegrids.init[&#39;2000.01.02&#39;]
</span><span class="noop">
</span><span class="noop">        The following tests are based on method :func:`interp_v_v1` for the
</span><span class="noop">        interpolation of the stored water volume based on the corrected
</span><span class="noop">        water stage:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.interp_v = model.interp_v_v1
</span><span class="noop">
</span><span class="noop">        For the sake of simplicity, the underlying `w`-`v` relationship is
</span><span class="noop">        assumed to be linear:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; n(2.)
</span><span class="noop">        &gt;&gt;&gt; w(0., 1.)
</span><span class="noop">        &gt;&gt;&gt; v(0., 1e6)
</span><span class="noop">
</span><span class="noop">        The maximum drop in water stage for the first half of the second
</span><span class="noop">        day of January is set to 0.4 m/d.  Note that, due to the difference
</span><span class="noop">        between the parameter step size and the simulation step size, the
</span><span class="noop">        actual value used for calculation is 0.2 m/12h:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; maxdw(_1_1_18=.1,
</span><span class="noop">        ...       _1_2_6=.4,
</span><span class="noop">        ...       _1_2_18=.1)
</span><span class="noop">        &gt;&gt;&gt; maxdw
</span><span class="noop">        maxdw(toy_1_1_18_0_0=0.1,
</span><span class="noop">              toy_1_2_6_0_0=0.4,
</span><span class="noop">              toy_1_2_18_0_0=0.1)
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.objecttools import round_
</span><span class="noop">        &gt;&gt;&gt; round_(maxdw.value[2])
</span><span class="noop">        0.2
</span><span class="noop">
</span><span class="noop">        Define old and new water stages and volumes in agreement with the
</span><span class="noop">        given linear relationship:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.w.old = 1.
</span><span class="noop">        &gt;&gt;&gt; states.v.old = 1e6
</span><span class="noop">        &gt;&gt;&gt; states.w.new = .9
</span><span class="noop">        &gt;&gt;&gt; states.v.new = 9e5
</span><span class="noop">
</span><span class="noop">        Also define an inflow and an outflow value.  Note the that the latter
</span><span class="noop">        is set to zero, which is inconsistent with the actual water stage drop
</span><span class="noop">        defined above, but done for didactic reasons:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.qz = 1.
</span><span class="noop">        &gt;&gt;&gt; fluxes.qa = 0.
</span><span class="noop">
</span><span class="noop">        Calling the :func:`corr_dw_v1` method does not change the values of
</span><span class="noop">        either of following sequences, as the actual drop (0.1 m/12h) is
</span><span class="noop">        smaller than the allowed drop (0.2 m/12h):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.corr_dw_v1()
</span><span class="noop">        &gt;&gt;&gt; states.w
</span><span class="noop">        w(0.9)
</span><span class="noop">        &gt;&gt;&gt; states.v
</span><span class="noop">        v(900000.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qa
</span><span class="noop">        qa(0.0)
</span><span class="noop">
</span><span class="noop">        Note that the values given above are not recalculated, which can
</span><span class="noop">        clearly be seen for the lake outflow, which is still zero.
</span><span class="noop">
</span><span class="noop">        Through setting the new value of the water stage to 0.6 m, the actual
</span><span class="noop">        drop (0.4 m/12h) exceeds the allowed drop (0.2 m/12h). Hence the
</span><span class="noop">        water stage is trimmed and the other values are recalculated:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.w.new = .6
</span><span class="noop">        &gt;&gt;&gt; model.corr_dw_v1()
</span><span class="noop">        &gt;&gt;&gt; states.w
</span><span class="noop">        w(0.8)
</span><span class="noop">        &gt;&gt;&gt; states.v
</span><span class="noop">        v(800000.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qa
</span><span class="noop">        qa(5.62963)
</span><span class="noop">
</span><span class="noop">        Through setting the maximum water stage drop to zero, method
</span><span class="noop">        :func:`corr_dw_v1` is effectively disabled.  Regardless of the
</span><span class="noop">        actual change in water stage, no trimming or recalculating is
</span><span class="noop">        performed:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; maxdw.toy_01_02_06 = 0.
</span><span class="noop">        &gt;&gt;&gt; states.w.new = .6
</span><span class="noop">        &gt;&gt;&gt; model.corr_dw_v1()
</span><span class="noop">        &gt;&gt;&gt; states.w
</span><span class="noop">        w(0.6)
</span><span class="noop">        &gt;&gt;&gt; states.v
</span><span class="noop">        v(800000.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qa
</span><span class="noop">        qa(5.62963)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    old = self.sequences.states.fastaccess_old
</span><span class="hit">    new = self.sequences.states.fastaccess_new
</span><span class="hit">    idx = der.toy[self.idx_sim]
</span><span class="hit">    if (con.maxdw[idx] &gt; 0.) and ((old.w-new.w) &gt; con.maxdw[idx]):
</span><span class="hit">        new.w = old.w-con.maxdw[idx]
</span><span class="hit">        self.interp_v()
</span><span class="hit">        flu.qa = flu.qz+(old.v-new.v)/der.seconds
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def modify_qa_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Add water to or remove water from the calculated lake outflow.
</span><span class="noop">
</span><span class="noop">    Required control parameter:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_control.Verzw`
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_derived.TOY`
</span><span class="noop">
</span><span class="noop">    Updated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.llake.llake_fluxes.QA`
</span><span class="noop">
</span><span class="noop">    Basic Equation:
</span><span class="noop">      :math:`QA = QA* - Verzw`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        In preparation for the following examples, define a short simulation
</span><span class="noop">        time period with a simulation step size of 12 hours and initialize
</span><span class="noop">        the required model object:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import pub
</span><span class="noop">        &gt;&gt;&gt; from hydpy.core.timetools import Timegrids, Timegrid
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids = Timegrids(Timegrid(&#39;2000.01.01&#39;,
</span><span class="noop">        ...                                    &#39;2000.01.04&#39;,
</span><span class="noop">        ...                                    &#39;12h&#39;))
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.llake import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; derived.toy.update()
</span><span class="noop">
</span><span class="noop">        Select the first half of the second day of January as the simulation
</span><span class="noop">        step relevant for the following examples:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.idx_sim = pub.timegrids.init[&#39;2000.01.02&#39;]
</span><span class="noop">
</span><span class="noop">        Assume that, in accordance with previous calculations, the original
</span><span class="noop">        outflow value is 3 m³/s:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.qa = 3.
</span><span class="noop">
</span><span class="noop">        Prepare the shape of parameter `verzw` (usually, this is done
</span><span class="noop">        automatically when calling parameter `n`):
</span><span class="noop">        &gt;&gt;&gt; verzw.shape = (None,)
</span><span class="noop">
</span><span class="noop">        Set the value of the abstraction on the first half of the second
</span><span class="noop">        day of January to 2 m³/s:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; verzw(_1_1_18=0.,
</span><span class="noop">        ...       _1_2_6=2.,
</span><span class="noop">        ...       _1_2_18=0.)
</span><span class="noop">
</span><span class="noop">        In the first example `verzw` is simply subtracted from `qa`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.modify_qa_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qa
</span><span class="noop">        qa(1.0)
</span><span class="noop">
</span><span class="noop">        In the second example `verzw` exceeds `qa`, resulting in a zero
</span><span class="noop">        outflow value:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.modify_qa_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qa
</span><span class="noop">        qa(0.0)
</span><span class="noop">
</span><span class="noop">        The last example demonstrates, that &#34;negative abstractions&#34; are
</span><span class="noop">        allowed, resulting in an increase in simulated outflow:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; verzw.toy_1_2_6 = -2.
</span><span class="noop">        &gt;&gt;&gt; model.modify_qa_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qa
</span><span class="noop">        qa(2.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    idx = der.toy[self.idx_sim]
</span><span class="hit">    flu.qa = max(flu.qa-con.verzw[idx], 0.)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def update_inlets_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Update the inlet link sequence.&#34;&#34;&#34;
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    inl = self.sequences.inlets.fastaccess
</span><span class="hit">    flu.qz = 0.
</span><span class="hit">    for idx in range(inl.len_q):
</span><span class="hit">        flu.qz += inl.q[idx][0]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def update_outlets_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Update the outlet link sequence.&#34;&#34;&#34;
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    out = self.sequences.outlets.fastaccess
</span><span class="hit">    out.q[0] += flu.qa
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Model(modeltools.Model):
</span><span class="noop">    &#34;&#34;&#34;Base model for HydPy-L-Lake.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    _RUNMETHODS = (update_inlets_v1,
</span><span class="noop">                   solve_dv_dt_v1,
</span><span class="noop">                   interp_w_v1,
</span><span class="noop">                   corr_dw_v1,
</span><span class="noop">                   modify_qa_v1,
</span><span class="noop">                   update_outlets_v1)
</span><span class="hit">    _ADDMETHODS = (interp_v_v1,
</span><span class="noop">                   calc_vq_v1,
</span><span class="noop">                   interp_qa_v1,
</span><span class="noop">                   calc_v_qa_v1)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake/llake_outlets.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake/llake_outlets.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Q(sequencetools.LinkSequence):
</span><span class="noop">    &#34;&#34;&#34;Abfluss (runoff) [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class OutletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Downstream link sequences of HydPy-L-Lake.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Q,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake/llake_states.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/llake/llake_states.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class V(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Wasservolumen (water volume) [m³].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class W(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Wasserstand (water stage) [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class StateSequences(sequencetools.StateSequences):
</span><span class="noop">    &#34;&#34;&#34;State sequences of HydPy-L-Lake.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (V, W)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/__init__.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/__init__.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;
</span><span class="noop">The L-Land model is the core of the HydPy implementation of the
</span><span class="noop">LARSIM model.  It consists of routines for the preparation
</span><span class="noop">of meteorological input, the calculation of potential evaporation,
</span><span class="noop">the simulation of water stored on plants, in the snow layer and in the
</span><span class="noop">soil, as well as runoff concentration.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core.modelimports import *
</span><span class="noop"># ...from lland
</span><span class="hit">from hydpy.models.lland.lland_constants import (SIED_D, SIED_L, VERS, ACKER,
</span><span class="noop">                                                WEINB, OBSTB, BODEN, GLETS,
</span><span class="noop">                                                GRUE_I, FEUCHT, GRUE_E, BAUMB,
</span><span class="noop">                                                NADELW, LAUBW, MISCHW, WASSER)
</span><span class="hit">from hydpy.models.lland.lland_parameters import Parameters
</span><span class="hit">from hydpy.models.lland.lland_control import ControlParameters
</span><span class="hit">from hydpy.models.lland.lland_derived import DerivedParameters
</span><span class="hit">from hydpy.models.lland.lland_inputs import InputSequences
</span><span class="hit">from hydpy.models.lland.lland_fluxes import FluxSequences
</span><span class="hit">from hydpy.models.lland.lland_states import StateSequences
</span><span class="hit">from hydpy.models.lland.lland_aides import AideSequences
</span><span class="hit">from hydpy.models.lland.lland_outlets import OutletSequences
</span><span class="hit">from hydpy.models.lland.lland_model import Model
</span><span class="noop">
</span><span class="hit">autodoc_basemodel()
</span><span class="hit">tester = Tester()
</span><span class="hit">cythonizer = Cythonizer()
</span><span class="hit">cythonizer.complete()
</span><span class="noop">
</span><span class="noop">
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_aides.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_aides.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Temp(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Temporary variable used in different methods [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class SfA(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Sättigungsflächen-Aktivität (activity of the saturated surface) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Exz(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Bodenfeuchteüberschuss (excess of soil water) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class BVl(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Berechneter Bodenwasserverlust (calculated amount of water that should
</span><span class="noop">    be released from the soil) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MVl(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Möglicher Bodenwasserverlust (maximum amount of water released that can
</span><span class="noop">    be released from the soil) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RVl(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Relation von MVl und BVl (ratio of MVl and BVl) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class EPW(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Potenzielle Evaporation/Evapotranspiration von Wasserflächen (potential
</span><span class="noop">    evaporation/evapotranspiration combined from all water areas) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class AideSequences(sequencetools.AideSequences):
</span><span class="noop">    &#34;&#34;&#34;Aide sequences of the HydPy-L-Land model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Temp, SfA, Exz, BVl, MVl, RVl, EPW)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_constants.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_constants.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;The HydPy-L-Land model (`lland`) allows for the subdivision of subbasins
</span><span class="noop">into hydrological response units (hru).  Some processes, e.g. interception,
</span><span class="noop">are calculated seperately for each zone.  This is why some parameters (e.g.
</span><span class="noop">the usable field capacity :class:`~hydpy.models.lland.lland_control.NFk`)
</span><span class="noop">and some sequences (e.g. the actual soil water storage
</span><span class="noop">:class:`~hydpy.models.lland.lland_states.BoWa`) are 1-dimensional.  Each entry
</span><span class="noop">represents the value of a different hru.
</span><span class="noop">
</span><span class="noop">In contrasts to the original LARSIM model, the HydPy-L-Land model allows for
</span><span class="noop">arbitrary definitions of units.  Nevertheless, the original distinction
</span><span class="noop">in accordance with sixteen different landuse types is still supported.  The
</span><span class="noop">parameter :class:`~hydpy.models.lland.lland_control.Lnk` defines,
</span><span class="noop">which entry of e.g. :class:`~hydpy.models.lland.lland_control.NFk` is
</span><span class="noop">related to which land use type via integer values.  Note that for the units
</span><span class="noop">of the most land use types, the same equations are applied. Only units
</span><span class="noop">of type `VERS` and `WASSER` are partly connected to different process
</span><span class="noop">equations.
</span><span class="noop">
</span><span class="noop">For comprehensibility, this module introduces the relevant integer constants.
</span><span class="noop">Through performing a wildcard import
</span><span class="noop">
</span><span class="noop">&gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">
</span><span class="noop">these are available in your local namespace:
</span><span class="noop">
</span><span class="noop">&gt;&gt;&gt; (SIED_D, SIED_L, VERS, ACKER, WEINB, OBSTB, BODEN, GLETS, GRUE_I,
</span><span class="noop">...  FEUCHT, GRUE_E, BAUMB, NADELW, LAUBW, MISCHW, WASSER)
</span><span class="noop">(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">SIED_D = 1
</span><span class="noop">&#34;&#34;&#34;Constant for `Siedlung, dicht` (settlement, dense).&#34;&#34;&#34;
</span><span class="hit">SIED_L = 2
</span><span class="noop">&#34;&#34;&#34;Constant for `Siedlung, locker` (settlement, light).&#34;&#34;&#34;
</span><span class="hit">VERS = 3
</span><span class="noop">&#34;&#34;&#34;Constant for `versiegelt` (sealed).&#34;&#34;&#34;
</span><span class="hit">ACKER = 4
</span><span class="noop">&#34;&#34;&#34;Constant for `Acker` (fields).&#34;&#34;&#34;
</span><span class="hit">WEINB = 5
</span><span class="noop">&#34;&#34;&#34;Constant for `Weinbau` (viniculture).&#34;&#34;&#34;
</span><span class="hit">OBSTB = 6
</span><span class="noop">&#34;&#34;&#34;Constant for `Obstbau` (intensive orchards).&#34;&#34;&#34;
</span><span class="hit">BODEN = 7
</span><span class="noop">&#34;&#34;&#34;Constant for `unbewachsener Boden` (unsealed soil, not overgrown).&#34;&#34;&#34;
</span><span class="hit">GLETS = 8
</span><span class="noop">&#34;&#34;&#34;Constant for `Gletscher` (`glacier`).&#34;&#34;&#34;
</span><span class="hit">GRUE_I = 9
</span><span class="noop">&#34;&#34;&#34;Constant for `Grünland, intensiv` (intensive pasture).&#34;&#34;&#34;
</span><span class="hit">FEUCHT = 10
</span><span class="noop">&#34;&#34;&#34;Constant for `Feuchtflächen` (wetlands).&#34;&#34;&#34;
</span><span class="hit">GRUE_E = 11
</span><span class="noop">&#34;&#34;&#34;Constant for `Grünland, extensiv` (extensive pasture).&#34;&#34;&#34;
</span><span class="hit">BAUMB = 12
</span><span class="noop">&#34;&#34;&#34;Constant for `lockerer Baumbestand` (sparsely populated forest).&#34;&#34;&#34;
</span><span class="hit">NADELW = 13
</span><span class="noop">&#34;&#34;&#34;Constant for `Nadelwald` (coniferous forest).&#34;&#34;&#34;
</span><span class="hit">LAUBW = 14
</span><span class="noop">&#34;&#34;&#34;Constant for `Laubwald` (deciduous forest).&#34;&#34;&#34;
</span><span class="hit">MISCHW = 15
</span><span class="noop">&#34;&#34;&#34;Constant for `Mischwald` (mixed forest).&#34;&#34;&#34;
</span><span class="hit">WASSER = 16
</span><span class="noop">&#34;&#34;&#34;Constant for `Wasser` (water).&#34;&#34;&#34;
</span><span class="hit">CONSTANTS = {key: value for key, value in locals().items()
</span><span class="noop">             if (key.isupper() and isinstance(value, int))}
</span><span class="hit">&#34;&#34;&#34;Dictionary containing all constants defined by HydPy-L-Land.&#34;&#34;&#34;
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_control.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_control.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
677 &nbsp;
678 &nbsp;
679 &nbsp;
680 &nbsp;
681 &nbsp;
682 &nbsp;
683 &nbsp;
684 &nbsp;
685 &nbsp;
686 &nbsp;
687 &nbsp;
688 &nbsp;
689 &nbsp;
690 &nbsp;
691 &nbsp;
692 &nbsp;
693 &nbsp;
694 &nbsp;
695 &nbsp;
696 &nbsp;
697 &nbsp;
698 &nbsp;
699 &nbsp;
700 &nbsp;
701 &nbsp;
702 &nbsp;
703 &nbsp;
704 &nbsp;
705 &nbsp;
706 &nbsp;
707 &nbsp;
708 &nbsp;
709 &nbsp;
710 &nbsp;
711 &nbsp;
712 &nbsp;
713 &nbsp;
714 &nbsp;
715 &nbsp;
716 &nbsp;
717 &nbsp;
718 &nbsp;
719 &nbsp;
720 &nbsp;
721 &nbsp;
722 &nbsp;
723 &nbsp;
724 &nbsp;
725 &nbsp;
726 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="hit">import warnings
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import parametertools
</span><span class="hit">from hydpy.core import objecttools
</span><span class="hit">from hydpy.core import timetools
</span><span class="noop"># ...model specific
</span><span class="hit">from hydpy.models.lland import lland_constants
</span><span class="hit">from hydpy.models.lland import lland_parameters
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FT(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Teileinzugsgebietsfläche (subbasin area) [km²].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (1e-10, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class NHRU(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Anzahl der Hydrotope (number of hydrological response units) [-].
</span><span class="noop">
</span><span class="noop">    Note that :class:`NHRU` determines the length of most 1-dimensional
</span><span class="noop">    HydPy-L-Land parameters and sequences.  This required that the value of
</span><span class="noop">    the respective :class:`NHRU` instance is set before any of the values
</span><span class="noop">    of these 1-dimensional parameters or sequences are set.  Changing the
</span><span class="noop">    value of the :class:`NHRU` instance necessitates setting their values
</span><span class="noop">    again.
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(5)
</span><span class="noop">        &gt;&gt;&gt; control.kg.shape
</span><span class="noop">        (5,)
</span><span class="noop">        &gt;&gt;&gt; fluxes.tkor.shape
</span><span class="noop">        (5,)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, int, None, (1, None)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="noop">        &#34;&#34;&#34;The prefered way to pass a value to :class:`NHRU` instances
</span><span class="noop">        within parameter control files.  Sets the shape of the associated
</span><span class="noop">        1-dimensional parameter and sequence objects additionally.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        parametertools.SingleParameter.__call__(self, *args, **kwargs)
</span><span class="hit">        for (_name, subpars) in self.subpars.pars.model.parameters:
</span><span class="hit">            for (name, par) in subpars:
</span><span class="hit">                if par.NDIM == 1:
</span><span class="hit">                    par.shape = self.value
</span><span class="hit">        for (_name, subseqs) in self.subpars.pars.model.sequences:
</span><span class="hit">            for (name, seq) in subseqs:
</span><span class="hit">                if (seq.NDIM == 1) and (seq.name != &#39;moy&#39;):
</span><span class="hit">                    seq.shape = self.value
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FHRU(lland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Flächenanteile der Hydrotope (area percentages of the respective
</span><span class="noop">    HRUs) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., 1.)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Lnk(lland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Landnutzungsklasse (land use class) [-].
</span><span class="noop">
</span><span class="noop">    For increasing legibility, the HydPy-L-Land constants are used for string
</span><span class="noop">    representions of :class:`Lnk` instances:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">    &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">    &gt;&gt;&gt; nhru(4)
</span><span class="noop">    &gt;&gt;&gt; lnk(ACKER, ACKER, WASSER, MISCHW)
</span><span class="noop">    &gt;&gt;&gt; lnk.values
</span><span class="noop">    array([ 4,  4, 16, 15])
</span><span class="noop">    &gt;&gt;&gt; lnk
</span><span class="noop">    lnk(ACKER, ACKER, WASSER, MISCHW)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME = 1, int, None
</span><span class="hit">    SPAN = (min(lland_constants.CONSTANTS.values()),
</span><span class="noop">            max(lland_constants.CONSTANTS.values()))
</span><span class="noop">
</span><span class="hit">    def compressrepr(self):
</span><span class="noop">        &#34;&#34;&#34;Returns a list which contains a string representation with land
</span><span class="noop">        uses beeing defined by the constants
</span><span class="noop">        :const:`~hydpy.models.lland.lland_constants.SIED_D`,
</span><span class="noop">        :const:`~hydpy.models.lland.lland_constants.SIED_L`...
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        invmap = {value: key for key, value in
</span><span class="noop">                  lland_constants.CONSTANTS.items()}
</span><span class="hit">        return [&#39;, &#39;.join(invmap.get(value, repr(value))
</span><span class="noop">                          for value in self.values)]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class HNN(lland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Höhe über Normal-Null (height above sea level) [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class KG(lland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Niederschlagskorrekturfaktor (adjustment factor for precipitation)
</span><span class="noop">    [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class KT(lland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Temperaturkorrektursummand (adjustment summand for air temperature)
</span><span class="noop">    [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class KE(lland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Grasreferenzverdunstungskorrekturfaktor (adjustment factor for
</span><span class="noop">    reference evapotranspiration) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, True, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class KF(lland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Küstenfaktor (&#34;coast factor&#34; of Turc-Wendling&#39;s evaporation equation
</span><span class="noop">    [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (.6, 1.)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FLn(lland_parameters.LanduseMonthParameter):
</span><span class="noop">    &#34;&#34;&#34;Landnutzungsabhängiger Verdunstungsfaktor (factor for adjusting
</span><span class="noop">    reference evapotranspiration to different land use classes) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 2, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class HInz(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Interzeptionskapazität bezogen auf die Blattoberfläche (interception
</span><span class="noop">    capacity normalized to the leaf surface area) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class LAI(lland_parameters.LanduseMonthParameter):
</span><span class="noop">    &#34;&#34;&#34;Blattflächenindex (leaf area index) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 2, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TRefT(lland_parameters.MultiParameterLand):
</span><span class="noop">    &#34;&#34;&#34;Lufttemperaturgrenzwert des grundlegenden Grad-Tag-Verfahrens
</span><span class="noop">    (air temperature threshold of the degree-day method) [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TRefN(lland_parameters.MultiParameterLand):
</span><span class="noop">    &#34;&#34;&#34;Niederschlagstemperaturgrenzwert des erweiterten Grad-Tag-Verfahrens
</span><span class="noop">    (precipitation temperature threshold of the degree-day method) [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TGr(lland_parameters.MultiParameterLand):
</span><span class="noop">    &#34;&#34;&#34;Temperaturgrenzwert flüssiger/fester Niederschlag (threshold
</span><span class="noop">    temperature liquid/frozen precipitation) [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TSp(lland_parameters.MultiParameterLand):
</span><span class="noop">    &#34;&#34;&#34;Temperaturspanne flüssiger/fester Niederschlag (temperature range
</span><span class="noop">    with mixed precipitation) [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="hit">    INIT = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class GTF(lland_parameters.MultiParameterLand):
</span><span class="noop">    &#34;&#34;&#34;Grad-Tag-Faktor (factor of the degree-day method) [mm/°C/T].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, True, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RSchmelz(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Spezifische Schmelzwärme von Wasser (specific melt heat of water)
</span><span class="noop">    [J/g].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="hit">    INIT = 334.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class CPWasser(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Spezifische Wärmekapazität von Wasser (specific heat capacity of water)
</span><span class="noop">    [J/g].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="hit">    INIT = 4.1868
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class PWMax(lland_parameters.MultiParameterLand):
</span><span class="noop">    &#34;&#34;&#34;Maximalverhältnis Gesamt- zu Trockenschnee (maximum ratio of the
</span><span class="noop">    total and the frozen water equivalent stored in the snow cover) [-].
</span><span class="noop">
</span><span class="noop">    In addition to the :class:`parametertools.SingleParameter` call method, it
</span><span class="noop">    is possible to set the value of parameter :class:`PWMax` in accordance to
</span><span class="noop">    the keyword arguments `rhot0` and `rhodkrit`.
</span><span class="noop">
</span><span class="noop">    Basic Equation:
</span><span class="noop">        :math:`PWMax = \\frac{1.474 \\cdot rhodkrit}
</span><span class="noop">        {rhot0 + 0.474 \\cdot rhodkrit}`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">        Using the common values for both rhot0 and rhodkrit...
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; nhru(1)
</span><span class="noop">        &gt;&gt;&gt; lnk(ACKER)
</span><span class="noop">        &gt;&gt;&gt; pwmax(rhot0=0.2345, rhodkrit=0.42)
</span><span class="noop">
</span><span class="noop">        ...leads to,...
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; pwmax
</span><span class="noop">        pwmax(1.427833)
</span><span class="noop">
</span><span class="noop">        This is also the default value of :class:`PWMax` and means that
</span><span class="noop">        the proportion of the liquid water in the snow cover cannot go
</span><span class="noop">        above 30%.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (1., None)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="noop">        &#34;&#34;&#34;The prefered way to pass values to :class:`PWMax` instances
</span><span class="noop">        within parameter control files.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            lland_parameters.MultiParameterLand.__call__(self, *args, **kwargs)
</span><span class="hit">        except NotImplementedError:
</span><span class="hit">            counter = (&#39;rhot0&#39; in kwargs) + (&#39;rhodkrit&#39; in kwargs)
</span><span class="hit">            if counter == 0:
</span><span class="miss">                raise ValueError(&#39;For parameter `pwmax` a value can be set &#39;
</span><span class="noop">                                 &#39;directly by passing a single value or &#39;
</span><span class="noop">                                 &#39;indirectly by using the keyword arguments &#39;
</span><span class="noop">                                 &#39;`rhot0` and `rhodkrit`.&#39;)
</span><span class="hit">            elif counter == 1:
</span><span class="miss">                raise ValueError(&#39;For the alternative calculation of &#39;
</span><span class="noop">                                 &#39;parameter `pwmax`, values for both keyword &#39;
</span><span class="noop">                                 &#39;keyword arguments `rhot0` and `rhodkrit` &#39;
</span><span class="noop">                                 &#39;must be given.&#39;)
</span><span class="noop">            else:
</span><span class="hit">                rhot0 = float(kwargs[&#39;rhot0&#39;])
</span><span class="hit">                rhodkrit = float(kwargs[&#39;rhodkrit&#39;])
</span><span class="hit">                self(1.474*rhodkrit/(rhot0+0.474*rhodkrit))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class GrasRef_R(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Bodenfeuchte-Verdunstung-Parameter (soil moisture dependend
</span><span class="noop">    evaporation factor) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class NFk(lland_parameters.MultiParameterSoil):
</span><span class="noop">    &#34;&#34;&#34;Nutzbare Feldkapazität (usable field capacity) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RelWZ(lland_parameters.MultiParameterSoil):
</span><span class="noop">    &#34;&#34;&#34;Relative Mindestbodenfeuchte für die Interflowentstehung (threshold
</span><span class="noop">       value of relative soil moisture for interflow generation) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (None, 1.)
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="noop">        &#34;&#34;&#34;Trim upper values in accordance with :math:`RelWB \\leq RelWZ`.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(3)
</span><span class="noop">        &gt;&gt;&gt; relwb.values = .5
</span><span class="noop">        &gt;&gt;&gt; relwz(0.2, .5, .8)
</span><span class="noop">        &gt;&gt;&gt; relwz
</span><span class="noop">        relwz(0.5, 0.5, 0.8)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        relwb = self.subpars.relwb.value
</span><span class="hit">        if (lower is None) and (relwb is not None):
</span><span class="hit">            lower = relwb
</span><span class="hit">        lland_parameters.MultiParameterSoil.trim(self, lower, upper)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RelWB(lland_parameters.MultiParameterSoil):
</span><span class="noop">    &#34;&#34;&#34;Relative Mindestbodenfeuchte für die Basisabflussentstehung (threshold
</span><span class="noop">       value of relative soil moisture for base flow generation) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="noop">        &#34;&#34;&#34;Trim upper values in accordance with :math:`RelWB \\leq RelWZ`.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(3)
</span><span class="noop">        &gt;&gt;&gt; relwz.values = .5
</span><span class="noop">        &gt;&gt;&gt; relwb(0.2, .5, .8)
</span><span class="noop">        &gt;&gt;&gt; relwb
</span><span class="noop">        relwb(0.2, 0.5, 0.5)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        relwz = self.subpars.relwz.value
</span><span class="hit">        if (upper is None) and (relwz is not None):
</span><span class="hit">            upper = relwz
</span><span class="hit">        lland_parameters.MultiParameterSoil.trim(self, lower, upper)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Beta(lland_parameters.MultiParameterSoil):
</span><span class="noop">    &#34;&#34;&#34;Drainageindex des tiefen Bodenspeichers (storage coefficient for
</span><span class="noop">    releasing base flow from the lower soil compartment) [1/T].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, True, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FBeta(lland_parameters.MultiParameterSoil):
</span><span class="noop">    &#34;&#34;&#34;Faktor zur Erhöhung der Perkolation im Grobporenbereich (factor for
</span><span class="noop">    increasing percolation under wet conditions) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (1., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class DMin(lland_parameters.MultiParameterSoil):
</span><span class="noop">    &#34;&#34;&#34;Drainageindex des mittleren Bodenspeichers (flux rate for
</span><span class="noop">    releasing interflow from the middle soil compartment) [mm/T].
</span><span class="noop">
</span><span class="noop">    In addition to the :class:`parametertools.MultiParameterSoil` call method,
</span><span class="noop">    it is possible to set the value of parameter :class:`DMin` in accordance
</span><span class="noop">    to the keyword argument `r_dmin` due to compatibility reasons with the
</span><span class="noop">    original LARSIM implemetation.
</span><span class="noop">
</span><span class="noop">    Basic Equation:
</span><span class="noop">        :math:`Dmin = 0.024192 \\cdot r_dmin`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(1)
</span><span class="noop">        &gt;&gt;&gt; lnk(ACKER)
</span><span class="noop">        &gt;&gt;&gt; dmax(10.) # to prevent trimming of dmin, see below
</span><span class="noop">        &gt;&gt;&gt; dmin(r_dmin=10.)
</span><span class="noop">        &gt;&gt;&gt; dmin
</span><span class="noop">        dmin(0.24192)
</span><span class="noop">
</span><span class="noop">        Note the additional dependence of the parameter value on the
</span><span class="noop">        relation between the `parameterstep` and the actual `simulationstep`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; dmin.values
</span><span class="noop">        array([ 0.12096])
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, True, (0., None)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="noop">        &#34;&#34;&#34;The prefered way to pass values to :class:`DMin` instances
</span><span class="noop">        within parameter control files.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            lland_parameters.MultiParameterSoil.__call__(self, *args, **kwargs)
</span><span class="hit">        except NotImplementedError:
</span><span class="hit">            args = kwargs.get(&#39;r_dmin&#39;)
</span><span class="hit">            if args is not None:
</span><span class="hit">                self.values = 0.024192*self.applytimefactor(numpy.array(args))
</span><span class="hit">                self.trim()
</span><span class="noop">            else:
</span><span class="miss">                objecttools.augmentexcmessage()
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="noop">        &#34;&#34;&#34;Trim upper values in accordance with :math:`DMin \\leq DMax`.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(5)
</span><span class="noop">        &gt;&gt;&gt; dmax.values = 2.
</span><span class="noop">        &gt;&gt;&gt; dmin(-2., 0., 2., 4., 6.)
</span><span class="noop">        &gt;&gt;&gt; dmin
</span><span class="noop">        dmin(0.0, 0.0, 2.0, 4.0, 4.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if upper is None:
</span><span class="hit">            upper = self.subpars.dmax
</span><span class="hit">        lland_parameters.MultiParameterSoil.trim(self, lower, upper)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class DMax(lland_parameters.MultiParameterSoil):
</span><span class="noop">    &#34;&#34;&#34;Drainageindex des oberen Bodenspeichers (additional flux rate for
</span><span class="noop">    releasing interflow from the upper soil compartment) [mm/T].
</span><span class="noop">
</span><span class="noop">    In addition to the :class:`parametertools.MultiParameterSoil` call method,
</span><span class="noop">    it is possible to set the value of parameter :class:`DMax` in accordance
</span><span class="noop">    to the keyword argument `r_dmax` due to compatibility reasons with the
</span><span class="noop">    original LARSIM implemetation.
</span><span class="noop">
</span><span class="noop">    Basic Equation:
</span><span class="noop">        :math:`Dmax = 2.4192 \\cdot r_dmax`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(1)
</span><span class="noop">        &gt;&gt;&gt; lnk(ACKER)
</span><span class="noop">        &gt;&gt;&gt; dmin(0.) # to prevent trimming of dmax, see below
</span><span class="noop">        &gt;&gt;&gt; dmax(r_dmax=10.)
</span><span class="noop">        &gt;&gt;&gt; dmax
</span><span class="noop">        dmax(24.192)
</span><span class="noop">
</span><span class="noop">        Note the additional dependence of the parameter value on the
</span><span class="noop">        relation between the `parameterstep` and the actual `simulationstep`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; dmax.values
</span><span class="noop">        array([ 12.096])
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, True, (None, None)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="noop">        &#34;&#34;&#34;The prefered way to pass values to :class:`DMin` instances
</span><span class="noop">        within parameter control files.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            lland_parameters.MultiParameterSoil.__call__(self, *args, **kwargs)
</span><span class="hit">        except NotImplementedError:
</span><span class="hit">            args = kwargs.get(&#39;r_dmax&#39;)
</span><span class="hit">            if args is not None:
</span><span class="hit">                self.values = 2.4192*self.applytimefactor(numpy.array(args))
</span><span class="hit">                self.trim()
</span><span class="noop">            else:
</span><span class="miss">                objecttools.augmentexcmessage()
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="noop">        &#34;&#34;&#34;Trim upper values in accordance with :math:`DMax \\geq DMin`.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(3)
</span><span class="noop">        &gt;&gt;&gt; dmin.values = 2.
</span><span class="noop">        &gt;&gt;&gt; dmax(2., 4., 6.)
</span><span class="noop">        &gt;&gt;&gt; dmax
</span><span class="noop">        dmax(4.0, 4.0, 6.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if lower is None:
</span><span class="hit">            lower = self.subpars.dmin
</span><span class="hit">        lland_parameters.MultiParameterSoil.trim(self, lower, upper)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class BSf(lland_parameters.MultiParameterSoil):
</span><span class="noop">    &#34;&#34;&#34;Bodenfeuchte-Sättigungsfläche-Parameter (shape parameter for the
</span><span class="noop">    relation between the avarage soil moisture and the relative saturated
</span><span class="noop">    area of a subbasin) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class A1(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Parameter für die kontinuierliche Aufteilung der
</span><span class="noop">    Direktabflusskomponenten (threshold value for the continuous seperation
</span><span class="noop">    of direct runoff in a slow and a fast component) [mm/d]
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, True, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class A2(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Parameter für die diskontinuierliche Aufteilung der
</span><span class="noop">    Direktabflusskomponenten (threshold value for the discontinuous seperation
</span><span class="noop">    of direct runoff in a slow and a fast component) [mm/d]
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, True, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TInd(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Fließzeitindex (factor related to the time of concentration) [T].
</span><span class="noop">
</span><span class="noop">    In addition to the :class:`parametertools.SingleParameter` call method, it
</span><span class="noop">    is possible to set the value of parameter :class:`TInd` in accordance to
</span><span class="noop">    the keyword arguments `tal` (talweg, [km]), `hot` (higher reference
</span><span class="noop">    altitude, [m]), and `hut` (lower reference altitude, [m]).  This is
</span><span class="noop">    supposed to decrease the time of runoff concentration in small and/or
</span><span class="noop">    steep catchments.  Note that :class:`TInd` does not only affect direct
</span><span class="noop">    runoff, but interflow and base flow as well.  Hence it seems advisable
</span><span class="noop">    to use this regionalization strategy with caution.
</span><span class="noop">
</span><span class="noop">    Basic Equation:
</span><span class="noop">        :math:`TInd[h] = (0.868 \\cdot \\frac{Tal^3}{HOT-HUT})^{0.385}`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Using typical values:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; tind(tal=5., hot=210., hut=200.)
</span><span class="noop">        &gt;&gt;&gt; tind
</span><span class="noop">        tind(0.104335)
</span><span class="noop">
</span><span class="noop">        Note that this result is related to the selected parameter step size
</span><span class="noop">        of one day.  The value related to the selected simulation step size
</span><span class="noop">        of 12 hours is:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; round(tind.value, 6)
</span><span class="noop">        0.20867
</span><span class="noop">
</span><span class="noop">        Unplausible input values lead to the following exception:
</span><span class="noop">        &gt;&gt;&gt; tind(tal=5., hot=200., hut=200.)
</span><span class="noop">        Traceback (most recent call last):
</span><span class="noop">        ...
</span><span class="noop">        ValueError: For the alternative calculation of parameter `tind`, the value assigned to keyword argument `tal` must be greater then zero and the one of `hot` must be greater than the one of `hut`.  However, for element ?, the values `5.0`, `200.0` and `200.0` were given respectively.
</span><span class="noop">        &gt;&gt;&gt; tind(tal=0., hot=210., hut=200.)
</span><span class="noop">        Traceback (most recent call last):
</span><span class="noop">        ...
</span><span class="noop">        ValueError: For the alternative calculation of parameter `tind`, the value assigned to keyword argument `tal` must be greater then zero and the one of `hot` must be greater than the one of `hut`.  However, for element ?, the values `0.0`, `210.0` and `200.0` were given respectively.
</span><span class="noop">
</span><span class="noop">        However, it is hard to define exact bounds for the value of
</span><span class="noop">        :class:`TInd` itself.  Whenever it is below 0.001 or above 1000 days,
</span><span class="noop">        the following warning is given:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; tind(tal=.001, hot=210., hut=200.)
</span><span class="noop">        Traceback (most recent call last):
</span><span class="noop">        ...
</span><span class="noop">        UserWarning: Due to the given values for the keyword arguments `tal` (0.001), `hot` (210.0) and `hut` (200.0), parameter `tind` of element `?` has been set to an unrealistic value of `0.000134 hours`.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, False, (0., None)
</span><span class="noop">
</span><span class="hit">    def __call__(self, *args, **kwargs):
</span><span class="noop">        &#34;&#34;&#34;The prefered way to pass values to :class:`TInd` instances
</span><span class="noop">        within parameter control files.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        try:
</span><span class="hit">            parametertools.SingleParameter.__call__(self, *args, **kwargs)
</span><span class="hit">        except NotImplementedError:
</span><span class="hit">            counter = (&#39;tal&#39; in kwargs) + (&#39;hot&#39; in kwargs) + (&#39;hut&#39; in kwargs)
</span><span class="hit">            if counter == 0:
</span><span class="miss">                raise ValueError(&#39;For parameter `tind` a value can be set &#39;
</span><span class="noop">                                 &#39;directly by passing a single value or &#39;
</span><span class="noop">                                 &#39;indirectly by using the keyword arguments &#39;
</span><span class="noop">                                 &#39;`tal`, `hot`, and `hut`.&#39;)
</span><span class="hit">            elif counter &lt; 3:
</span><span class="miss">                raise ValueError(&#39;For the alternative calculation of &#39;
</span><span class="noop">                                 &#39;parameter `tind`, values for all three &#39;
</span><span class="noop">                                 &#39;keyword keyword arguments `tal`, `hot`, &#39;
</span><span class="noop">                                 &#39;and `hut` must be given.&#39;)
</span><span class="noop">            else:
</span><span class="hit">                tal = float(kwargs[&#39;tal&#39;])
</span><span class="hit">                hot = float(kwargs[&#39;hot&#39;])
</span><span class="hit">                hut = float(kwargs[&#39;hut&#39;])
</span><span class="hit">                if (tal &lt;= 0.) or (hot &lt;= hut):
</span><span class="hit">                    raise ValueError(&#39;For the alternative calculation of &#39;
</span><span class="noop">                                     &#39;parameter `tind`, the value assigned to &#39;
</span><span class="noop">                                     &#39;keyword argument `tal` must be greater &#39;
</span><span class="noop">                                     &#39;then zero and the one of `hot` must be &#39;
</span><span class="noop">                                     &#39;greater than the one of `hut`.  &#39;
</span><span class="noop">                                     &#39;However, for element %s, the values &#39;
</span><span class="noop">                                     &#39;`%s`, `%s` and `%s` were given &#39;
</span><span class="noop">                                     &#39;respectively.&#39;
</span><span class="noop">                                     % (objecttools.devicename(self),
</span><span class="noop">                                        tal, hot, hut))
</span><span class="hit">                self.value = (.868*tal**3/(hot-hut))**.385
</span><span class="hit">                if (self &gt; 1000.) or (self &lt; .001):
</span><span class="hit">                    warnings.warn(&#39;Due to the given values for the keyword &#39;
</span><span class="noop">                                  &#39;arguments `tal` (%s), `hot` (%s) and `hut` &#39;
</span><span class="noop">                                  &#39;(%s), parameter `tind` of element `%s` has &#39;
</span><span class="noop">                                  &#39;been set to an unrealistic value of `%s &#39;
</span><span class="noop">                                  &#39;hours`.&#39; % (tal, hot, hut,
</span><span class="noop">                                               objecttools.devicename(self),
</span><span class="noop">                                               round(self.value, 6)))
</span><span class="hit">                self.value *= timetools.Period(&#39;1h&#39;)/self.simulationstep
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class EQB(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Kalibrierfaktor für die Basisabflusskonzentration (factor for adjusting
</span><span class="noop">    the concentration time of baseflow). [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="noop">        &#34;&#34;&#34;Trim upper values in accordance with :math:`EQI1 \\leq EQB`.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; eqi1.value = 2.
</span><span class="noop">        &gt;&gt;&gt; eqb(1.)
</span><span class="noop">        &gt;&gt;&gt; eqb
</span><span class="noop">        eqb(2.0)
</span><span class="noop">        &gt;&gt;&gt; eqb(2.)
</span><span class="noop">        &gt;&gt;&gt; eqb
</span><span class="noop">        eqb(2.0)
</span><span class="noop">        &gt;&gt;&gt; eqb(3.)
</span><span class="noop">        &gt;&gt;&gt; eqb
</span><span class="noop">        eqb(3.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if lower is None:
</span><span class="hit">            lower = self.subpars.eqi1
</span><span class="hit">        parametertools.SingleParameter.trim(self, lower, upper)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class EQI1(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Kalibrierfaktor für die &#34;untere&#34; Zwischenabflusskonzentration
</span><span class="noop">    (factor for adjusting the concentration time of the first interflow
</span><span class="noop">    component) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="noop">        &#34;&#34;&#34;Trim upper values in accordance with
</span><span class="noop">        :math:`EQI2 \\leq EQI1 \\leq EQB`.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; eqb.value = 3.
</span><span class="noop">        &gt;&gt;&gt; eqi2.value = 1.
</span><span class="noop">        &gt;&gt;&gt; eqi1(0.)
</span><span class="noop">        &gt;&gt;&gt; eqi1
</span><span class="noop">        eqi1(1.0)
</span><span class="noop">        &gt;&gt;&gt; eqi1(1.)
</span><span class="noop">        &gt;&gt;&gt; eqi1
</span><span class="noop">        eqi1(1.0)
</span><span class="noop">        &gt;&gt;&gt; eqi1(2.)
</span><span class="noop">        &gt;&gt;&gt; eqi1
</span><span class="noop">        eqi1(2.0)
</span><span class="noop">        &gt;&gt;&gt; eqi1(3.)
</span><span class="noop">        &gt;&gt;&gt; eqi1
</span><span class="noop">        eqi1(3.0)
</span><span class="noop">        &gt;&gt;&gt; eqi1(4.)
</span><span class="noop">        &gt;&gt;&gt; eqi1
</span><span class="noop">        eqi1(3.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if lower is None:
</span><span class="hit">            lower = self.subpars.eqi2
</span><span class="hit">        if upper is None:
</span><span class="hit">            upper = self.subpars.eqb
</span><span class="hit">        parametertools.SingleParameter.trim(self, lower, upper)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class EQI2(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Kalibrierfaktor für die &#34;obere&#34; Zwischenabflusskonzentration
</span><span class="noop">    (factor for adjusting the concentration time of the second interflow
</span><span class="noop">    component) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="noop">        &#34;&#34;&#34;Trim upper values in accordance with
</span><span class="noop">        :math:`EQD \\leq EQI2 \\leq EQI1`.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; eqi1.value = 3.
</span><span class="noop">        &gt;&gt;&gt; eqd1.value = 1.
</span><span class="noop">        &gt;&gt;&gt; eqi2(0.)
</span><span class="noop">        &gt;&gt;&gt; eqi2
</span><span class="noop">        eqi2(1.0)
</span><span class="noop">        &gt;&gt;&gt; eqi2(1.)
</span><span class="noop">        &gt;&gt;&gt; eqi2
</span><span class="noop">        eqi2(1.0)
</span><span class="noop">        &gt;&gt;&gt; eqi2(2.)
</span><span class="noop">        &gt;&gt;&gt; eqi2
</span><span class="noop">        eqi2(2.0)
</span><span class="noop">        &gt;&gt;&gt; eqi2(3.)
</span><span class="noop">        &gt;&gt;&gt; eqi2
</span><span class="noop">        eqi2(3.0)
</span><span class="noop">        &gt;&gt;&gt; eqi2(4.)
</span><span class="noop">        &gt;&gt;&gt; eqi2
</span><span class="noop">        eqi2(3.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if lower is None:
</span><span class="hit">            lower = self.subpars.eqd1
</span><span class="hit">        if upper is None:
</span><span class="hit">            upper = self.subpars.eqi1
</span><span class="hit">        parametertools.SingleParameter.trim(self, lower, upper)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class EQD1(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Kalibrierfaktor für die langsamere Direktabflusskonzentration (factor
</span><span class="noop">    for adjusting the concentration time of the slower component of direct
</span><span class="noop">    runoff). [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="noop">        &#34;&#34;&#34;Trim upper values in accordance with
</span><span class="noop">        :math:`EQD2 \\leq EQD1 \\leq EQI2`.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; eqi2.value = 3.
</span><span class="noop">        &gt;&gt;&gt; eqd2.value = 1.
</span><span class="noop">        &gt;&gt;&gt; eqd1(0.)
</span><span class="noop">        &gt;&gt;&gt; eqd1
</span><span class="noop">        eqd1(1.0)
</span><span class="noop">        &gt;&gt;&gt; eqd1(1.)
</span><span class="noop">        &gt;&gt;&gt; eqd1
</span><span class="noop">        eqd1(1.0)
</span><span class="noop">        &gt;&gt;&gt; eqd1(2.)
</span><span class="noop">        &gt;&gt;&gt; eqd1
</span><span class="noop">        eqd1(2.0)
</span><span class="noop">        &gt;&gt;&gt; eqd1(3.)
</span><span class="noop">        &gt;&gt;&gt; eqd1
</span><span class="noop">        eqd1(3.0)
</span><span class="noop">        &gt;&gt;&gt; eqd1(4.)
</span><span class="noop">        &gt;&gt;&gt; eqd1
</span><span class="noop">        eqd1(3.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if lower is None:
</span><span class="hit">            lower = self.subpars.eqd2
</span><span class="hit">        if upper is None:
</span><span class="hit">            upper = self.subpars.eqi2
</span><span class="hit">        parametertools.SingleParameter.trim(self, lower, upper)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class EQD2(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Kalibrierfaktor für die schnellere Direktabflusskonzentration (factor
</span><span class="noop">    for adjusting the concentration time of the faster component of direct
</span><span class="noop">    runoff). [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="noop">        &#34;&#34;&#34;Trim upper values in accordance with
</span><span class="noop">        :math:`EQD2 \\leq EQD1`.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; eqd1.value = 3.
</span><span class="noop">        &gt;&gt;&gt; eqd2(2.)
</span><span class="noop">        &gt;&gt;&gt; eqd2
</span><span class="noop">        eqd2(2.0)
</span><span class="noop">        &gt;&gt;&gt; eqd2(3.)
</span><span class="noop">        &gt;&gt;&gt; eqd2
</span><span class="noop">        eqd2(3.0)
</span><span class="noop">        &gt;&gt;&gt; eqd2(4.)
</span><span class="noop">        &gt;&gt;&gt; eqd2
</span><span class="noop">        eqd2(3.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if upper is None:
</span><span class="hit">            upper = self.subpars.eqd1
</span><span class="hit">        parametertools.SingleParameter.trim(self, lower, upper)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ControlParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Control parameters of HydPy-L-Land, directly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (FT, NHRU, Lnk, FHRU, HNN, KG, KT, KE, KF, FLn, HInz, LAI,
</span><span class="noop">                   TRefT, TRefN, TGr, TSp, GTF, RSchmelz, CPWasser, PWMax,
</span><span class="noop">                   GrasRef_R, NFk, RelWZ, RelWB, Beta, FBeta, DMax, DMin, BSf,
</span><span class="noop">                   A1, A2, TInd, EQB, EQI1, EQI2, EQD1, EQD2)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_derived.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_derived.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy import pub
</span><span class="hit">from hydpy.core import parametertools
</span><span class="noop"># ...model specific
</span><span class="hit">from hydpy.models.lland import lland_parameters
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MOY(parametertools.IndexParameter):
</span><span class="noop">    &#34;&#34;&#34;References the &#34;global&#34; month of the year index array [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, int, None, (0, 11)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        self.setreference(pub.indexer.monthofyear)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class KInz(lland_parameters.LanduseMonthParameter):
</span><span class="noop">    &#34;&#34;&#34;Interzeptionskapazität bezogen auf die Bodenoberfläche (interception
</span><span class="noop">    capacity normalized to the soil surface area) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 2, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        con = self.subpars.pars.control
</span><span class="hit">        self(con.hinz*con.lai)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class WB(lland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Absolute Mindestbodenfeuchte für die Basisabflussentstehung (threshold
</span><span class="noop">       value of absolute soil moisture for base flow generation) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        con = self.subpars.pars.control
</span><span class="hit">        self(con.relwb*con.nfk)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class WZ(lland_parameters.MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Absolute Mindestbodenfeuchte für die Interflowentstehung (threshold
</span><span class="noop">       value of absolute soil moisture for interflow generation) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        con = self.subpars.pars.control
</span><span class="hit">        self(con.relwz*con.nfk)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class KB(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Konzentrationszeit des Basisabflusses (concentration time of baseflow)
</span><span class="noop">    [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        con = self.subpars.pars.control
</span><span class="hit">        self(con.eqb*con.tind)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class KI1(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Konzentrationszeit des &#34;unteren&#34; Zwischenabflusses (concentration time
</span><span class="noop">    of the first interflow component) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        con = self.subpars.pars.control
</span><span class="hit">        self(con.eqi1*con.tind)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class KI2(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Konzentrationszeit des &#34;oberen&#34; Zwischenabflusses&#34; (concentration time
</span><span class="noop">    of the second interflow component) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        con = self.subpars.pars.control
</span><span class="hit">        self(con.eqi2*con.tind)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class KD1(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Konzentrationszeit des &#34;langsamen&#34; Direktabflusses (concentration time
</span><span class="noop">    of the slower component of direct runoff) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        con = self.subpars.pars.control
</span><span class="hit">        self(con.eqd1*con.tind)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class KD2(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Konzentrationszeit des &#34;schnellen&#34; Direktabflusses (concentration time
</span><span class="noop">    of the faster component of direct runoff) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        con = self.subpars.pars.control
</span><span class="hit">        self(con.eqd2*con.tind)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QFactor(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Factor for converting mm/stepsize to m³/s.&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="hit">        con = self.subpars.pars.control
</span><span class="hit">        self(con.ft*1000./self.simulationstep.seconds)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class DerivedParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Derived parameters of HydPy-H-Land, indirectly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (MOY, KInz, WB, WZ, KB, KI1, KI2, KD1, KD2, QFactor)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_fluxes.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_fluxes.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class NKor(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Korrigierter Niederschlag (corrected precipitation) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TKor(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Korrigierte Lufttemperatur (corrected air temperature) [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ET0(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Grasreferenzverdunstung (reference evapotranspiration) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class EvPo(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Potenzielle Evaporation/Evapotranspiration (potential
</span><span class="noop">    evaporation/evapotranspiration) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class NBes(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Gesamter Bestandsniederschlag (total stand precipitation) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class SBes(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Schneeanteil Bestandsniederschlag (frozen stand precipitation) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class EvI(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Tatsächliche Interzeptionsverdunstung (actual evaporation of
</span><span class="noop">    intercepted water) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class EvB(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Tatsächliche Bodenverdunstung (actual evaporation of
</span><span class="noop">    soil water) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class WGTF(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Potenzielle Schneeschmelze (maximum amount of frozen water that could
</span><span class="noop">    be melted) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Schm(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Tatsächliche Schneeschmelze (actual amount of water melting within the
</span><span class="noop">    snow cover) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class WaDa(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Wasserdargebot (water reaching the soil routine) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QDB(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Direktabfluss-Abgabe aus dem Bodenspeicher (direct runoff release
</span><span class="noop">    from the soil storage) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QIB1(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Erste Komponente der Interflow-Abgabe aus dem Bodenspeicher (first
</span><span class="noop">    component of the interflow release from the soil storage) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QIB2(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Zweite Komponente der Interflow-Abgabe aus dem Bodenspeicher (second
</span><span class="noop">    component of the interflow release from the soil storage) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QBB(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Basisabfluss-Abgabe aus dem Bodenspeicher (base flow release
</span><span class="noop">    from the soil storage) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QDGZ(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Gesamtzufluss in beide Direktabfluss-Gebietsspeicher (total inflow
</span><span class="noop">    into both storage compartments for direct runoff) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Q(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Gesamtabfluss des Teilgebiets (runoff at the catchment outlet) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FluxSequences(sequencetools.FluxSequences):
</span><span class="noop">    &#34;&#34;&#34;Flux sequences of the HydPy-L-Land model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (NKor, TKor, ET0, EvPo, SBes, NBes, EvI, EvB,
</span><span class="noop">                   WGTF, Schm, WaDa, QDB, QIB1, QIB2, QBB, QDGZ, Q)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_inputs.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_inputs.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Nied(sequencetools.InputSequence):
</span><span class="noop">    &#34;&#34;&#34;Niederschlag (precipitation) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class TemL(sequencetools.InputSequence):
</span><span class="noop">    &#34;&#34;&#34;Lufttemperatur (air temperature) [°C].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Glob(sequencetools.InputSequence):
</span><span class="noop">    &#34;&#34;&#34;Globalstrahlung (global radiation) [W/m²].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class InputSequences(sequencetools.InputSequences):
</span><span class="noop">    &#34;&#34;&#34;Input sequences of the HydPy-L-Land model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Nied, TemL, Glob)</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_model.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_model.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
677 &nbsp;
678 &nbsp;
679 &nbsp;
680 &nbsp;
681 &nbsp;
682 &nbsp;
683 &nbsp;
684 &nbsp;
685 &nbsp;
686 &nbsp;
687 &nbsp;
688 &nbsp;
689 &nbsp;
690 &nbsp;
691 &nbsp;
692 &nbsp;
693 &nbsp;
694 &nbsp;
695 &nbsp;
696 &nbsp;
697 &nbsp;
698 &nbsp;
699 &nbsp;
700 &nbsp;
701 &nbsp;
702 &nbsp;
703 &nbsp;
704 &nbsp;
705 &nbsp;
706 &nbsp;
707 &nbsp;
708 &nbsp;
709 &nbsp;
710 &nbsp;
711 &nbsp;
712 &nbsp;
713 &nbsp;
714 &nbsp;
715 &nbsp;
716 &nbsp;
717 &nbsp;
718 &nbsp;
719 &nbsp;
720 &nbsp;
721 &nbsp;
722 &nbsp;
723 &nbsp;
724 &nbsp;
725 &nbsp;
726 &nbsp;
727 &nbsp;
728 &nbsp;
729 &nbsp;
730 &nbsp;
731 &nbsp;
732 &nbsp;
733 &nbsp;
734 &nbsp;
735 &nbsp;
736 &nbsp;
737 &nbsp;
738 &nbsp;
739 &nbsp;
740 &nbsp;
741 &nbsp;
742 &nbsp;
743 &nbsp;
744 &nbsp;
745 &nbsp;
746 &nbsp;
747 &nbsp;
748 &nbsp;
749 &nbsp;
750 &nbsp;
751 &nbsp;
752 &nbsp;
753 &nbsp;
754 &nbsp;
755 &nbsp;
756 &nbsp;
757 &nbsp;
758 &nbsp;
759 &nbsp;
760 &nbsp;
761 &nbsp;
762 &nbsp;
763 &nbsp;
764 &nbsp;
765 &nbsp;
766 &nbsp;
767 &nbsp;
768 &nbsp;
769 &nbsp;
770 &nbsp;
771 &nbsp;
772 &nbsp;
773 &nbsp;
774 &nbsp;
775 &nbsp;
776 &nbsp;
777 &nbsp;
778 &nbsp;
779 &nbsp;
780 &nbsp;
781 &nbsp;
782 &nbsp;
783 &nbsp;
784 &nbsp;
785 &nbsp;
786 &nbsp;
787 &nbsp;
788 &nbsp;
789 &nbsp;
790 &nbsp;
791 &nbsp;
792 &nbsp;
793 &nbsp;
794 &nbsp;
795 &nbsp;
796 &nbsp;
797 &nbsp;
798 &nbsp;
799 &nbsp;
800 &nbsp;
801 &nbsp;
802 &nbsp;
803 &nbsp;
804 &nbsp;
805 &nbsp;
806 &nbsp;
807 &nbsp;
808 &nbsp;
809 &nbsp;
810 &nbsp;
811 &nbsp;
812 &nbsp;
813 &nbsp;
814 &nbsp;
815 &nbsp;
816 &nbsp;
817 &nbsp;
818 &nbsp;
819 &nbsp;
820 &nbsp;
821 &nbsp;
822 &nbsp;
823 &nbsp;
824 &nbsp;
825 &nbsp;
826 &nbsp;
827 &nbsp;
828 &nbsp;
829 &nbsp;
830 &nbsp;
831 &nbsp;
832 &nbsp;
833 &nbsp;
834 &nbsp;
835 &nbsp;
836 &nbsp;
837 &nbsp;
838 &nbsp;
839 &nbsp;
840 &nbsp;
841 &nbsp;
842 &nbsp;
843 &nbsp;
844 &nbsp;
845 &nbsp;
846 &nbsp;
847 &nbsp;
848 &nbsp;
849 &nbsp;
850 &nbsp;
851 &nbsp;
852 &nbsp;
853 &nbsp;
854 &nbsp;
855 &nbsp;
856 &nbsp;
857 &nbsp;
858 &nbsp;
859 &nbsp;
860 &nbsp;
861 &nbsp;
862 &nbsp;
863 &nbsp;
864 &nbsp;
865 &nbsp;
866 &nbsp;
867 &nbsp;
868 &nbsp;
869 &nbsp;
870 &nbsp;
871 &nbsp;
872 &nbsp;
873 &nbsp;
874 &nbsp;
875 &nbsp;
876 &nbsp;
877 &nbsp;
878 &nbsp;
879 &nbsp;
880 &nbsp;
881 &nbsp;
882 &nbsp;
883 &nbsp;
884 &nbsp;
885 &nbsp;
886 &nbsp;
887 &nbsp;
888 &nbsp;
889 &nbsp;
890 &nbsp;
891 &nbsp;
892 &nbsp;
893 &nbsp;
894 &nbsp;
895 &nbsp;
896 &nbsp;
897 &nbsp;
898 &nbsp;
899 &nbsp;
900 &nbsp;
901 &nbsp;
902 &nbsp;
903 &nbsp;
904 &nbsp;
905 &nbsp;
906 &nbsp;
907 &nbsp;
908 &nbsp;
909 &nbsp;
910 &nbsp;
911 &nbsp;
912 &nbsp;
913 &nbsp;
914 &nbsp;
915 &nbsp;
916 &nbsp;
917 &nbsp;
918 &nbsp;
919 &nbsp;
920 &nbsp;
921 &nbsp;
922 &nbsp;
923 &nbsp;
924 &nbsp;
925 &nbsp;
926 &nbsp;
927 &nbsp;
928 &nbsp;
929 &nbsp;
930 &nbsp;
931 &nbsp;
932 &nbsp;
933 &nbsp;
934 &nbsp;
935 &nbsp;
936 &nbsp;
937 &nbsp;
938 &nbsp;
939 &nbsp;
940 &nbsp;
941 &nbsp;
942 &nbsp;
943 &nbsp;
944 &nbsp;
945 &nbsp;
946 &nbsp;
947 &nbsp;
948 &nbsp;
949 &nbsp;
950 &nbsp;
951 &nbsp;
952 &nbsp;
953 &nbsp;
954 &nbsp;
955 &nbsp;
956 &nbsp;
957 &nbsp;
958 &nbsp;
959 &nbsp;
960 &nbsp;
961 &nbsp;
962 &nbsp;
963 &nbsp;
964 &nbsp;
965 &nbsp;
966 &nbsp;
967 &nbsp;
968 &nbsp;
969 &nbsp;
970 &nbsp;
971 &nbsp;
972 &nbsp;
973 &nbsp;
974 &nbsp;
975 &nbsp;
976 &nbsp;
977 &nbsp;
978 &nbsp;
979 &nbsp;
980 &nbsp;
981 &nbsp;
982 &nbsp;
983 &nbsp;
984 &nbsp;
985 &nbsp;
986 &nbsp;
987 &nbsp;
988 &nbsp;
989 &nbsp;
990 &nbsp;
991 &nbsp;
992 &nbsp;
993 &nbsp;
994 &nbsp;
995 &nbsp;
996 &nbsp;
997 &nbsp;
998 &nbsp;
999 &nbsp;
1000 &nbsp;
1001 &nbsp;
1002 &nbsp;
1003 &nbsp;
1004 &nbsp;
1005 &nbsp;
1006 &nbsp;
1007 &nbsp;
1008 &nbsp;
1009 &nbsp;
1010 &nbsp;
1011 &nbsp;
1012 &nbsp;
1013 &nbsp;
1014 &nbsp;
1015 &nbsp;
1016 &nbsp;
1017 &nbsp;
1018 &nbsp;
1019 &nbsp;
1020 &nbsp;
1021 &nbsp;
1022 &nbsp;
1023 &nbsp;
1024 &nbsp;
1025 &nbsp;
1026 &nbsp;
1027 &nbsp;
1028 &nbsp;
1029 &nbsp;
1030 &nbsp;
1031 &nbsp;
1032 &nbsp;
1033 &nbsp;
1034 &nbsp;
1035 &nbsp;
1036 &nbsp;
1037 &nbsp;
1038 &nbsp;
1039 &nbsp;
1040 &nbsp;
1041 &nbsp;
1042 &nbsp;
1043 &nbsp;
1044 &nbsp;
1045 &nbsp;
1046 &nbsp;
1047 &nbsp;
1048 &nbsp;
1049 &nbsp;
1050 &nbsp;
1051 &nbsp;
1052 &nbsp;
1053 &nbsp;
1054 &nbsp;
1055 &nbsp;
1056 &nbsp;
1057 &nbsp;
1058 &nbsp;
1059 &nbsp;
1060 &nbsp;
1061 &nbsp;
1062 &nbsp;
1063 &nbsp;
1064 &nbsp;
1065 &nbsp;
1066 &nbsp;
1067 &nbsp;
1068 &nbsp;
1069 &nbsp;
1070 &nbsp;
1071 &nbsp;
1072 &nbsp;
1073 &nbsp;
1074 &nbsp;
1075 &nbsp;
1076 &nbsp;
1077 &nbsp;
1078 &nbsp;
1079 &nbsp;
1080 &nbsp;
1081 &nbsp;
1082 &nbsp;
1083 &nbsp;
1084 &nbsp;
1085 &nbsp;
1086 &nbsp;
1087 &nbsp;
1088 &nbsp;
1089 &nbsp;
1090 &nbsp;
1091 &nbsp;
1092 &nbsp;
1093 &nbsp;
1094 &nbsp;
1095 &nbsp;
1096 &nbsp;
1097 &nbsp;
1098 &nbsp;
1099 &nbsp;
1100 &nbsp;
1101 &nbsp;
1102 &nbsp;
1103 &nbsp;
1104 &nbsp;
1105 &nbsp;
1106 &nbsp;
1107 &nbsp;
1108 &nbsp;
1109 &nbsp;
1110 &nbsp;
1111 &nbsp;
1112 &nbsp;
1113 &nbsp;
1114 &nbsp;
1115 &nbsp;
1116 &nbsp;
1117 &nbsp;
1118 &nbsp;
1119 &nbsp;
1120 &nbsp;
1121 &nbsp;
1122 &nbsp;
1123 &nbsp;
1124 &nbsp;
1125 &nbsp;
1126 &nbsp;
1127 &nbsp;
1128 &nbsp;
1129 &nbsp;
1130 &nbsp;
1131 &nbsp;
1132 &nbsp;
1133 &nbsp;
1134 &nbsp;
1135 &nbsp;
1136 &nbsp;
1137 &nbsp;
1138 &nbsp;
1139 &nbsp;
1140 &nbsp;
1141 &nbsp;
1142 &nbsp;
1143 &nbsp;
1144 &nbsp;
1145 &nbsp;
1146 &nbsp;
1147 &nbsp;
1148 &nbsp;
1149 &nbsp;
1150 &nbsp;
1151 &nbsp;
1152 &nbsp;
1153 &nbsp;
1154 &nbsp;
1155 &nbsp;
1156 &nbsp;
1157 &nbsp;
1158 &nbsp;
1159 &nbsp;
1160 &nbsp;
1161 &nbsp;
1162 &nbsp;
1163 &nbsp;
1164 &nbsp;
1165 &nbsp;
1166 &nbsp;
1167 &nbsp;
1168 &nbsp;
1169 &nbsp;
1170 &nbsp;
1171 &nbsp;
1172 &nbsp;
1173 &nbsp;
1174 &nbsp;
1175 &nbsp;
1176 &nbsp;
1177 &nbsp;
1178 &nbsp;
1179 &nbsp;
1180 &nbsp;
1181 &nbsp;
1182 &nbsp;
1183 &nbsp;
1184 &nbsp;
1185 &nbsp;
1186 &nbsp;
1187 &nbsp;
1188 &nbsp;
1189 &nbsp;
1190 &nbsp;
1191 &nbsp;
1192 &nbsp;
1193 &nbsp;
1194 &nbsp;
1195 &nbsp;
1196 &nbsp;
1197 &nbsp;
1198 &nbsp;
1199 &nbsp;
1200 &nbsp;
1201 &nbsp;
1202 &nbsp;
1203 &nbsp;
1204 &nbsp;
1205 &nbsp;
1206 &nbsp;
1207 &nbsp;
1208 &nbsp;
1209 &nbsp;
1210 &nbsp;
1211 &nbsp;
1212 &nbsp;
1213 &nbsp;
1214 &nbsp;
1215 &nbsp;
1216 &nbsp;
1217 &nbsp;
1218 &nbsp;
1219 &nbsp;
1220 &nbsp;
1221 &nbsp;
1222 &nbsp;
1223 &nbsp;
1224 &nbsp;
1225 &nbsp;
1226 &nbsp;
1227 &nbsp;
1228 &nbsp;
1229 &nbsp;
1230 &nbsp;
1231 &nbsp;
1232 &nbsp;
1233 &nbsp;
1234 &nbsp;
1235 &nbsp;
1236 &nbsp;
1237 &nbsp;
1238 &nbsp;
1239 &nbsp;
1240 &nbsp;
1241 &nbsp;
1242 &nbsp;
1243 &nbsp;
1244 &nbsp;
1245 &nbsp;
1246 &nbsp;
1247 &nbsp;
1248 &nbsp;
1249 &nbsp;
1250 &nbsp;
1251 &nbsp;
1252 &nbsp;
1253 &nbsp;
1254 &nbsp;
1255 &nbsp;
1256 &nbsp;
1257 &nbsp;
1258 &nbsp;
1259 &nbsp;
1260 &nbsp;
1261 &nbsp;
1262 &nbsp;
1263 &nbsp;
1264 &nbsp;
1265 &nbsp;
1266 &nbsp;
1267 &nbsp;
1268 &nbsp;
1269 &nbsp;
1270 &nbsp;
1271 &nbsp;
1272 &nbsp;
1273 &nbsp;
1274 &nbsp;
1275 &nbsp;
1276 &nbsp;
1277 &nbsp;
1278 &nbsp;
1279 &nbsp;
1280 &nbsp;
1281 &nbsp;
1282 &nbsp;
1283 &nbsp;
1284 &nbsp;
1285 &nbsp;
1286 &nbsp;
1287 &nbsp;
1288 &nbsp;
1289 &nbsp;
1290 &nbsp;
1291 &nbsp;
1292 &nbsp;
1293 &nbsp;
1294 &nbsp;
1295 &nbsp;
1296 &nbsp;
1297 &nbsp;
1298 &nbsp;
1299 &nbsp;
1300 &nbsp;
1301 &nbsp;
1302 &nbsp;
1303 &nbsp;
1304 &nbsp;
1305 &nbsp;
1306 &nbsp;
1307 &nbsp;
1308 &nbsp;
1309 &nbsp;
1310 &nbsp;
1311 &nbsp;
1312 &nbsp;
1313 &nbsp;
1314 &nbsp;
1315 &nbsp;
1316 &nbsp;
1317 &nbsp;
1318 &nbsp;
1319 &nbsp;
1320 &nbsp;
1321 &nbsp;
1322 &nbsp;
1323 &nbsp;
1324 &nbsp;
1325 &nbsp;
1326 &nbsp;
1327 &nbsp;
1328 &nbsp;
1329 &nbsp;
1330 &nbsp;
1331 &nbsp;
1332 &nbsp;
1333 &nbsp;
1334 &nbsp;
1335 &nbsp;
1336 &nbsp;
1337 &nbsp;
1338 &nbsp;
1339 &nbsp;
1340 &nbsp;
1341 &nbsp;
1342 &nbsp;
1343 &nbsp;
1344 &nbsp;
1345 &nbsp;
1346 &nbsp;
1347 &nbsp;
1348 &nbsp;
1349 &nbsp;
1350 &nbsp;
1351 &nbsp;
1352 &nbsp;
1353 &nbsp;
1354 &nbsp;
1355 &nbsp;
1356 &nbsp;
1357 &nbsp;
1358 &nbsp;
1359 &nbsp;
1360 &nbsp;
1361 &nbsp;
1362 &nbsp;
1363 &nbsp;
1364 &nbsp;
1365 &nbsp;
1366 &nbsp;
1367 &nbsp;
1368 &nbsp;
1369 &nbsp;
1370 &nbsp;
1371 &nbsp;
1372 &nbsp;
1373 &nbsp;
1374 &nbsp;
1375 &nbsp;
1376 &nbsp;
1377 &nbsp;
1378 &nbsp;
1379 &nbsp;
1380 &nbsp;
1381 &nbsp;
1382 &nbsp;
1383 &nbsp;
1384 &nbsp;
1385 &nbsp;
1386 &nbsp;
1387 &nbsp;
1388 &nbsp;
1389 &nbsp;
1390 &nbsp;
1391 &nbsp;
1392 &nbsp;
1393 &nbsp;
1394 &nbsp;
1395 &nbsp;
1396 &nbsp;
1397 &nbsp;
1398 &nbsp;
1399 &nbsp;
1400 &nbsp;
1401 &nbsp;
1402 &nbsp;
1403 &nbsp;
1404 &nbsp;
1405 &nbsp;
1406 &nbsp;
1407 &nbsp;
1408 &nbsp;
1409 &nbsp;
1410 &nbsp;
1411 &nbsp;
1412 &nbsp;
1413 &nbsp;
1414 &nbsp;
1415 &nbsp;
1416 &nbsp;
1417 &nbsp;
1418 &nbsp;
1419 &nbsp;
1420 &nbsp;
1421 &nbsp;
1422 &nbsp;
1423 &nbsp;
1424 &nbsp;
1425 &nbsp;
1426 &nbsp;
1427 &nbsp;
1428 &nbsp;
1429 &nbsp;
1430 &nbsp;
1431 &nbsp;
1432 &nbsp;
1433 &nbsp;
1434 &nbsp;
1435 &nbsp;
1436 &nbsp;
1437 &nbsp;
1438 &nbsp;
1439 &nbsp;
1440 &nbsp;
1441 &nbsp;
1442 &nbsp;
1443 &nbsp;
1444 &nbsp;
1445 &nbsp;
1446 &nbsp;
1447 &nbsp;
1448 &nbsp;
1449 &nbsp;
1450 &nbsp;
1451 &nbsp;
1452 &nbsp;
1453 &nbsp;
1454 &nbsp;
1455 &nbsp;
1456 &nbsp;
1457 &nbsp;
1458 &nbsp;
1459 &nbsp;
1460 &nbsp;
1461 &nbsp;
1462 &nbsp;
1463 &nbsp;
1464 &nbsp;
1465 &nbsp;
1466 &nbsp;
1467 &nbsp;
1468 &nbsp;
1469 &nbsp;
1470 &nbsp;
1471 &nbsp;
1472 &nbsp;
1473 &nbsp;
1474 &nbsp;
1475 &nbsp;
1476 &nbsp;
1477 &nbsp;
1478 &nbsp;
1479 &nbsp;
1480 &nbsp;
1481 &nbsp;
1482 &nbsp;
1483 &nbsp;
1484 &nbsp;
1485 &nbsp;
1486 &nbsp;
1487 &nbsp;
1488 &nbsp;
1489 &nbsp;
1490 &nbsp;
1491 &nbsp;
1492 &nbsp;
1493 &nbsp;
1494 &nbsp;
1495 &nbsp;
1496 &nbsp;
1497 &nbsp;
1498 &nbsp;
1499 &nbsp;
1500 &nbsp;
1501 &nbsp;
1502 &nbsp;
1503 &nbsp;
1504 &nbsp;
1505 &nbsp;
1506 &nbsp;
1507 &nbsp;
1508 &nbsp;
1509 &nbsp;
1510 &nbsp;
1511 &nbsp;
1512 &nbsp;
1513 &nbsp;
1514 &nbsp;
1515 &nbsp;
1516 &nbsp;
1517 &nbsp;
1518 &nbsp;
1519 &nbsp;
1520 &nbsp;
1521 &nbsp;
1522 &nbsp;
1523 &nbsp;
1524 &nbsp;
1525 &nbsp;
1526 &nbsp;
1527 &nbsp;
1528 &nbsp;
1529 &nbsp;
1530 &nbsp;
1531 &nbsp;
1532 &nbsp;
1533 &nbsp;
1534 &nbsp;
1535 &nbsp;
1536 &nbsp;
1537 &nbsp;
1538 &nbsp;
1539 &nbsp;
1540 &nbsp;
1541 &nbsp;
1542 &nbsp;
1543 &nbsp;
1544 &nbsp;
1545 &nbsp;
1546 &nbsp;
1547 &nbsp;
1548 &nbsp;
1549 &nbsp;
1550 &nbsp;
1551 &nbsp;
1552 &nbsp;
1553 &nbsp;
1554 &nbsp;
1555 &nbsp;
1556 &nbsp;
1557 &nbsp;
1558 &nbsp;
1559 &nbsp;
1560 &nbsp;
1561 &nbsp;
1562 &nbsp;
1563 &nbsp;
1564 &nbsp;
1565 &nbsp;
1566 &nbsp;
1567 &nbsp;
1568 &nbsp;
1569 &nbsp;
1570 &nbsp;
1571 &nbsp;
1572 &nbsp;
1573 &nbsp;
1574 &nbsp;
1575 &nbsp;
1576 &nbsp;
1577 &nbsp;
1578 &nbsp;
1579 &nbsp;
1580 &nbsp;
1581 &nbsp;
1582 &nbsp;
1583 &nbsp;
1584 &nbsp;
1585 &nbsp;
1586 &nbsp;
1587 &nbsp;
1588 &nbsp;
1589 &nbsp;
1590 &nbsp;
1591 &nbsp;
1592 &nbsp;
1593 &nbsp;
1594 &nbsp;
1595 &nbsp;
1596 &nbsp;
1597 &nbsp;
1598 &nbsp;
1599 &nbsp;
1600 &nbsp;
1601 &nbsp;
1602 &nbsp;
1603 &nbsp;
1604 &nbsp;
1605 &nbsp;
1606 &nbsp;
1607 &nbsp;
1608 &nbsp;
1609 &nbsp;
1610 &nbsp;
1611 &nbsp;
1612 &nbsp;
1613 &nbsp;
1614 &nbsp;
1615 &nbsp;
1616 &nbsp;
1617 &nbsp;
1618 &nbsp;
1619 &nbsp;
1620 &nbsp;
1621 &nbsp;
1622 &nbsp;
1623 &nbsp;
1624 &nbsp;
1625 &nbsp;
1626 &nbsp;
1627 &nbsp;
1628 &nbsp;
1629 &nbsp;
1630 &nbsp;
1631 &nbsp;
1632 &nbsp;
1633 &nbsp;
1634 &nbsp;
1635 &nbsp;
1636 &nbsp;
1637 &nbsp;
1638 &nbsp;
1639 &nbsp;
1640 &nbsp;
1641 &nbsp;
1642 &nbsp;
1643 &nbsp;
1644 &nbsp;
1645 &nbsp;
1646 &nbsp;
1647 &nbsp;
1648 &nbsp;
1649 &nbsp;
1650 &nbsp;
1651 &nbsp;
1652 &nbsp;
1653 &nbsp;
1654 &nbsp;
1655 &nbsp;
1656 &nbsp;
1657 &nbsp;
1658 &nbsp;
1659 &nbsp;
1660 &nbsp;
1661 &nbsp;
1662 &nbsp;
1663 &nbsp;
1664 &nbsp;
1665 &nbsp;
1666 &nbsp;
1667 &nbsp;
1668 &nbsp;
1669 &nbsp;
1670 &nbsp;
1671 &nbsp;
1672 &nbsp;
1673 &nbsp;
1674 &nbsp;
1675 &nbsp;
1676 &nbsp;
1677 &nbsp;
1678 &nbsp;
1679 &nbsp;
1680 &nbsp;
1681 &nbsp;
1682 &nbsp;
1683 &nbsp;
1684 &nbsp;
1685 &nbsp;
1686 &nbsp;
1687 &nbsp;
1688 &nbsp;
1689 &nbsp;
1690 &nbsp;
1691 &nbsp;
1692 &nbsp;
1693 &nbsp;
1694 &nbsp;
1695 &nbsp;
1696 &nbsp;
1697 &nbsp;
1698 &nbsp;
1699 &nbsp;
1700 &nbsp;
1701 &nbsp;
1702 &nbsp;
1703 &nbsp;
1704 &nbsp;
1705 &nbsp;
1706 &nbsp;
1707 &nbsp;
1708 &nbsp;
1709 &nbsp;
1710 &nbsp;
1711 &nbsp;
1712 &nbsp;
1713 &nbsp;
1714 &nbsp;
1715 &nbsp;
1716 &nbsp;
1717 &nbsp;
1718 &nbsp;
1719 &nbsp;
1720 &nbsp;
1721 &nbsp;
1722 &nbsp;
1723 &nbsp;
1724 &nbsp;
1725 &nbsp;
1726 &nbsp;
1727 &nbsp;
1728 &nbsp;
1729 &nbsp;
1730 &nbsp;
1731 &nbsp;
1732 &nbsp;
1733 &nbsp;
1734 &nbsp;
1735 &nbsp;
1736 &nbsp;
1737 &nbsp;
1738 &nbsp;
1739 &nbsp;
1740 &nbsp;
1741 &nbsp;
1742 &nbsp;
1743 &nbsp;
1744 &nbsp;
1745 &nbsp;
1746 &nbsp;
1747 &nbsp;
1748 &nbsp;
1749 &nbsp;
1750 &nbsp;
1751 &nbsp;
1752 &nbsp;
1753 &nbsp;
1754 &nbsp;
1755 &nbsp;
1756 &nbsp;
1757 &nbsp;
1758 &nbsp;
1759 &nbsp;
1760 &nbsp;
1761 &nbsp;
1762 &nbsp;
1763 &nbsp;
1764 &nbsp;
1765 &nbsp;
1766 &nbsp;
1767 &nbsp;
1768 &nbsp;
1769 &nbsp;
1770 &nbsp;
1771 &nbsp;
1772 &nbsp;
1773 &nbsp;
1774 &nbsp;
1775 &nbsp;
1776 &nbsp;
1777 &nbsp;
1778 &nbsp;
1779 &nbsp;
1780 &nbsp;
1781 &nbsp;
1782 &nbsp;
1783 &nbsp;
1784 &nbsp;
1785 &nbsp;
1786 &nbsp;
1787 &nbsp;
1788 &nbsp;
1789 &nbsp;
1790 &nbsp;
1791 &nbsp;
1792 &nbsp;
1793 &nbsp;
1794 &nbsp;
1795 &nbsp;
1796 &nbsp;
1797 &nbsp;
1798 &nbsp;
1799 &nbsp;
1800 &nbsp;
1801 &nbsp;
1802 &nbsp;
1803 &nbsp;
1804 &nbsp;
1805 &nbsp;
1806 &nbsp;
1807 &nbsp;
1808 &nbsp;
1809 &nbsp;
1810 &nbsp;
1811 &nbsp;
1812 &nbsp;
1813 &nbsp;
1814 &nbsp;
1815 &nbsp;
1816 &nbsp;
1817 &nbsp;
1818 &nbsp;
1819 &nbsp;
1820 &nbsp;
1821 &nbsp;
1822 &nbsp;
1823 &nbsp;
1824 &nbsp;
1825 &nbsp;
1826 &nbsp;
1827 &nbsp;
1828 &nbsp;
1829 &nbsp;
1830 &nbsp;
1831 &nbsp;
1832 &nbsp;
1833 &nbsp;
1834 &nbsp;
1835 &nbsp;
1836 &nbsp;
1837 &nbsp;
1838 &nbsp;
1839 &nbsp;
1840 &nbsp;
1841 &nbsp;
1842 &nbsp;
1843 &nbsp;
1844 &nbsp;
1845 &nbsp;
1846 &nbsp;
1847 &nbsp;
1848 &nbsp;
1849 &nbsp;
1850 &nbsp;
1851 &nbsp;
1852 &nbsp;
1853 &nbsp;
1854 &nbsp;
1855 &nbsp;
1856 &nbsp;
1857 &nbsp;
1858 &nbsp;
1859 &nbsp;
1860 &nbsp;
1861 &nbsp;
1862 &nbsp;
1863 &nbsp;
1864 &nbsp;
1865 &nbsp;
1866 &nbsp;
1867 &nbsp;
1868 &nbsp;
1869 &nbsp;
1870 &nbsp;
1871 &nbsp;
1872 &nbsp;
1873 &nbsp;
1874 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># imports...
</span><span class="noop"># ...standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import modeltools
</span><span class="hit">from hydpy.cythons import modelutils
</span><span class="noop"># ...model specifc
</span><span class="hit">from hydpy.models.lland.lland_constants import WASSER, VERS
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_nkor_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Adjust the given precipitation values.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.KG`
</span><span class="noop">
</span><span class="noop">    Required input sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_inputs.Nied`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.NKor`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`NKor = KG \\cdot Nied`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">    &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">    &gt;&gt;&gt; nhru(3)
</span><span class="noop">    &gt;&gt;&gt; kg(.8, 1., 1.2)
</span><span class="noop">    &gt;&gt;&gt; inputs.nied = 10.
</span><span class="noop">    &gt;&gt;&gt; model.calc_nkor_v1()
</span><span class="noop">    &gt;&gt;&gt; fluxes.nkor
</span><span class="noop">    nkor(8.0, 10.0, 12.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    inp = self.sequences.inputs.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        flu.nkor[k] = con.kg[k] * inp.nied
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_tkor_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Adjust the given air temperature values.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.KT`
</span><span class="noop">
</span><span class="noop">    Required input sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_inputs.TemL`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.TKor`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`TKor = KT + TemL`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">    &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">    &gt;&gt;&gt; nhru(3)
</span><span class="noop">    &gt;&gt;&gt; kt(-2., 0., 2.)
</span><span class="noop">    &gt;&gt;&gt; inputs.teml(1.)
</span><span class="noop">    &gt;&gt;&gt; model.calc_tkor_v1()
</span><span class="noop">    &gt;&gt;&gt; fluxes.tkor
</span><span class="noop">    tkor(-1.0, 1.0, 3.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    inp = self.sequences.inputs.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        flu.tkor[k] = con.kt[k] + inp.teml
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_et0_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate reference evapotranspiration after Turc-Wendling.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.KE`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.KF`
</span><span class="noop">
</span><span class="noop">    Required input sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_inputs.Glob`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.TKor`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.ET0`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`ET0 = KE \\cdot
</span><span class="noop">      \\frac{(8.64 \\cdot Glob+93 \\cdot KF) \\cdot (TKor+22)}
</span><span class="noop">      {165 \\cdot (TKor+123) \\cdot (1 + 0.00019 \\cdot min(HNN, 600))}`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">    &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">    &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">    &gt;&gt;&gt; nhru(3)
</span><span class="noop">    &gt;&gt;&gt; ke(1.1)
</span><span class="noop">    &gt;&gt;&gt; kf(.6)
</span><span class="noop">    &gt;&gt;&gt; hnn(200., 600., 1000.)
</span><span class="noop">    &gt;&gt;&gt; inputs.glob = 200.
</span><span class="noop">    &gt;&gt;&gt; fluxes.tkor = 15.
</span><span class="noop">    &gt;&gt;&gt; model.calc_et0_v1()
</span><span class="noop">    &gt;&gt;&gt; fluxes.et0
</span><span class="noop">    et0(1.535855, 1.431075, 1.431075)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    inp = self.sequences.inputs.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        flu.et0[k] = (con.ke[k]*(((8.64*inp.glob+93.*con.kf[k]) *
</span><span class="noop">                                  (flu.tkor[k]+22.)) /
</span><span class="noop">                                 (165.*(flu.tkor[k]+123.) *
</span><span class="noop">                                  (1.+0.00019*min(con.hnn[k], 600.)))))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_evpo_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate land use and month specific values of potential
</span><span class="noop">    evapotranspiration.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.Lnk`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.FLn`
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.MOY`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.ET0`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.EvPo`
</span><span class="noop">
</span><span class="noop">    Additional requirements:
</span><span class="noop">      :attr:`~hydpy.core.modeltools.Model.idx_sim`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`EvPo = FLn \\cdot ET0`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">
</span><span class="noop">        For clarity, this is more of a kind of an integration example.
</span><span class="noop">        Parameter :class:`~hydpy.models.lland.lland_control.FLn` both
</span><span class="noop">        depends on time (the actual month) and space (the actual land use).
</span><span class="noop">        Firstly, let us define a initialization time period spanning the
</span><span class="noop">        transition from June to July:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy import pub, Timegrid, Timegrids
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids = Timegrids(Timegrid(&#39;30.06.2000&#39;,
</span><span class="noop">        ...                                    &#39;02.07.2000&#39;,
</span><span class="noop">        ...                                    &#39;1d&#39;))
</span><span class="noop">
</span><span class="noop">        Secondly, assume that the considered subbasin is differenciated in
</span><span class="noop">        two HRUs, one of primarily consisting of arable land and the other
</span><span class="noop">        one of deciduous forests:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(2)
</span><span class="noop">        &gt;&gt;&gt; lnk(ACKER, LAUBW)
</span><span class="noop">
</span><span class="noop">        Thirdly, set the :class:`~hydpy.models.lland.lland_control.FLn`
</span><span class="noop">        values, one for the relevant months and land use classes:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fln.acker_jun = 1.299
</span><span class="noop">        &gt;&gt;&gt; fln.acker_jul = 1.304
</span><span class="noop">        &gt;&gt;&gt; fln.laubw_jun = 1.350
</span><span class="noop">        &gt;&gt;&gt; fln.laubw_jul = 1.365
</span><span class="noop">
</span><span class="noop">        Fourthly, the index array connecting the simulation time steps
</span><span class="noop">        defined above and the month indexes (0...11) can be retrieved
</span><span class="noop">        from the :mod:`~hydpy.pub` module.  This can be done manually
</span><span class="noop">        more conveniently via its update method:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.moy.update()
</span><span class="noop">        &gt;&gt;&gt; derived.moy
</span><span class="noop">        moy(5, 6)
</span><span class="noop">
</span><span class="noop">        Finally, the actual method (with its simple equation) is applied
</span><span class="noop">        as usual:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.et0 = 2.
</span><span class="noop">        &gt;&gt;&gt; model.idx_sim = 0
</span><span class="noop">        &gt;&gt;&gt; model.calc_evpo_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.evpo
</span><span class="noop">        evpo(2.598, 2.7)
</span><span class="noop">        &gt;&gt;&gt; model.idx_sim = 1
</span><span class="noop">        &gt;&gt;&gt; model.calc_evpo_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.evpo
</span><span class="noop">        evpo(2.608, 2.73)
</span><span class="noop">
</span><span class="noop">        Reset module :mod:`~hydpy.pub` to not interfere the following
</span><span class="noop">        examples:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; pub.timegrids = None
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        flu.evpo[k] = con.fln[con.lnk[k]-1, der.moy[self.idx_sim]] * flu.et0[k]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_nbes_inzp_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate throughfall and update the interception storage
</span><span class="noop">    accordingly.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.Lnk`
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.KInz`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.NKor`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.NBes`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_states.Inzp`
</span><span class="noop">
</span><span class="noop">    Additional requirements:
</span><span class="noop">      :attr:`~hydpy.core.modeltools.Model.idx_sim`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`NBes = \\Bigl \\lbrace
</span><span class="noop">      {
</span><span class="noop">      {PKor \\ | \\ Inzp = KInz}
</span><span class="noop">      \\atop
</span><span class="noop">      {0 \\ | \\ Inzp &lt; KInz}
</span><span class="noop">      }`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        Initialize six HRUs with different land usages:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(4)
</span><span class="noop">        &gt;&gt;&gt; lnk(SIED_D, FEUCHT, GLETS, WASSER)
</span><span class="noop">
</span><span class="noop">        Define values for the maximum interception storage directly:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.kinz.sied_d_jul = 2.
</span><span class="noop">        &gt;&gt;&gt; derived.kinz.feucht_jul = 1.
</span><span class="noop">        &gt;&gt;&gt; derived.kinz.glets_jul = 0.
</span><span class="noop">        &gt;&gt;&gt; derived.kinz.wasser_jul = 0.
</span><span class="noop">
</span><span class="noop">        Assume that the three consecutive initialization time steps
</span><span class="noop">        lie in three different months (does not make sense for the
</span><span class="noop">        selected time step of one day, but allows for a more rigorous
</span><span class="noop">        testing of proper indexing):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.moy.shape = 3
</span><span class="noop">        &gt;&gt;&gt; derived.moy = numpy.array([5, 6, 7])
</span><span class="noop">        &gt;&gt;&gt; model.idx_sim = 1
</span><span class="noop">
</span><span class="noop">        The dense settlement and the wetland area start with a initial
</span><span class="noop">        interception storage of 1/2 mm, the glacier and water area (must)
</span><span class="noop">        start with 0 mm.  In the first example, actual precipition is 2 mm:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.inzp(0.5, 0.5, 0., 0.)
</span><span class="noop">        &gt;&gt;&gt; fluxes.nkor = 1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_nbes_inzp_v1()
</span><span class="noop">        &gt;&gt;&gt; states.inzp
</span><span class="noop">        inzp(1.5, 1.0, 0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.nbes
</span><span class="noop">        nbes(0.0, 0.5, 1.0, 1.0)
</span><span class="noop">
</span><span class="noop">        Only for the settled area, interception capacity is not exceeded,
</span><span class="noop">        meaning not through fall occurs.
</span><span class="noop">
</span><span class="noop">        If there is no precipitation, there is of course also no through
</span><span class="noop">        fall and interception storage remains unchanged:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.inzp(0.5, 0.5, 0., 0.)
</span><span class="noop">        &gt;&gt;&gt; fluxes.nkor = 0.
</span><span class="noop">        &gt;&gt;&gt; model.calc_nbes_inzp_v1()
</span><span class="noop">        &gt;&gt;&gt; states.inzp
</span><span class="noop">        inzp(0.5, 0.5, 0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.nbes
</span><span class="noop">        nbes(0.0, 0.0, 0.0, 0.0)
</span><span class="noop">
</span><span class="noop">        Note the following to peculiarities:  Firstly, the behaviour of
</span><span class="noop">        the glacier area is due to its zero interception capacity.  On the
</span><span class="noop">        contrary, the behaviour of the water area hard coded.  Hence,
</span><span class="noop">        increasing the interception capacity shows no effect:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.kinz.glets_jul = 1.
</span><span class="noop">        &gt;&gt;&gt; derived.kinz.wasser_jul = 1.
</span><span class="noop">        &gt;&gt;&gt; states.inzp(0.5, 0.5, 0., 0.)
</span><span class="noop">        &gt;&gt;&gt; fluxes.nkor = 1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_nbes_inzp_v1()
</span><span class="noop">        &gt;&gt;&gt; states.inzp
</span><span class="noop">        inzp(1.5, 1.0, 1.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.nbes
</span><span class="noop">        nbes(0.0, 0.5, 0.0, 1.0)
</span><span class="noop">
</span><span class="noop">        Secondly, due to discontinuous changes of the interception capacity
</span><span class="noop">        between two months, through fall can occur after the corresponding
</span><span class="noop">        precipitation event has occured.  In the last example, this results
</span><span class="noop">        from the given decrease of the glaciers interception capacity:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.kinz.glets_jul = .6
</span><span class="noop">        &gt;&gt;&gt; fluxes.nkor = 0.
</span><span class="noop">        &gt;&gt;&gt; model.calc_nbes_inzp_v1()
</span><span class="noop">        &gt;&gt;&gt; states.inzp
</span><span class="noop">        inzp(1.5, 1.0, 0.6, 0.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.nbes
</span><span class="noop">        nbes(0.0, 0.0, 0.4, 0.0)
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        if con.lnk[k] != WASSER:
</span><span class="hit">            flu.nbes[k] = \
</span><span class="noop">                max(flu.nkor[k]+sta.inzp[k] -
</span><span class="noop">                    der.kinz[con.lnk[k]-1, der.moy[self.idx_sim]], 0.)
</span><span class="hit">            sta.inzp[k] += flu.nkor[k]-flu.nbes[k]
</span><span class="noop">        else:
</span><span class="hit">            flu.nbes[k] = flu.nkor[k]
</span><span class="hit">            sta.inzp[k] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_evi_inzp_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate interception evaporation and update the interception
</span><span class="noop">    storage accordingly.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.Lnk`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.TRefT`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.TRefN`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.EvPo`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.EvI`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_states.Inzp`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`EvI = \\Bigl \\lbrace
</span><span class="noop">      {
</span><span class="noop">      {EvPo \\ | \\ Inzp &gt; 0}
</span><span class="noop">      \\atop
</span><span class="noop">      {0 \\ | \\ Inzp = 0}
</span><span class="noop">      }`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Initialize four HRUs with different combinations of land usage
</span><span class="noop">        and initial interception storage and apply a value of potential
</span><span class="noop">        evaporation of 3 mm on each one:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(4)
</span><span class="noop">        &gt;&gt;&gt; lnk(ACKER, ACKER, ACKER, WASSER)
</span><span class="noop">        &gt;&gt;&gt; states.inzp = 0., 2., 4., 0.
</span><span class="noop">        &gt;&gt;&gt; fluxes.evpo = 3.
</span><span class="noop">        &gt;&gt;&gt; model.calc_evi_inzp_v1()
</span><span class="noop">        &gt;&gt;&gt; states.inzp
</span><span class="noop">        inzp(0.0, 0.0, 1.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.evi
</span><span class="noop">        evi(0.0, 2.0, 3.0, 3.0)
</span><span class="noop">
</span><span class="noop">        For the first three HRUs of land use class
</span><span class="noop">        :const:`~hydpy.models.lland.lland_constants.ACKER`,
</span><span class="noop">        interception evaporation is identical with potential
</span><span class="noop">        evapotranspiration as long as it is met by the available
</span><span class="noop">        intercepted water.  For water areas, interception evaporation is
</span><span class="noop">        generally set to potential evaporation.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        if con.lnk[k] != WASSER:
</span><span class="hit">            flu.evi[k] = min(flu.evpo[k], sta.inzp[k])
</span><span class="hit">            sta.inzp[k] -= flu.evi[k]
</span><span class="noop">        else:
</span><span class="hit">            flu.evi[k] = flu.evpo[k]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_sbes_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the frozen part of stand precipitation.
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.TGr`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.TSp`
</span><span class="noop">
</span><span class="noop">    Required flux sequences:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.TKor`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.NBes`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.SBes`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        In the first example, the threshold temperature of seven hydrological
</span><span class="noop">        response units is 0°C and the corresponding temperature interval of
</span><span class="noop">        mixed precipitation 2°C:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(7)
</span><span class="noop">        &gt;&gt;&gt; tgr(0.)
</span><span class="noop">        &gt;&gt;&gt; tsp(2.)
</span><span class="noop">
</span><span class="noop">        The value of `sbes` is zero above 1°C and equal to the value of
</span><span class="noop">        `nbes` below -1°C.  Between these temperature values, `sbes`
</span><span class="noop">        decreases linearly:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.nbes = 4.
</span><span class="noop">        &gt;&gt;&gt; fluxes.tkor = -10., -1., -.5, 0., .5, 1., 10.
</span><span class="noop">        &gt;&gt;&gt; model.calc_sbes_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.sbes
</span><span class="noop">        sbes(4.0, 4.0, 3.0, 2.0, 1.0, 0.0, 0.0)
</span><span class="noop">
</span><span class="noop">        Note the special case of a zero temperature intervall.  With the
</span><span class="noop">        actual temperature beeing equal to the threshold temperature, the
</span><span class="noop">        the value of `sbes` is zero:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; tsp(0.)
</span><span class="noop">        &gt;&gt;&gt; model.calc_sbes_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.sbes
</span><span class="noop">        sbes(4.0, 4.0, 4.0, 0.0, 0.0, 0.0, 0.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        if flu.tkor[k] &gt;= (con.tgr[k]+con.tsp[k]/2.):
</span><span class="hit">            flu.sbes[k] = 0.
</span><span class="hit">        elif flu.tkor[k] &lt;= (con.tgr[k]-con.tsp[k]/2.):
</span><span class="hit">            flu.sbes[k] = flu.nbes[k]
</span><span class="noop">        else:
</span><span class="hit">            flu.sbes[k] = ((((con.tgr[k]+con.tsp[k]/2.)-flu.tkor[k]) /
</span><span class="noop">                            con.tsp[k])*flu.nbes[k])
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_wgtf_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the potential snow melt.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.Lnk`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.GTF`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.TRefT`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.TRefN`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.RSchmelz`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.CPWasser`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.TKor`
</span><span class="noop">
</span><span class="noop">    Calculated fluxes sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.WGTF`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`WGTF = max(GTF \\cdot (TKor - TRefT), 0) +
</span><span class="noop">      max(\\frac{CPWasser}{RSchmelz} \\cdot (TKor - TRefN), 0)`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Initialize six HRUs with identical degree-day factors and
</span><span class="noop">        temperature thresholds, but different combinations of land use
</span><span class="noop">        and air temperature:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(6)
</span><span class="noop">        &gt;&gt;&gt; lnk(ACKER, LAUBW, WASSER, ACKER, ACKER, ACKER)
</span><span class="noop">        &gt;&gt;&gt; gtf(5.)
</span><span class="noop">        &gt;&gt;&gt; treft(0.)
</span><span class="noop">        &gt;&gt;&gt; trefn(1.)
</span><span class="noop">        &gt;&gt;&gt; fluxes.tkor = 2., 2., 2., -1., 0., 1.
</span><span class="noop">
</span><span class="noop">        The specific heat capacity and melt heat capacity of water are
</span><span class="noop">        (compared to most parameters of hydrological models) relatively
</span><span class="noop">        fixed properties:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; cpwasser(4.1868)
</span><span class="noop">        &gt;&gt;&gt; rschmelz(334.0)
</span><span class="noop">
</span><span class="noop">        Note that the values of the degree-day factor are only half
</span><span class="noop">        as much as the given value, due to the small simulation step size
</span><span class="noop">        beeing only half as long as the parameter step size:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; gtf
</span><span class="noop">        gtf(5.0)
</span><span class="noop">        &gt;&gt;&gt; gtf.values
</span><span class="noop">        array([ 2.5,  2.5,  2.5,  2.5,  2.5,  2.5])
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">        (These values are not hard coded, to allow for changing the
</span><span class="noop">        sensitivity of the snow routine for precipitation driven snow
</span><span class="noop">        melt events.)
</span><span class="noop">
</span><span class="noop">        When performing the calculations, one sees that the potential
</span><span class="noop">        melting rate is identical for the first two HRUs.  The land use
</span><span class="noop">        class results in no difference, except for water areas (third HRU),
</span><span class="noop">        where no potential melt needs to be calculated.  The last three
</span><span class="noop">        HRUs show the usual behaviour of the degree day method, when the
</span><span class="noop">        actual temperature is below (fourth HRU), equal to (fifth HRU) or
</span><span class="noop">        above (sixths zone) the threshold temperature.  Additionally, the
</span><span class="noop">        first two zones show the influence of the additional energy intake
</span><span class="noop">        due to &#34;warm&#34; precipitation.  Obviously, this additional term is
</span><span class="noop">        quite negligible for common parameterizations, even if lower
</span><span class="noop">        values for the seperate threshold temperature would be taken into
</span><span class="noop">        account:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.calc_wgtf_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.wgtf
</span><span class="noop">        wgtf(5.012535, 5.012535, 0.0, 0.0, 0.0, 2.5)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        if con.lnk[k] != WASSER:
</span><span class="hit">            flu.wgtf[k] = (
</span><span class="noop">              max(con.gtf[k]*(flu.tkor[k]-con.treft[k]), 0) +
</span><span class="noop">              max(con.cpwasser/con.rschmelz*(flu.tkor[k]-con.trefn[k]), 0.)
</span><span class="noop">              )
</span><span class="noop">        else:
</span><span class="hit">            flu.wgtf[k] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_schm_wats_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the actual amount of water melting within the snow cover.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.Lnk`
</span><span class="noop">
</span><span class="noop">    Required flux sequences:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.SBes`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.WGTF`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.Schm`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_states.WATS`
</span><span class="noop">
</span><span class="noop">    Basic equations:
</span><span class="noop">      :math:`\\frac{dWATS}{dt}  = SBes - Schm`
</span><span class="noop">      :math:`Schm = \\Bigl \\lbrace
</span><span class="noop">      {
</span><span class="noop">      {WGTF \\ | \\ WATS &gt; 0}
</span><span class="noop">      \\atop
</span><span class="noop">      {0 \\ | \\ WATS = 0}
</span><span class="noop">      }`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Initialize one water and four arable land HRUs.  Assume the same
</span><span class="noop">        values for the initial amount of frozen water and the frozen
</span><span class="noop">        part of stand precipitation, but different values for the
</span><span class="noop">        potential snow melt:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(5)
</span><span class="noop">        &gt;&gt;&gt; lnk(WASSER, ACKER, ACKER, ACKER, ACKER)
</span><span class="noop">        &gt;&gt;&gt; states.wats = 2.
</span><span class="noop">        &gt;&gt;&gt; fluxes.sbes = 1.
</span><span class="noop">        &gt;&gt;&gt; fluxes.wgtf = 0., 0., 1., 3., 5.
</span><span class="noop">        &gt;&gt;&gt; model.calc_schm_wats_v1()
</span><span class="noop">        &gt;&gt;&gt; states.wats
</span><span class="noop">        wats(0.0, 3.0, 2.0, 0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.schm
</span><span class="noop">        schm(0.0, 0.0, 1.0, 3.0, 3.0)
</span><span class="noop">
</span><span class="noop">        For water areas, both the frozen amount of water and actual melt
</span><span class="noop">        are set to zero.  For all other land use classes, actual melt
</span><span class="noop">        is either limited by potential melt or the available frozen water,
</span><span class="noop">        which is the sum of initial frozen water and the frozen part
</span><span class="noop">        of stand precipitation.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        if con.lnk[k] != WASSER:
</span><span class="hit">            sta.wats[k] += flu.sbes[k]
</span><span class="hit">            flu.schm[k] = min(flu.wgtf[k], sta.wats[k])
</span><span class="hit">            sta.wats[k] -= flu.schm[k]
</span><span class="noop">        else:
</span><span class="hit">            sta.wats[k] = 0.
</span><span class="hit">            flu.schm[k] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_wada_waes_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the actual water release from the snow cover.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.Lnk`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.PWMax`
</span><span class="noop">
</span><span class="noop">    Required flux sequences:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.NBes`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.WaDa`
</span><span class="noop">
</span><span class="noop">    Required state sequences
</span><span class="noop">      :class:`~hydpy.models.lland.lland_states.WAeS`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_states.WAeS`
</span><span class="noop">
</span><span class="noop">    Basic equations:
</span><span class="noop">      :math:`\\frac{dWAeS}{dt} = NBes - WaDa`
</span><span class="noop">      :math:`WAeS \\leq PWMax \\cdot WATS`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        For simplicity, :class:`~hydpy.models.lland.lland_control.PWMax`
</span><span class="noop">        is set to a value of two for each of the five initialized HRUs.
</span><span class="noop">        Thus, the snow cover can hold as much liquid water as it contains
</span><span class="noop">        frozen water.  Stand precipitation is also always set to the same
</span><span class="noop">        value, but the initial conditions of the snow cover are varied:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(5)
</span><span class="noop">        &gt;&gt;&gt; lnk(WASSER, ACKER, ACKER, ACKER, ACKER)
</span><span class="noop">        &gt;&gt;&gt; pwmax(2.)
</span><span class="noop">        &gt;&gt;&gt; fluxes.nbes = 1.
</span><span class="noop">        &gt;&gt;&gt; states.wats = 0., 0., 1., 1.0, 1.
</span><span class="noop">        &gt;&gt;&gt; states.waes = 0., 0., 1., 1.5, 2.
</span><span class="noop">        &gt;&gt;&gt; model.calc_wada_waes_v1()
</span><span class="noop">        &gt;&gt;&gt; states.waes
</span><span class="noop">        waes(0.0, 0.0, 2.0, 2.0, 2.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.wada
</span><span class="noop">        wada(1.0, 1.0, 0.0, 0.5, 1.0)
</span><span class="noop">
</span><span class="noop">        Note the special cases of the first HRU (the snow routine is not
</span><span class="noop">        applied for water areas) and the second HRU (for all other land
</span><span class="noop">        use classes the snow routine is also applied on &#34;empty&#34; snow
</span><span class="noop">        covers with zero initial values).
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        if con.lnk[k] != WASSER:
</span><span class="hit">            sta.waes[k] += flu.nbes[k]
</span><span class="hit">            flu.wada[k] = max(sta.waes[k]-con.pwmax[k]*sta.wats[k], 0.)
</span><span class="hit">            sta.waes[k] -= flu.wada[k]
</span><span class="noop">        else:
</span><span class="hit">            sta.waes[k] = 0.
</span><span class="hit">            flu.wada[k] = flu.nbes[k]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_evb_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the actual water release from the snow cover.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.Lnk`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NFk`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.GrasRef_R`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_states.BoWa`
</span><span class="noop">
</span><span class="noop">    Required flux sequences:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.EvPo`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.EvI`
</span><span class="noop">
</span><span class="noop">    Used aide sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_aides.Temp`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.EvB`
</span><span class="noop">
</span><span class="noop">    Basic equations:
</span><span class="noop">      :math:`temp = exp(-GrasRef_R \\cdot \\frac{BoWa}{NFk})`
</span><span class="noop">      :math:`EvB = (EvPo - EvI) \\cdot
</span><span class="noop">      \\frac{1 - temp}{1 + temp -2 \\cdot exp(-GrasRef_R)}`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Soil evaporation is calculated neither for water nor for sealed
</span><span class="noop">        areas (see HRUs one and two).  All other land use classes are
</span><span class="noop">        handled in accordance with a recommendation of the set of codes
</span><span class="noop">        described in ATV-DVWK-M 504 (arable land has been selected for
</span><span class="noop">        HRUs three to six arbitrarily):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(6)
</span><span class="noop">        &gt;&gt;&gt; lnk(WASSER, VERS, ACKER, ACKER, ACKER, ACKER)
</span><span class="noop">        &gt;&gt;&gt; grasref_r(5.)
</span><span class="noop">        &gt;&gt;&gt; nfk(0., 0., 0., 100., 100., 100.)
</span><span class="noop">        &gt;&gt;&gt; fluxes.evpo = 5.
</span><span class="noop">        &gt;&gt;&gt; fluxes.evi = 3.
</span><span class="noop">        &gt;&gt;&gt; states.bowa = 0., 0., 0., 0., 50., 100.
</span><span class="noop">        &gt;&gt;&gt; model.calc_evb_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.evb
</span><span class="noop">        evb(0.0, 0.0, 0.0, 0.0, 1.717962, 2.0)
</span><span class="noop">
</span><span class="noop">        In case usable field capacity is zero, soil evaporation is
</span><span class="noop">        generally set to zero (see the third HRU).  The last three
</span><span class="noop">        HRUs demonstrate the rise in soil evaporation with increasing
</span><span class="noop">        soil moisture, lessening in the high soil moisture range.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    aid = self.sequences.aides.fastaccess
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        if ((con.lnk[k] != WASSER) and (con.lnk[k] != VERS) and
</span><span class="noop">                (con.nfk[k] &gt; 0.)):
</span><span class="hit">            aid.temp = modelutils.exp(-con.grasref_r *
</span><span class="noop">                                      sta.bowa[k]/con.nfk[k])
</span><span class="hit">            flu.evb[k] = ((flu.evpo[k]-flu.evi[k]) * (1.-aid.temp) /
</span><span class="noop">                          (1.+aid.temp-2.*modelutils.exp(-con.grasref_r)))
</span><span class="noop">        else:
</span><span class="hit">            flu.evb[k] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qbb_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the amount of base flow released from the soil.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.Lnk`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.Beta`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.FBeta`
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_derived.WB`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_derived.WZ`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_states.BoWa`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QBB`
</span><span class="noop">
</span><span class="noop">    Basic equations:
</span><span class="noop">      :math:`Beta_{eff} = \\Bigl \\lbrace
</span><span class="noop">      {
</span><span class="noop">      {Beta \\ | \\ BoWa \\leq WZ}
</span><span class="noop">      \\atop
</span><span class="noop">      {Beta \\cdot (1+(FBeta-1)\\cdot\\frac{BoWa-WZ}{NFk-WZ}) \\|\\ BoWa &gt; WZ}
</span><span class="noop">      }`
</span><span class="noop">
</span><span class="noop">      :math:`QBB = \\Bigl \\lbrace
</span><span class="noop">      {
</span><span class="noop">      {0 \\ | \\ BoWa \\leq WB}
</span><span class="noop">      \\atop
</span><span class="noop">      {Beta_{eff}  \\cdot (BoWa - WB) \\|\\ BoWa &gt; WB}
</span><span class="noop">      }`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        For water and sealed areas, no base is flow calculated (see the
</span><span class="noop">        first two HRUs).  No principal distinction is made between the
</span><span class="noop">        remaining land use classes (arable land has been selected for
</span><span class="noop">        the other five HRUs arbitrarily):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(7)
</span><span class="noop">        &gt;&gt;&gt; lnk(WASSER, VERS, ACKER, ACKER, ACKER, ACKER, ACKER)
</span><span class="noop">        &gt;&gt;&gt; beta(.04)
</span><span class="noop">        &gt;&gt;&gt; fbeta(2.)
</span><span class="noop">        &gt;&gt;&gt; nfk(0., 0., 0., 100., 100., 100., 200.)
</span><span class="noop">        &gt;&gt;&gt; derived.wb(10.)
</span><span class="noop">        &gt;&gt;&gt; derived.wz(70.)
</span><span class="noop">
</span><span class="noop">        Note the time dependence of parameter
</span><span class="noop">        :class:`~hydpy.models.lland.lland_control.Beta`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; beta
</span><span class="noop">        beta(0.04)
</span><span class="noop">        &gt;&gt;&gt; beta.values
</span><span class="noop">        array([ 0.02,  0.02,  0.02,  0.02,  0.02,  0.02,  0.02])
</span><span class="noop">
</span><span class="noop">        In the first example, the actual soil water content is set to low
</span><span class="noop">        values. For values below the threshold `wb`, not percolation occurs.
</span><span class="noop">        Above `wb` (but below `wz`), calculated percolation shows a linear
</span><span class="noop">        behaviour which is only related to parameter `beta`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; states.bowa = 0., 0., 0., 0., 10., 20., 20.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qbb_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qbb
</span><span class="noop">        qbb(0.0, 0.0, 0.0, 0.0, 0.0, 0.2, 0.2)
</span><span class="noop">
</span><span class="noop">        Note that for the last two HRUs the same amount of
</span><span class="noop">        base flow generation is determined, in spite of the fact
</span><span class="noop">        that both exhibit different relative soil moistures.  It is
</span><span class="noop">        common to modify this &#34;pure absolute dependency&#34; to a &#34;mixed
</span><span class="noop">        absolute/relative dependency&#34; through defining the values of
</span><span class="noop">        parameter :class:`~hydpy.models.lland.lland_derived.WB` indirectly
</span><span class="noop">        via parameter :class:`~hydpy.models.lland.lland_control.RelWB`.
</span><span class="noop">
</span><span class="noop">        In the second example, the actual soil water content is set to high
</span><span class="noop">        values.  For values below the threshold `wz`, the disussion above
</span><span class="noop">        remains valid.  For values above `wz`, percolation shows a nonlinear
</span><span class="noop">        behaviour in case factor `fbeta` is set to value larger than one:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; nfk(0., 0., 100., 100., 100, 100., 200.)
</span><span class="noop">        &gt;&gt;&gt; states.bowa = 0., 0., 60., 70., 80., 100., 200.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qbb_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qbb
</span><span class="noop">        qbb(0.0, 0.0, 1.0, 1.2, 1.866667, 3.6, 7.6)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        if ((con.lnk[k] == WASSER) or (con.lnk[k] == VERS) or
</span><span class="noop">                (sta.bowa[k] &lt;= der.wb[k]) or (con.nfk[k] &lt;= 0.)):
</span><span class="hit">            flu.qbb[k] = 0.
</span><span class="hit">        elif sta.bowa[k] &lt;= der.wz[k]:
</span><span class="hit">            flu.qbb[k] = con.beta[k]*(sta.bowa[k]-der.wb[k])
</span><span class="noop">        else:
</span><span class="hit">            flu.qbb[k] = (con.beta[k]*(sta.bowa[k]-der.wb[k]) *
</span><span class="noop">                          (1.+(con.fbeta[k]-1.)*((sta.bowa[k]-der.wz[k]) /
</span><span class="noop">                                                 (con.nfk[k]-der.wz[k]))))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qib1_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the first inflow component released from the soil.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.Lnk`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NFk`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.DMin`
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_derived.WB`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_states.BoWa`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QIB1`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`QIB1 = DMin \\cdot \\frac{BoWa}{NFk}`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        For water and sealed areas, no interflow is calculated (see the
</span><span class="noop">        first two HRUs).  No principal distinction is made between the
</span><span class="noop">        remaining land use classes (arable land has been selected for
</span><span class="noop">        the other five HRUs arbitrarily):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(7)
</span><span class="noop">        &gt;&gt;&gt; lnk(WASSER, VERS, ACKER, ACKER, ACKER, ACKER, ACKER)
</span><span class="noop">        &gt;&gt;&gt; dmax(10.)
</span><span class="noop">        &gt;&gt;&gt; dmin(4.)
</span><span class="noop">        &gt;&gt;&gt; nfk(0., 0., 0., 101., 101., 101., 202.)
</span><span class="noop">        &gt;&gt;&gt; derived.wb(10.)
</span><span class="noop">        &gt;&gt;&gt; states.bowa = 0., 0., 0., 0., 10., 10.1, 10.1
</span><span class="noop">
</span><span class="noop">        Note the time dependence of parameter
</span><span class="noop">        :class:`~hydpy.models.lland.lland_control.DMin`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; dmin
</span><span class="noop">        dmin(4.0)
</span><span class="noop">        &gt;&gt;&gt; dmin.values
</span><span class="noop">        array([ 2.,  2.,  2.,  2.,  2.,  2.,  2.])
</span><span class="noop">
</span><span class="noop">        Compared to the calculation of
</span><span class="noop">        :class:`~hydpy.models.lland.lland_fluxes.QBB`, the following
</span><span class="noop">        results show some relevant differences:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.calc_qib1_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qib1
</span><span class="noop">        qib1(0.0, 0.0, 0.0, 0.0, 0.0, 0.2, 0.1)
</span><span class="noop">
</span><span class="noop">        Firstly, as demonstrated with the help of the sixths and the
</span><span class="noop">        sevenths HRU the generation of first interflow component depends
</span><span class="noop">        on the relative soil moisture.  Secondly, as demonstratd with the
</span><span class="noop">        help the fifths and the sixths HRU, it starts abruptly whenever
</span><span class="noop">        there is the slightest exceedance of the threshold  parameter
</span><span class="noop">        :class:`~hydpy.models.lland.lland_derived.WB` occurs.  Such step
</span><span class="noop">        functions are a potential source of trouble.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        if ((con.lnk[k] != WASSER) and (con.lnk[k] != VERS) and
</span><span class="noop">                (sta.bowa[k] &gt; der.wb[k])):
</span><span class="hit">            flu.qib1[k] = con.dmin[k]*(sta.bowa[k]/con.nfk[k])
</span><span class="noop">        else:
</span><span class="hit">            flu.qib1[k] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qib2_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the first inflow component released from the soil.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.Lnk`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NFk`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.DMin`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.DMax`
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_derived.WZ`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_states.BoWa`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QIB2`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`QIB2 = (DMax-DMin) \\cdot
</span><span class="noop">      (\\frac{BoWa-WZ}{NFk-WZ})^\\frac{3}{2}`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        For water and sealed areas, no interflow is calculated (see the
</span><span class="noop">        first two HRUs).  No principal distinction is made between the
</span><span class="noop">        remaining land use classes (arable land has been selected for
</span><span class="noop">        the other five HRUs arbitrarily):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(7)
</span><span class="noop">        &gt;&gt;&gt; lnk(WASSER, VERS, ACKER, ACKER, ACKER, ACKER, ACKER)
</span><span class="noop">        &gt;&gt;&gt; dmax(10.)
</span><span class="noop">        &gt;&gt;&gt; dmin(4.)
</span><span class="noop">        &gt;&gt;&gt; nfk(0., 0., 50., 100., 100., 100., 200.)
</span><span class="noop">        &gt;&gt;&gt; derived.wz(50.)
</span><span class="noop">        &gt;&gt;&gt; states.bowa = 0., 0., 50.1, 50., 75., 100., 100.
</span><span class="noop">
</span><span class="noop">        Note the time dependence of parameters
</span><span class="noop">        :class:`~hydpy.models.lland.lland_control.DMin` (see the example
</span><span class="noop">        above) and :class:`~hydpy.models.lland.lland_control.DMax`:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; dmax
</span><span class="noop">        dmax(10.0)
</span><span class="noop">        &gt;&gt;&gt; dmax.values
</span><span class="noop">        array([ 5.,  5.,  5.,  5.,  5.,  5.,  5.])
</span><span class="noop">
</span><span class="noop">        The following results show that he calculation of
</span><span class="noop">        :class:`~hydpy.models.lland.lland_fluxes.QIB2` both resembles
</span><span class="noop">        those of :class:`~hydpy.models.lland.lland_fluxes.QBB` and
</span><span class="noop">        :class:`~hydpy.models.lland.lland_fluxes.QIB1` in some regards:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; model.calc_qib2_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qib2
</span><span class="noop">        qib2(0.0, 0.0, 0.0, 0.0, 1.06066, 3.0, 0.57735)
</span><span class="noop">
</span><span class="noop">        In the given example, the maximum rate of total interflow
</span><span class="noop">        generation is 5mm/12h.  For the sixths zone, which contains
</span><span class="noop">        a saturated soil, a value of 3mm/h is calculated.  The &#34;missing&#34;
</span><span class="noop">        2mm/12h would be added to the inflow concentration routine via
</span><span class="noop">        :class:`~hydpy.models.lland.lland_fluxes.QIB1`.
</span><span class="noop">
</span><span class="noop">        (The third zone, which is slightly oversaturated, is only intended
</span><span class="noop">        to demonstrate that zero division due to nfk=wz is circumvented.)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        if ((con.lnk[k] != WASSER) and (con.lnk[k] != VERS) and
</span><span class="noop">                (sta.bowa[k] &gt; der.wz[k]) and (con.nfk[k] &gt; der.wz[k])):
</span><span class="hit">            flu.qib2[k] = ((con.dmax[k]-con.dmin[k]) *
</span><span class="noop">                           ((sta.bowa[k]-der.wz[k]) /
</span><span class="noop">                            (con.nfk[k]-der.wz[k]))**1.5)
</span><span class="noop">        else:
</span><span class="hit">            flu.qib2[k] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qdb_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate direct runoff released from the soil.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.Lnk`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NFk`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.BSF`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_states.BoWa`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.WaDa`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QDB`
</span><span class="noop">
</span><span class="noop">    Basic equations:
</span><span class="noop">      :math:`QDB = \\Bigl \\lbrace
</span><span class="noop">      {
</span><span class="noop">      {max(Exz, 0) \\ | \\ SfA \\leq 0}
</span><span class="noop">      \\atop
</span><span class="noop">      {max(Exz + NFk \\cdot SfA^{BSf+1}, 0) \\ | \\ SfA &gt; 0}
</span><span class="noop">      }`
</span><span class="noop">      :math:`SFA = (1 - \\frac{BoWa}{NFk})^\\frac{1}{BSf+1} -
</span><span class="noop">      \\frac{WaDa}{(BSf+1) \\cdot NFk}`
</span><span class="noop">      :math:`Exz = (BoWa + WaDa) - NFk`
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        For water areas, sealed areas, and areas without any soil storage
</span><span class="noop">        capacity, all water is completely routed as direct runoff (see the
</span><span class="noop">        first three HRUs).  No principal distinction is made between the
</span><span class="noop">        remaining land use classes (arable land has been selected for
</span><span class="noop">        the other five HRUs arbitrarily):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(8)
</span><span class="noop">        &gt;&gt;&gt; lnk(WASSER, VERS, ACKER, ACKER, ACKER, ACKER, ACKER, ACKER)
</span><span class="noop">        &gt;&gt;&gt; bsf(0.4)
</span><span class="noop">        &gt;&gt;&gt; nfk(0., 0., 0., 100., 100., 100., 100., 100.)
</span><span class="noop">        &gt;&gt;&gt; fluxes.wada = 10.
</span><span class="noop">        &gt;&gt;&gt; states.bowa = 0., 0., 0., -.1, 0., 50., 100., 100.1
</span><span class="noop">        &gt;&gt;&gt; model.calc_qdb_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qdb
</span><span class="noop">        qdb(10.0, 10.0, 10.0, 0.142039, 0.144959, 1.993649, 10.0, 10.1)
</span><span class="noop">
</span><span class="noop">        With the common bsf value of 0.4, the discharge coefficient
</span><span class="noop">        increases more or less exponentially with soil moisture.
</span><span class="noop">        For soil moisture values slightly below zero or above usable
</span><span class="noop">        field capacity, plausible amounts of generated direct runoff
</span><span class="noop">        are ensured.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    aid = self.sequences.aides.fastaccess
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        if ((con.lnk[k] != WASSER) and (con.lnk[k] != VERS) and
</span><span class="noop">                (con.nfk[k] &gt; 0.)):
</span><span class="hit">            if sta.bowa[k] &lt; con.nfk[k]:
</span><span class="hit">                aid.sfa[k] = (
</span><span class="noop">                    (1.-sta.bowa[k]/con.nfk[k])**(1./(con.bsf[k]+1.)) -
</span><span class="noop">                    (flu.wada[k]/((con.bsf[k]+1.)*con.nfk[k])))
</span><span class="noop">            else:
</span><span class="hit">                aid.sfa[k] = 0.
</span><span class="hit">            aid.exz[k] = sta.bowa[k]+flu.wada[k]-con.nfk[k]
</span><span class="hit">            flu.qdb[k] = aid.exz[k]
</span><span class="hit">            if aid.sfa[k] &gt; 0.:
</span><span class="hit">                flu.qdb[k] += aid.sfa[k]**(con.bsf[k]+1.)*con.nfk[k]
</span><span class="hit">            flu.qdb[k] = max(flu.qdb[k], 0.)
</span><span class="noop">        else:
</span><span class="hit">            flu.qdb[k] = flu.wada[k]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_bowa_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Update soil moisture and correct fluxes if necessary.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.Lnk`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.WaDa`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_states.BoWa`
</span><span class="noop">
</span><span class="noop">    Required (and eventually corrected) flux sequences:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.EvB`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QBB`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QIB1`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QIB2`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QDB`
</span><span class="noop">
</span><span class="noop">    Basic equations:
</span><span class="noop">       :math:`\\frac{dBoWa}{dt} = WaDa - EvB - QBB - QIB1 - QIB2 - QDB`
</span><span class="noop">       :math:`BoWa \\geq 0`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        For water areas and sealed areas, soil moisture is simply set to
</span><span class="noop">        zero and no flux corrections need not be performed.  No principal
</span><span class="noop">        distinction is made between the remaining land use classes (arable
</span><span class="noop">        land has been selected for the other four HRUs arbitrarily):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(6)
</span><span class="noop">        &gt;&gt;&gt; lnk(WASSER, VERS, ACKER, ACKER, ACKER, ACKER)
</span><span class="noop">        &gt;&gt;&gt; states.bowa = 2.
</span><span class="noop">        &gt;&gt;&gt; fluxes.wada = 1.
</span><span class="noop">        &gt;&gt;&gt; fluxes.evb(0., 0., 0., .1, .2, .3)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qbb(0., 0., 0., .2, .4, .6)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qib1(0., 0., 0., .3, .6, .9)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qib2(0., 0., 0., .4, .8, 1.2)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qdb(0., 0., 0., .5, 1., 1.5)
</span><span class="noop">        &gt;&gt;&gt; model.calc_bowa_v1()
</span><span class="noop">        &gt;&gt;&gt; states.bowa
</span><span class="noop">        bowa(0.0, 0.0, 3.0, 1.5, 0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.evb
</span><span class="noop">        evb(0.0, 0.0, 0.0, 0.1, 0.2, 0.2)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qbb
</span><span class="noop">        qbb(0.0, 0.0, 0.0, 0.2, 0.4, 0.4)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qib1
</span><span class="noop">        qib1(0.0, 0.0, 0.0, 0.3, 0.6, 0.6)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qib2
</span><span class="noop">        qib2(0.0, 0.0, 0.0, 0.4, 0.8, 0.8)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qdb
</span><span class="noop">        qdb(0.0, 0.0, 0.0, 0.5, 1.0, 1.0)
</span><span class="noop">
</span><span class="noop">        For the sixths HRU, the original loss terms would result in
</span><span class="noop">        negative soil moisture values.  They are corrected to the same
</span><span class="noop">        loss terms of the fifths HRU, which result in a complete
</span><span class="noop">        emptying of the soil storage exactly.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    aid = self.sequences.aides.fastaccess
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        if (con.lnk[k] != WASSER) and (con.lnk[k] != VERS):
</span><span class="hit">            aid.bvl[k] = (flu.evb[k] +
</span><span class="noop">                          flu.qbb[k]+flu.qib1[k]+flu.qib2[k]+flu.qdb[k])
</span><span class="hit">            aid.mvl[k] = sta.bowa[k]+flu.wada[k]
</span><span class="hit">            if aid.bvl[k] &gt; aid.mvl[k]:
</span><span class="hit">                aid.rvl[k] = aid.mvl[k]/aid.bvl[k]
</span><span class="hit">                flu.evb[k] *= aid.rvl[k]
</span><span class="hit">                flu.qbb[k] *= aid.rvl[k]
</span><span class="hit">                flu.qib1[k] *= aid.rvl[k]
</span><span class="hit">                flu.qib2[k] *= aid.rvl[k]
</span><span class="hit">                flu.qdb[k] *= aid.rvl[k]
</span><span class="hit">                sta.bowa[k] = 0.
</span><span class="noop">            else:
</span><span class="hit">                sta.bowa[k] = aid.mvl[k]-aid.bvl[k]
</span><span class="noop">        else:
</span><span class="hit">            sta.bowa[k] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qbgz_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Aggregate the amount of base flow released by all HRUs.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.FHRU`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QBB`
</span><span class="noop">
</span><span class="noop">    Calculated state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QBGZ`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">       :math:`QBGZ = \\Sigma(FHRU \\cdot QBB)`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; nhru(2)
</span><span class="noop">        &gt;&gt;&gt; lnk(ACKER, ACKER)
</span><span class="noop">        &gt;&gt;&gt; fhru(.75, .25)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qbb = 1., 5.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qbgz_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qbgz
</span><span class="noop">        qbgz(2.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    sta.qbgz = 0.
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        sta.qbgz += con.fhru[k]*flu.qbb[k]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qigz1_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Aggregate the amount of the first interflow component released
</span><span class="noop">    by all HRUs.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.FHRU`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QIB1`
</span><span class="noop">
</span><span class="noop">    Calculated state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QIGZ1`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">       :math:`QIGZ1 = \\Sigma(FHRU \\cdot QIB1)`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; nhru(2)
</span><span class="noop">        &gt;&gt;&gt; lnk(ACKER, ACKER)
</span><span class="noop">        &gt;&gt;&gt; fhru(.75, .25)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qib1 = 1., 5.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qigz1_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qigz1
</span><span class="noop">        qigz1(2.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    sta.qigz1 = 0.
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        sta.qigz1 += con.fhru[k]*flu.qib1[k]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qigz2_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Aggregate the amount of the second interflow component released
</span><span class="noop">    by all HRUs.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.FHRU`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QIB2`
</span><span class="noop">
</span><span class="noop">    Calculated state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QIGZ2`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">       :math:`QIGZ2 = \\Sigma(FHRU \\cdot QIB2)`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; nhru(2)
</span><span class="noop">        &gt;&gt;&gt; lnk(ACKER, ACKER)
</span><span class="noop">        &gt;&gt;&gt; fhru(.75, .25)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qib2 = 1., 5.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qigz2_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qigz2
</span><span class="noop">        qigz2(2.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    sta.qigz2 = 0.
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        sta.qigz2 += con.fhru[k]*flu.qib2[k]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qdgz_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Aggregate the amount of total direct flow released by all HRUs.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.FHRU`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QDB`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QDGZ`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">       :math:`QDGZ = \\Sigma(FHRU \\cdot QDB)`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; nhru(2)
</span><span class="noop">        &gt;&gt;&gt; lnk(ACKER, ACKER)
</span><span class="noop">        &gt;&gt;&gt; fhru(.75, .25)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qdb = 1., 5.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qdgz_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qdgz
</span><span class="noop">        qdgz(2.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    flu.qdgz = 0.
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        flu.qdgz += con.fhru[k]*flu.qdb[k]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qdgz1_qdgz2_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Seperate total direct flow into a small and a fast component.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.A1`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.A2`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QDGZ`
</span><span class="noop">
</span><span class="noop">    Calculated state sequences:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QDGZ1`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QDGZ2`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">       :math:`QDGZ2 = \\frac{(QDGZ-A2)^2}{QDGZ+A1-A2}`
</span><span class="noop">       :math:`QDGZ1 = QDGZ - QDGZ1`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        The formula for calculating the amount of the fast component of
</span><span class="noop">        direct flow is borrowed from the famous curve number approach.
</span><span class="noop">        Parameter :class:`A2` would be the initial loss and parameter
</span><span class="noop">        :class:`A1` the maximum storage, but one should not take this
</span><span class="noop">        analogy too serious.  Instead, with the value of parameter `a1`
</span><span class="noop">        set to zero, parameter `a2` just defines the maximum amount of
</span><span class="noop">        &#34;slow&#34; direct runoff per time step:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; simulationstep(&#39;12h&#39;)
</span><span class="noop">        &gt;&gt;&gt; a1(0.)
</span><span class="noop">
</span><span class="noop">        Let us set the value of `a2` to 4 mm/d, which is 2 mm/12h with
</span><span class="noop">        respect to the selected simulation step size:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; a2(4.)
</span><span class="noop">        &gt;&gt;&gt; a2
</span><span class="noop">        a2(4.0)
</span><span class="noop">        &gt;&gt;&gt; a2.value
</span><span class="noop">        2.0
</span><span class="noop">
</span><span class="noop">        Define a small test function to shorten the following examples:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; def test(*values):
</span><span class="noop">        ...     for value in values:
</span><span class="noop">        ...         fluxes.qdgz = value
</span><span class="noop">        ...         model.calc_qdgz1_qdgz2_v1()
</span><span class="noop">        ...         print(fluxes.qdgz, states.qdgz1, states.qdgz2)
</span><span class="noop">
</span><span class="noop">        The results of the seperation for total direct flow volumes of
</span><span class="noop">        1, 2, 3 and 4 mm/12h are:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; test(1., 2., 3., 100.)
</span><span class="noop">        qdgz(1.0) qdgz1(1.0) qdgz2(0.0)
</span><span class="noop">        qdgz(2.0) qdgz1(2.0) qdgz2(0.0)
</span><span class="noop">        qdgz(3.0) qdgz1(2.0) qdgz2(1.0)
</span><span class="noop">        qdgz(100.0) qdgz1(2.0) qdgz2(98.0)
</span><span class="noop">
</span><span class="noop">        Setting `a2` to zero and `a1` to 4 mm/d (or 2mm/12h)...
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; a2(0.)
</span><span class="noop">        &gt;&gt;&gt; a1(4.)
</span><span class="noop">        &gt;&gt;&gt; a1
</span><span class="noop">        a1(4.0)
</span><span class="noop">        &gt;&gt;&gt; a1.value
</span><span class="noop">        2.0
</span><span class="noop">
</span><span class="noop">        ...results in a smoother transition instead:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; test(1., 2., 3., 100.)
</span><span class="noop">        qdgz(1.0) qdgz1(0.666667) qdgz2(0.333333)
</span><span class="noop">        qdgz(2.0) qdgz1(1.0) qdgz2(1.0)
</span><span class="noop">        qdgz(3.0) qdgz1(1.2) qdgz2(1.8)
</span><span class="noop">        qdgz(100.0) qdgz1(1.960784) qdgz2(98.039216)
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">        Alternatively, one can mix these two configurations by setting
</span><span class="noop">        the values of both parameters to 2 mm/h:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; a2(2.)
</span><span class="noop">        &gt;&gt;&gt; a1(2.)
</span><span class="noop">        &gt;&gt;&gt; test(1., 2., 3., 100.)
</span><span class="noop">        qdgz(1.0) qdgz1(1.0) qdgz2(0.0)
</span><span class="noop">        qdgz(2.0) qdgz1(1.5) qdgz2(0.5)
</span><span class="noop">        qdgz(3.0) qdgz1(1.666667) qdgz2(1.333333)
</span><span class="noop">        qdgz(100.0) qdgz1(1.99) qdgz2(98.01)
</span><span class="noop">
</span><span class="noop">        Note the similarity of the results for very high values of total
</span><span class="noop">        direct flow in all three examples, which converge to the sum of
</span><span class="noop">        the values of parameter `a1` and `a2`, representing the maximum
</span><span class="noop">        value of `slow` direct flow generation per simulation step
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    if flu.qdgz &gt; con.a2:
</span><span class="hit">        sta.qdgz2 = (flu.qdgz-con.a2)**2/(flu.qdgz+con.a1-con.a2)
</span><span class="hit">        sta.qdgz1 = flu.qdgz-sta.qdgz2
</span><span class="noop">    else:
</span><span class="hit">        sta.qdgz2 = 0.
</span><span class="hit">        sta.qdgz1 = flu.qdgz
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qbga_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Perform the runoff concentration calculation for base flow.
</span><span class="noop">
</span><span class="noop">    The working equation is the analytical solution of the linear storage
</span><span class="noop">    equation under the assumption of constant change in inflow during
</span><span class="noop">    the simulation time step.
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.KB`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QBGZ`
</span><span class="noop">
</span><span class="noop">    Calculated state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QBGA`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">       :math:`QBGA_{neu} = QBGA_{alt} +
</span><span class="noop">       (QBGZ_{alt}-QBGA_{alt}) \\cdot (1-exp(-KB^{-1})) +
</span><span class="noop">       (QBGZ_{neu}-QBGZ_{alt}) \\cdot (1-KB\\cdot(1-exp(-KB^{-1})))`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        A normal test case:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; derived.kb(0.1)
</span><span class="noop">        &gt;&gt;&gt; states.qbgz.old = 2.
</span><span class="noop">        &gt;&gt;&gt; states.qbgz.new = 4.
</span><span class="noop">        &gt;&gt;&gt; states.qbga.old = 3.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qbga_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qbga
</span><span class="noop">        qbga(3.800054)
</span><span class="noop">
</span><span class="noop">        First extreme test case (zero division is circumvented):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.kb(0.)
</span><span class="noop">        &gt;&gt;&gt; model.calc_qbga_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qbga
</span><span class="noop">        qbga(4.0)
</span><span class="noop">
</span><span class="noop">        Second extreme test case (numerical overflow is circumvented):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.kb(1e200)
</span><span class="noop">        &gt;&gt;&gt; model.calc_qbga_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qbga
</span><span class="noop">        qbga(5.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    old = self.sequences.states.fastaccess_old
</span><span class="hit">    new = self.sequences.states.fastaccess_new
</span><span class="hit">    aid = self.sequences.aides.fastaccess
</span><span class="hit">    if der.kb &lt;= 0.:
</span><span class="hit">        new.qbga = new.qbgz
</span><span class="hit">    elif der.kb &gt; 1e200:
</span><span class="miss">        new.qbga = old.qbga+new.qbgz-old.qbgz
</span><span class="noop">    else:
</span><span class="hit">        aid.temp = (1.-modelutils.exp(-1./der.kb))
</span><span class="hit">        new.qbga = (old.qbga +
</span><span class="noop">                    (old.qbgz-old.qbga)*aid.temp +
</span><span class="noop">                    (new.qbgz-old.qbgz)*(1.-der.kb*aid.temp))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qiga1_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Perform the runoff concentration calculation for the first
</span><span class="noop">    interflow component.
</span><span class="noop">
</span><span class="noop">    The working equation is the analytical solution of the linear storage
</span><span class="noop">    equation under the assumption of constant change in inflow during
</span><span class="noop">    the simulation time step.
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.KI1`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QIGZ1`
</span><span class="noop">
</span><span class="noop">    Calculated state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QIGA1`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">       :math:`QIGA1_{neu} = QIGA1_{alt} +
</span><span class="noop">       (QIGZ1_{alt}-QIGA1_{alt}) \\cdot (1-exp(-KI1^{-1})) +
</span><span class="noop">       (QIGZ1_{neu}-QIGZ1_{alt}) \\cdot (1-KI1\\cdot(1-exp(-KI1^{-1})))`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        A normal test case:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; derived.ki1(0.1)
</span><span class="noop">        &gt;&gt;&gt; states.qigz1.old = 2.
</span><span class="noop">        &gt;&gt;&gt; states.qigz1.new = 4.
</span><span class="noop">        &gt;&gt;&gt; states.qiga1.old = 3.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qiga1_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qiga1
</span><span class="noop">        qiga1(3.800054)
</span><span class="noop">
</span><span class="noop">        First extreme test case (zero division is circumvented):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.ki1(0.)
</span><span class="noop">        &gt;&gt;&gt; model.calc_qiga1_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qiga1
</span><span class="noop">        qiga1(4.0)
</span><span class="noop">
</span><span class="noop">        Second extreme test case (numerical overflow is circumvented):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.ki1(1e200)
</span><span class="noop">        &gt;&gt;&gt; model.calc_qiga1_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qiga1
</span><span class="noop">        qiga1(5.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    old = self.sequences.states.fastaccess_old
</span><span class="hit">    new = self.sequences.states.fastaccess_new
</span><span class="hit">    aid = self.sequences.aides.fastaccess
</span><span class="hit">    if der.ki1 &lt;= 0.:
</span><span class="hit">        new.qiga1 = new.qigz1
</span><span class="hit">    elif der.ki1 &gt; 1e200:
</span><span class="miss">        new.qiga1 = old.qiga1+new.qigz1-old.qigz1
</span><span class="noop">    else:
</span><span class="hit">        aid.temp = (1.-modelutils.exp(-1./der.ki1))
</span><span class="hit">        new.qiga1 = (old.qiga1 +
</span><span class="noop">                     (old.qigz1-old.qiga1)*aid.temp +
</span><span class="noop">                     (new.qigz1-old.qigz1)*(1.-der.ki1*aid.temp))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qiga2_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Perform the runoff concentration calculation for the second
</span><span class="noop">    interflow component.
</span><span class="noop">
</span><span class="noop">    The working equation is the analytical solution of the linear storage
</span><span class="noop">    equation under the assumption of constant change in inflow during
</span><span class="noop">    the simulation time step.
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.KI2`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QIGZ2`
</span><span class="noop">
</span><span class="noop">    Calculated state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QIGA2`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">       :math:`QIGA2_{neu} = QIGA2_{alt} +
</span><span class="noop">       (QIGZ2_{alt}-QIGA2_{alt}) \\cdot (1-exp(-KI2^{-1})) +
</span><span class="noop">       (QIGZ2_{neu}-QIGZ2_{alt}) \\cdot (1-KI2\\cdot(1-exp(-KI2^{-1})))`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        A normal test case:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; derived.ki2(0.1)
</span><span class="noop">        &gt;&gt;&gt; states.qigz2.old = 2.
</span><span class="noop">        &gt;&gt;&gt; states.qigz2.new = 4.
</span><span class="noop">        &gt;&gt;&gt; states.qiga2.old = 3.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qiga2_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qiga2
</span><span class="noop">        qiga2(3.800054)
</span><span class="noop">
</span><span class="noop">        First extreme test case (zero division is circumvented):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.ki2(0.)
</span><span class="noop">        &gt;&gt;&gt; model.calc_qiga2_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qiga2
</span><span class="noop">        qiga2(4.0)
</span><span class="noop">
</span><span class="noop">        Second extreme test case (numerical overflow is circumvented):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.ki2(1e200)
</span><span class="noop">        &gt;&gt;&gt; model.calc_qiga2_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qiga2
</span><span class="noop">        qiga2(5.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    old = self.sequences.states.fastaccess_old
</span><span class="hit">    new = self.sequences.states.fastaccess_new
</span><span class="hit">    aid = self.sequences.aides.fastaccess
</span><span class="hit">    if der.ki2 &lt;= 0.:
</span><span class="hit">        new.qiga2 = new.qigz2
</span><span class="hit">    elif der.ki2 &gt; 1e200:
</span><span class="miss">        new.qiga2 = old.qiga2+new.qigz2-old.qigz2
</span><span class="noop">    else:
</span><span class="hit">        aid.temp = (1.-modelutils.exp(-1./der.ki2))
</span><span class="hit">        new.qiga2 = (old.qiga2 +
</span><span class="noop">                     (old.qigz2-old.qiga2)*aid.temp +
</span><span class="noop">                     (new.qigz2-old.qigz2)*(1.-der.ki2*aid.temp))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qdga1_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Perform the runoff concentration calculation for &#34;slow&#34; direct runoff.
</span><span class="noop">
</span><span class="noop">    The working equation is the analytical solution of the linear storage
</span><span class="noop">    equation under the assumption of constant change in inflow during
</span><span class="noop">    the simulation time step.
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_derived.KD1`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QDGZ1`
</span><span class="noop">
</span><span class="noop">    Calculated state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QDGA1`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">       :math:`QDGA1_{neu} = QDGA1_{alt} +
</span><span class="noop">       (QDGZ1_{alt}-QDGA1_{alt}) \\cdot (1-exp(-KD1^{-1})) +
</span><span class="noop">       (QDGZ1_{neu}-QDGZ1_{alt}) \\cdot (1-KD1\\cdot(1-exp(-KD1^{-1})))`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        A normal test case:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; derived.kd1(0.1)
</span><span class="noop">        &gt;&gt;&gt; states.qdgz1.old = 2.
</span><span class="noop">        &gt;&gt;&gt; states.qdgz1.new = 4.
</span><span class="noop">        &gt;&gt;&gt; states.qdga1.old = 3.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qdga1_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qdga1
</span><span class="noop">        qdga1(3.800054)
</span><span class="noop">
</span><span class="noop">        First extreme test case (zero division is circumvented):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.kd1(0.)
</span><span class="noop">        &gt;&gt;&gt; model.calc_qdga1_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qdga1
</span><span class="noop">        qdga1(4.0)
</span><span class="noop">
</span><span class="noop">        Second extreme test case (numerical overflow is circumvented):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.kd1(1e200)
</span><span class="noop">        &gt;&gt;&gt; model.calc_qdga1_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qdga1
</span><span class="noop">        qdga1(5.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    old = self.sequences.states.fastaccess_old
</span><span class="hit">    new = self.sequences.states.fastaccess_new
</span><span class="hit">    aid = self.sequences.aides.fastaccess
</span><span class="hit">    if der.kd1 &lt;= 0.:
</span><span class="hit">        new.qdga1 = new.qdgz1
</span><span class="hit">    elif der.kd1 &gt; 1e200:
</span><span class="miss">        new.qdga1 = old.qdga1+new.qdgz1-old.qdgz1
</span><span class="noop">    else:
</span><span class="hit">        aid.temp = (1.-modelutils.exp(-1./der.kd1))
</span><span class="hit">        new.qdga1 = (old.qdga1 +
</span><span class="noop">                     (old.qdgz1-old.qdga1)*aid.temp +
</span><span class="noop">                     (new.qdgz1-old.qdgz1)*(1.-der.kd1*aid.temp))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qdga2_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Perform the runoff concentration calculation for &#34;fast&#34; direct runoff.
</span><span class="noop">
</span><span class="noop">    The working equation is the analytical solution of the linear storage
</span><span class="noop">    equation under the assumption of constant change in inflow during
</span><span class="noop">    the simulation time step.
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_derived.KD2`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QDGZ2`
</span><span class="noop">
</span><span class="noop">    Calculated state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QDGA2`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">       :math:`QDGA2_{neu} = QDGA2_{alt} +
</span><span class="noop">       (QDGZ2_{alt}-QDGA2_{alt}) \\cdot (1-exp(-KD2^{-1})) +
</span><span class="noop">       (QDGZ2_{neu}-QDGZ2_{alt}) \\cdot (1-KD2\\cdot(1-exp(-KD2^{-1})))`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        A normal test case:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; derived.kd2(0.1)
</span><span class="noop">        &gt;&gt;&gt; states.qdgz2.old = 2.
</span><span class="noop">        &gt;&gt;&gt; states.qdgz2.new = 4.
</span><span class="noop">        &gt;&gt;&gt; states.qdga2.old = 3.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qdga2_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qdga2
</span><span class="noop">        qdga2(3.800054)
</span><span class="noop">
</span><span class="noop">        First extreme test case (zero division is circumvented):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.kd2(0.)
</span><span class="noop">        &gt;&gt;&gt; model.calc_qdga2_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qdga2
</span><span class="noop">        qdga2(4.0)
</span><span class="noop">
</span><span class="noop">        Second extreme test case (numerical overflow is circumvented):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.kd2(1e200)
</span><span class="noop">        &gt;&gt;&gt; model.calc_qdga2_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qdga2
</span><span class="noop">        qdga2(5.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    old = self.sequences.states.fastaccess_old
</span><span class="hit">    new = self.sequences.states.fastaccess_new
</span><span class="hit">    aid = self.sequences.aides.fastaccess
</span><span class="hit">    if der.kd2 &lt;= 0.:
</span><span class="hit">        new.qdga2 = new.qdgz2
</span><span class="hit">    elif der.kd2 &gt; 1e200:
</span><span class="miss">        new.qdga2 = old.qdga2+new.qdgz2-old.qdgz2
</span><span class="noop">    else:
</span><span class="hit">        aid.temp = (1.-modelutils.exp(-1./der.kd2))
</span><span class="hit">        new.qdga2 = (old.qdga2 +
</span><span class="noop">                     (old.qdgz2-old.qdga2)*aid.temp +
</span><span class="noop">                     (new.qdgz2-old.qdgz2)*(1.-der.kd2*aid.temp))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_q_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the final runoff.
</span><span class="noop">
</span><span class="noop">    Note that, in case there are water areas, their (interception)
</span><span class="noop">    evaporation values are subtracted from the &#34;potential&#34; runoff value.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.NHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.FHRU`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_control.Lnk`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.EvI`
</span><span class="noop">
</span><span class="noop">    Required state sequences:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QBGA`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QIGA1`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QIGA2`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QDGA1`
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.QDGA2`
</span><span class="noop">
</span><span class="noop">    Calculated state sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.Q`
</span><span class="noop">
</span><span class="noop">    Basic equations:
</span><span class="noop">       :math:`Q = QBGA + QIGA1 + QIGA2 + QDGA1 + QDGA2 - EvI_{WASSER}`
</span><span class="noop">       :math:`Q \\geq 0`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        When there are no water areas in the respective subbasin, the
</span><span class="noop">        different runoff components are simply summed up:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; nhru(3)
</span><span class="noop">        &gt;&gt;&gt; lnk(ACKER, VERS, NADELW)
</span><span class="noop">        &gt;&gt;&gt; fhru(0.5, 0.2, 0.3)
</span><span class="noop">        &gt;&gt;&gt; states.qbga = .1
</span><span class="noop">        &gt;&gt;&gt; states.qiga1 = .3
</span><span class="noop">        &gt;&gt;&gt; states.qiga2 = .5
</span><span class="noop">        &gt;&gt;&gt; states.qdga1 = .7
</span><span class="noop">        &gt;&gt;&gt; states.qdga2 = .9
</span><span class="noop">        &gt;&gt;&gt; fluxes.evi = 4., 5., 3.
</span><span class="noop">        &gt;&gt;&gt; model.calc_q_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.q
</span><span class="noop">        q(2.5)
</span><span class="noop">        &gt;&gt;&gt; fluxes.evi
</span><span class="noop">        evi(4.0, 5.0, 3.0)
</span><span class="noop">
</span><span class="noop">        The defined values of interception evaporation do not show any
</span><span class="noop">        impact on the result of the given example.  But when the first
</span><span class="noop">        HRU is assumed to be a water area, its interception evaporation
</span><span class="noop">        is subtracted:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; control.lnk(WASSER, VERS, NADELW)
</span><span class="noop">        &gt;&gt;&gt; model.calc_q_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.q
</span><span class="noop">        q(0.5)
</span><span class="noop">        &gt;&gt;&gt; fluxes.evi
</span><span class="noop">        evi(4.0, 5.0, 3.0)
</span><span class="noop">
</span><span class="noop">        Note that only 2mm instead of 4mm are subtracted, as the first
</span><span class="noop">        HRU`s area is only 50% of the subbasin area.
</span><span class="noop">
</span><span class="noop">        Setting also the land use class of the second HRU to water would
</span><span class="noop">        result in overtrying.  To avoid this, both water evaporation
</span><span class="noop">        values are reduced by the same factor:
</span><span class="noop">
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; control.lnk(WASSER, WASSER, NADELW)
</span><span class="noop">        &gt;&gt;&gt; model.calc_q_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.q
</span><span class="noop">        q(0.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.evi
</span><span class="noop">        evi(3.333333, 4.166667, 3.0)
</span><span class="noop">
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    aid = self.sequences.aides.fastaccess
</span><span class="hit">    flu.q = sta.qbga+sta.qiga1+sta.qiga2+sta.qdga1+sta.qdga2
</span><span class="hit">    aid.epw = 0.
</span><span class="hit">    for k in range(con.nhru):
</span><span class="hit">        if con.lnk[k] == WASSER:
</span><span class="hit">            aid.epw += con.fhru[k]*flu.evi[k]
</span><span class="hit">    if flu.q &gt; aid.epw:
</span><span class="hit">        flu.q -= aid.epw
</span><span class="noop">    else:
</span><span class="hit">        for k in range(con.nhru):
</span><span class="hit">            if con.lnk[k] == WASSER:
</span><span class="hit">                flu.evi[k] *= flu.q/aid.epw
</span><span class="hit">        flu.q = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def update_outlets_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Update the outlet link sequence.
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_derived.QFactor`
</span><span class="noop">
</span><span class="noop">    Required flux sequences:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_fluxes.Q`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.models.lland.lland_outlets.Q`
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    out = self.sequences.outlets.fastaccess
</span><span class="hit">    out.q[0] += der.qfactor*flu.q
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Model(modeltools.Model):
</span><span class="noop">    &#34;&#34;&#34;Base model for HydPy-L-Land.&#34;&#34;&#34;
</span><span class="noop">
</span><span class="hit">    _RUNMETHODS = (calc_nkor_v1,
</span><span class="noop">                   calc_tkor_v1,
</span><span class="noop">                   calc_et0_v1,
</span><span class="noop">                   calc_evpo_v1,
</span><span class="noop">                   calc_nbes_inzp_v1,
</span><span class="noop">                   calc_evi_inzp_v1,
</span><span class="noop">                   calc_sbes_v1,
</span><span class="noop">                   calc_wgtf_v1,
</span><span class="noop">                   calc_schm_wats_v1,
</span><span class="noop">                   calc_wada_waes_v1,
</span><span class="noop">                   calc_evb_v1,
</span><span class="noop">                   calc_qbb_v1,
</span><span class="noop">                   calc_qib1_v1,
</span><span class="noop">                   calc_qib2_v1,
</span><span class="noop">                   calc_qdb_v1,
</span><span class="noop">                   calc_bowa_v1,
</span><span class="noop">                   calc_qbgz_v1,
</span><span class="noop">                   calc_qigz1_v1,
</span><span class="noop">                   calc_qigz2_v1,
</span><span class="noop">                   calc_qdgz_v1,
</span><span class="noop">                   calc_qdgz1_qdgz2_v1,
</span><span class="noop">                   calc_qbga_v1,
</span><span class="noop">                   calc_qiga1_v1,
</span><span class="noop">                   calc_qiga2_v1,
</span><span class="noop">                   calc_qdga1_v1,
</span><span class="noop">                   calc_qdga2_v1,
</span><span class="noop">                   calc_q_v1,
</span><span class="noop">                   update_outlets_v1)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_outlets.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_outlets.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Q(sequencetools.LinkSequence):
</span><span class="noop">    &#34;&#34;&#34;Runoff [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class OutletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Downstream link sequences of the HydPy-L-Land model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Q,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_parameters.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_parameters.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import parametertools
</span><span class="noop"># ...model specific
</span><span class="hit">from hydpy.models.lland import lland_constants
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MultiParameter(parametertools.ZipParameter):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling parameters of the HydPy-L-Land model
</span><span class="noop">    (potentially) handling multiple values.
</span><span class="noop">
</span><span class="noop">    Class :class:`MultiParameter` of HydPy-L-Land basically works like
</span><span class="noop">    Class :class:`~hydpy.models.lland.lland_parameters.MultiParameter` of
</span><span class="noop">    HydPy-H-Land, except that keyword arguments specific to HydPy-L-Land
</span><span class="noop">    are applied (acker, nadelw, wasser..., see module
</span><span class="noop">    :mod:`~hydpy.models.lland.lland_constants`) and except that parameter
</span><span class="noop">    :class:`~hydpy.models.lland.lland_control.NHRU` determines the number of
</span><span class="noop">    entries:
</span><span class="noop">
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.lland.lland_parameters import MultiParameter
</span><span class="noop">    &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">    &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">    &gt;&gt;&gt; mp = MultiParameter()
</span><span class="noop">    &gt;&gt;&gt; mp.subpars = control
</span><span class="noop">    &gt;&gt;&gt; mp.shape
</span><span class="noop">    Traceback (most recent call last):
</span><span class="noop">    ...
</span><span class="noop">    RuntimeError: Shape information for parameter `multiparameter` can only be retrieved after it has been defined.  You can do this manually, but usually it is done automatically by defining the value of parameter `nhru` first in each parameter control file.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    REQUIRED_VALUES = tuple(lland_constants.CONSTANTS.values())
</span><span class="hit">    MODEL_CONSTANTS = lland_constants.CONSTANTS
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def refparameter(self):
</span><span class="noop">        &#34;&#34;&#34;Alias for the associated instance of
</span><span class="noop">        :class:`~hydpy.models.lland.lland_control.LNK`.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return self.subpars.pars.control.lnk
</span><span class="noop">
</span><span class="hit">    @property
</span><span class="noop">    def shapeparameter(self):
</span><span class="noop">        &#34;&#34;&#34;Alias for the associated instance of
</span><span class="noop">        :class:`~hydpy.models.lland.lland_control.NHRU`.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        return self.subpars.pars.control.nhru
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MultiParameterLand(MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling parameters of HydPy-L-Land (potentially)
</span><span class="noop">    handling multiple values relevant for non water HRUs.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    REQUIRED_VALUES = tuple(value for (key, value)
</span><span class="noop">                            in lland_constants.CONSTANTS.items()
</span><span class="noop">                            if value != &#39;WASSER&#39;)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class MultiParameterSoil(MultiParameter):
</span><span class="noop">    &#34;&#34;&#34;Base class for handling parameters of HydPy-L-Land (potentially)
</span><span class="noop">    handling multiple values relevant for non water HRUs without sealed
</span><span class="noop">    surfaces.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    REQUIRED_VALUES = tuple(value for (key, value)
</span><span class="noop">                            in lland_constants.CONSTANTS.items()
</span><span class="noop">                            if value not in (&#39;WASSER&#39;, &#39;VERS&#39;))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class LanduseMonthParameter(parametertools.KeywordParameter2D):
</span><span class="noop">    &#34;&#34;&#34;Base class for parameters which values depend both an the actual
</span><span class="noop">    land use class and the actual month.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    COLNAMES = (&#39;jan&#39;, &#39;feb&#39;, &#39;mar&#39;, &#39;apr&#39;, &#39;mai&#39;, &#39;jun&#39;,
</span><span class="noop">                &#39;jul&#39;, &#39;aug&#39;, &#39;sep&#39;, &#39;oct&#39;, &#39;nov&#39;, &#39;dec&#39;)
</span><span class="hit">    ROWNAMES = tuple(key.lower() for (idx, key)
</span><span class="noop">                     in (sorted((idx, key) for (key, idx) in
</span><span class="noop">                         lland_constants.CONSTANTS.items())))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Parameters(parametertools.Parameters):
</span><span class="noop">    &#34;&#34;&#34;All parameters of the HydPy-L-Land model.&#34;&#34;&#34;
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_sequences.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_sequences.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Sequences(sequencetools.Sequences):
</span><span class="noop">    &#34;&#34;&#34;All sequences of the HydPy-L-Land model.&#34;&#34;&#34;
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_states.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lland/lland_states.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from site-packages
</span><span class="hit">import numpy
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Inzp(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Interzeptionsspeicherung (interception storage) [mm].
</span><span class="noop">
</span><span class="noop">    Note that :class:`Inzp` of HydPy-L implements no specialized trim method
</span><span class="noop">    (as opposed to :class:`~hydpy.models.hland.hland_states.Ic` of HydPy-H).
</span><span class="noop">    This is due the discontinuous evolution of
</span><span class="noop">    :class:`~hydpy.models.lland.lland_control.IcC` in time.  In accordance
</span><span class="noop">    with the orginal LARSIM implementation, :class:`Inzp` can be temporarily
</span><span class="noop">    overfilled during rain periods whenever
</span><span class="noop">    :class:`~hydpy.models.lland.lland_control.IcC` drops rapidly between two
</span><span class="noop">    months.  A specialized trim method would just make the excess water
</span><span class="noop">    vanish.  But in HydPy-L, the excess water becomes
</span><span class="noop">    :class:`~hydpy.models.lland.lland_fluxes.ThruFall` in the first simulation
</span><span class="noop">    step of the new month.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class WATS(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Wasseräquivalent Trockenschnee (frozen water equivalent of the snow
</span><span class="noop">    cover) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (0., None)
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="noop">        &#34;&#34;&#34;Trim values in accordance with :math:`WAeS \\leq PWMax \\cdot WATS`.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(7)
</span><span class="noop">        &gt;&gt;&gt; pwmax(2.)
</span><span class="noop">        &gt;&gt;&gt; states.waes = -1., 0., 1., -1., 5., 10., 20.
</span><span class="noop">        &gt;&gt;&gt; states.wats(-1., 0., 0., 5., 5., 5., 5.)
</span><span class="noop">        &gt;&gt;&gt; states.wats
</span><span class="noop">        wats(0.0, 0.0, 0.5, 5.0, 5.0, 5.0, 10.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        pwmax = self.subseqs.seqs.model.parameters.control.pwmax
</span><span class="hit">        waes = self.subseqs.waes
</span><span class="hit">        if lower is None:
</span><span class="hit">            if waes.values is not None:
</span><span class="hit">                lower = numpy.clip(waes/pwmax, 0., numpy.inf)
</span><span class="noop">            else:
</span><span class="miss">                lower = 0.
</span><span class="hit">        sequencetools.StateSequence.trim(self, lower, upper)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class WAeS(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Wasseräquivalent Gesamtschnee (total water equivalent of the snow
</span><span class="noop">    cover) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (0., None)
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="noop">        &#34;&#34;&#34;Trim values in accordance with :math:`WAeS \\leq PWMax \\cdot WATS`.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(7)
</span><span class="noop">        &gt;&gt;&gt; pwmax(2.)
</span><span class="noop">        &gt;&gt;&gt; states.wats = 0., 0., 0., 5., 5., 5., 5.
</span><span class="noop">        &gt;&gt;&gt; states.waes(-1., 0., 1., -1., 5., 10., 20.)
</span><span class="noop">        &gt;&gt;&gt; states.waes
</span><span class="noop">        waes(0.0, 0.0, 0.0, 0.0, 5.0, 10.0, 10.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        pwmax = self.subseqs.seqs.model.parameters.control.pwmax
</span><span class="hit">        wats = self.subseqs.wats
</span><span class="hit">        if (upper is None) and (wats.values is not None):
</span><span class="hit">            upper = pwmax*wats
</span><span class="hit">        sequencetools.StateSequence.trim(self, lower, upper)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class BoWa(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Bodenwasserspeicherung (soil water storage) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (0., None)
</span><span class="noop">
</span><span class="hit">    def trim(self, lower=None, upper=None):
</span><span class="noop">        &#34;&#34;&#34;Trim values in accordance with :math:`BoWa \\leq NFk`.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lland import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">        &gt;&gt;&gt; nhru(5)
</span><span class="noop">        &gt;&gt;&gt; nfk(200.)
</span><span class="noop">        &gt;&gt;&gt; states.bowa(-100.,0., 100., 200., 300.)
</span><span class="noop">        &gt;&gt;&gt; states.bowa
</span><span class="noop">        bowa(0.0, 0.0, 100.0, 200.0, 200.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        if upper is None:
</span><span class="hit">            upper = self.subseqs.seqs.model.parameters.control.nfk
</span><span class="hit">        sequencetools.StateSequence.trim(self, lower, upper)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QDGZ1(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Zufluss in den trägeren Direktabfluss-Gebietsspeicher (inflow into
</span><span class="noop">    the less responsive storage compartment for direct runoff) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QDGZ2(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Zufluss in den dynamischeren Direktabfluss-Gebietsspeicher (inflow into
</span><span class="noop">    the more responsive storage compartment for direct runoff) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QIGZ1(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;&#34;Zufluss in den ersten Zwischenabfluss-Gebietsspeicher (inflow into the
</span><span class="noop">    first storage compartment for interflow) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QIGZ2(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Zufluss in den zweiten Zwischenabfluss-Gebietsspeicher (inflow into the
</span><span class="noop">    second storage compartment for interflow) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QBGZ(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Zufluss in den Basisabfluss-Gebietsspeicher (inflow into the
</span><span class="noop">    storage compartment for base flow) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QDGA1(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Abfluss aus dem trägeren Direktabfluss-Gebietsspeicher (outflow from
</span><span class="noop">    the less responsive storage compartment for direct runoff) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QDGA2(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Abfluss aus dem dynamischeren Direktabfluss-Gebietsspeicher (outflow
</span><span class="noop">    from the more responsive storage compartment for direct runoff) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QIGA1(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Abfluss aus dem &#34;unteren&#34; Zwischenabfluss-Gebietsspeicher (outflow from
</span><span class="noop">    the storage compartment for the first interflow component) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QIGA2(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Abfluss aus dem &#34;oberen&#34; Zwischenabfluss-Gebietsspeicher (outflow from
</span><span class="noop">    the storage compartment for the second interflow component) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QBGA(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Abfluss aus dem Basisabfluss-Gebietsspeicher (outflow from the
</span><span class="noop">    storage compartment for base flow) [mm].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class StateSequences(sequencetools.StateSequences):
</span><span class="noop">    &#34;&#34;&#34;State sequences of the HydPy-L-Land model.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Inzp, WATS, WAeS, BoWa, QDGZ1, QDGZ2, QIGZ1, QIGZ2,
</span><span class="noop">                   QBGZ, QDGA1, QDGA2, QIGA1, QIGA2, QBGA)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream/__init__.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream/__init__.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="hit">&#34;&#34;&#34;
</span><span class="noop">The L-Stream model defines the methods and classes required for
</span><span class="noop">performing  flood routing calculations after the Williams method
</span><span class="noop">as implemented in LARSIM.
</span><span class="noop">&#34;&#34;&#34;
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...from HydPy
</span><span class="hit">from hydpy.core.modelimports import *
</span><span class="noop"># ...from lstream
</span><span class="hit">from hydpy.models.lstream.lstream_control import ControlParameters
</span><span class="hit">from hydpy.models.lstream.lstream_derived import DerivedParameters
</span><span class="hit">from hydpy.models.lstream.lstream_fluxes import FluxSequences
</span><span class="hit">from hydpy.models.lstream.lstream_states import StateSequences
</span><span class="hit">from hydpy.models.lstream.lstream_aides import AideSequences
</span><span class="hit">from hydpy.models.lstream.lstream_inlets import InletSequences
</span><span class="hit">from hydpy.models.lstream.lstream_outlets import OutletSequences
</span><span class="hit">from hydpy.models.lstream.lstream_model import Model
</span><span class="noop">
</span><span class="hit">autodoc_basemodel()
</span><span class="hit">tester = Tester()
</span><span class="hit">cythonizer = Cythonizer()
</span><span class="hit">cythonizer.complete()
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream/lstream_aides.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream/lstream_aides.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Temp(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Temporäre Variable (temporary variable) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class HMin(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Untere Wasserstandsgrenze (lower water stage boundary) [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class HMax(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Obere Wasserstandsgrenze (upper water stage boundary) [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QMin(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Untere Abflussgrenze (lower discharge boundary) [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QMax(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Obere Abflussgrenze (upper discharge boundary) [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QTest(sequencetools.AideSequence):
</span><span class="noop">    &#34;&#34;&#34;Vergleichsabfluss (discharge to be compared) [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class AideSequences(sequencetools.AideSequences):
</span><span class="noop">    &#34;&#34;&#34;Aide sequences of HydPy-L-Stream.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Temp, HMin, HMax, QMin, QMax, QTest)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream/lstream_control.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream/lstream_control.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import parametertools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Laen(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Flusslänge (channel length) [km].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Gef(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Sohlgefälle (channel slope) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class HM(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Höhe Hauptgerinne (height of the main channel) [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class BM(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Sohlbreite Hauptgerinne (bed width of the main channel) [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class BNM(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Böschungsneigung Hauptgerinne (slope of both main channel embankments)
</span><span class="noop">    [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class BV(parametertools.LeftRightParameter):
</span><span class="noop">    &#34;&#34;&#34;Sohlbreite Vorländer (bed widths of both forelands) [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class BBV(parametertools.LeftRightParameter):
</span><span class="noop">    &#34;&#34;&#34;Breite Vorlandböschungen (width of both foreland embankments) [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class BNV(parametertools.LeftRightParameter):
</span><span class="noop">    &#34;&#34;&#34;Böschungsneigung Vorländer (slope of both foreland embankments) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class BNVR(parametertools.LeftRightParameter):
</span><span class="noop">    &#34;&#34;&#34;Böschungsneigung Vorlandränder (slope of both outer embankments) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class SKM(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Rauigkeitsbeiwert Hauptgerinne (roughness coefficient of the main
</span><span class="noop">    channel) [m^(1/3)/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class SKV(parametertools.LeftRightParameter):
</span><span class="noop">    &#34;&#34;&#34;Rauigkeitsbeiwert Vorländer (roughness coefficient of the both
</span><span class="noop">    forelands) [m^(1/3)/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class EKM(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Kalibrierfaktor Hauptgerinne (calibration factor for the main
</span><span class="noop">    channel) [-].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class EKV(parametertools.LeftRightParameter):
</span><span class="noop">    &#34;&#34;&#34;Kalibrierfaktor Vorländer (calibration factor for both forelands) [m].
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QTol(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Approximationstoleranz Abfluss (discharge related stopping criterion
</span><span class="noop">    for root-finding algorithms) [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="hit">    INIT = 1e-6
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class HTol(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Approximationstoleranz Wasserstand (water stage related stopping
</span><span class="noop">    criterion for root-finding algorithms) [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="hit">    INIT = 1e-6
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class ControlParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Control parameters HydPy-L-Stream, directly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (Laen, Gef, HM, BM, BV, BBV, BNM, BNV, BNVR,
</span><span class="noop">                   SKM, SKV, EKM, EKV, QTol, HTol)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream/lstream_derived.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream/lstream_derived.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import parametertools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class HV(parametertools.LeftRightParameter):
</span><span class="noop">    &#34;&#34;&#34;Höhe Vorländer (height of both forelands) [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="noop">        &#34;&#34;&#34;Update value based on :math:`HV=BBV/BNV`.
</span><span class="noop">
</span><span class="noop">        Required Parameters:
</span><span class="noop">            :class:`BBV`
</span><span class="noop">            :class:`BNV`
</span><span class="noop">
</span><span class="noop">        Examples:
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.lstream import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; bbv(left=10., right=40.)
</span><span class="noop">            &gt;&gt;&gt; bnv(left=10., right=20.)
</span><span class="noop">            &gt;&gt;&gt; derived.hv.update()
</span><span class="noop">            &gt;&gt;&gt; derived.hv
</span><span class="noop">            hv(1.0, 2.0)
</span><span class="noop">            &gt;&gt;&gt; bbv(left=10., right=0.)
</span><span class="noop">            &gt;&gt;&gt; bnv(left=0., right=20.)
</span><span class="noop">            &gt;&gt;&gt; derived.hv.update()
</span><span class="noop">            &gt;&gt;&gt; derived.hv
</span><span class="noop">            hv(0.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        con = self.subpars.pars.control
</span><span class="hit">        for idx in range(2):
</span><span class="hit">            if (con.bbv[idx] &gt; 0.) and (con.bnv[idx] &gt; 0.):
</span><span class="hit">                self[idx] = con.bbv[idx]/con.bnv[idx]
</span><span class="noop">            else:
</span><span class="hit">                self[idx] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QM(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34;Bordvoller Abfluss Hauptgerinne (maximum discharge of the main channel)
</span><span class="noop">    [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="noop">        &#34;&#34;&#34;Update value based on the actual
</span><span class="noop">        :func:`~hydpy.models.lstream.lstream_model.calc_qg` method.
</span><span class="noop">
</span><span class="noop">        Required derived parameter:
</span><span class="noop">            :class:`~hydpy.models.lstream.lstream_control.H`
</span><span class="noop">
</span><span class="noop">        Note that the value of parameter :class:`QM` is directly related to
</span><span class="noop">        the value of parameter :class:`HM` and indirectly related to all
</span><span class="noop">        parameters values relevant for method
</span><span class="noop">        :func:`~hydpy.models.lstream.lstream_model.calc_qg`. Hence the
</span><span class="noop">        complete paramter (and sequence) requirements might differ for
</span><span class="noop">        various application models.
</span><span class="noop">
</span><span class="noop">        For examples, see the documentation on method ToDo.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        mod = self.subpars.pars.model
</span><span class="hit">        con = mod.parameters.control
</span><span class="hit">        flu = mod.sequences.fluxes
</span><span class="hit">        flu.h = con.hm
</span><span class="hit">        mod.calc_qg()
</span><span class="hit">        self.value = flu.qg
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QV(parametertools.LeftRightParameter):
</span><span class="noop">    &#34;&#34;&#34;Bordvoller Abfluss Vorländer (maximum discharge of both forelands)
</span><span class="noop">    [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 1, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="noop">        &#34;&#34;&#34;Update value based on the actual
</span><span class="noop">        :func:`~hydpy.models.lstream.lstream_model.calc_qg` method.
</span><span class="noop">
</span><span class="noop">        Required derived parameter:
</span><span class="noop">            :class:`HV`
</span><span class="noop">
</span><span class="noop">        Note that the values of parameter :class:`QV` are directly related to
</span><span class="noop">        the values of parameter :class:`HV` and indirectly related to all
</span><span class="noop">        parameters values relevant for method
</span><span class="noop">        :func:`~hydpy.models.lstream.lstream_model.calc_qg`. Hence the
</span><span class="noop">        complete paramter (and sequence) requirements might differ for
</span><span class="noop">        various application models.
</span><span class="noop">
</span><span class="noop">        For examples, see the documentation on method ToDo.
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        mod = self.subpars.pars.model
</span><span class="hit">        con = mod.parameters.control
</span><span class="hit">        der = self.subpars
</span><span class="hit">        flu = mod.sequences.fluxes
</span><span class="hit">        for idx in range(2):
</span><span class="hit">            flu.h = con.hm+der.hv[idx]
</span><span class="hit">            mod.calc_qg()
</span><span class="hit">            self[idx] = flu.qg
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Sek(parametertools.SingleParameter):
</span><span class="noop">    &#34;&#34;&#34; Sekunden im Simulationszeitschritt (Number of seconds of the selected
</span><span class="noop">    simulation time step) [T].&#34;&#34;&#34;
</span><span class="hit">    NDIM, TYPE, TIME, SPAN = 0, float, None, (0., None)
</span><span class="noop">
</span><span class="hit">    def update(self):
</span><span class="noop">        &#34;&#34;&#34;Update value based on :math:`HL=BBR/BNR`.
</span><span class="noop">
</span><span class="noop">        Required Parameters:
</span><span class="noop">            :class:`BBR`
</span><span class="noop">            :class:`BNR`
</span><span class="noop">
</span><span class="noop">        Example:
</span><span class="noop">            &gt;&gt;&gt; from hydpy.models.lstream import *
</span><span class="noop">            &gt;&gt;&gt; parameterstep()
</span><span class="noop">            &gt;&gt;&gt; simulationstep(&#39;1d&#39;)
</span><span class="noop">            &gt;&gt;&gt; derived.sek.update()
</span><span class="noop">            &gt;&gt;&gt; derived.sek
</span><span class="noop">            sek(86400.0)
</span><span class="noop">        &#34;&#34;&#34;
</span><span class="hit">        self(self.simulationstep.seconds)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class DerivedParameters(parametertools.SubParameters):
</span><span class="noop">    &#34;&#34;&#34;Derived parameters of HydPy-L-Stream, indirectly defined by the user.&#34;&#34;&#34;
</span><span class="hit">    _PARCLASSES = (HV, QM, QV, Sek)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream/lstream_fluxes.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream/lstream_fluxes.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QRef(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Referenzabfluss (reference flow) [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class H(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Wasserstand (water stage) [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class AM(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Durchflossene Fläche Hauptgerinne (flown through area of the
</span><span class="noop">    main channel) [m²].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class AV(sequencetools.LeftRightSequence):
</span><span class="noop">    &#34;&#34;&#34;Durchflossene Fläche Vorländer (flown through area of both forelands)
</span><span class="noop">    [m²].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class AVR(sequencetools.LeftRightSequence):
</span><span class="noop">    &#34;&#34;&#34;Durchflossene Fläche Vorlandränder (flown through area of both outer
</span><span class="noop">    embankments) [m²].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class AG(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Durchflossene Fläche gesamt  (total flown through area) [m²].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class UM(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Benetzter Umfang Hauptgerinne (wetted perimeter of the
</span><span class="noop">    main channel) [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class UV(sequencetools.LeftRightSequence):
</span><span class="noop">    &#34;&#34;&#34;Benetzter Umfang Vorländer (wetted perimeter of both forelands) [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class UVR(sequencetools.LeftRightSequence):
</span><span class="noop">    &#34;&#34;&#34;Benetzter Umfang Vorlandränder (wetted perimeter of both outer
</span><span class="noop">    embankments) [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class UG(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Durchflossene Fläche gesamt  (total wetted perimeter) [m].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QM(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Durchfluss Hauptgerinne (discharge of the main channel) [m³].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QV(sequencetools.LeftRightSequence):
</span><span class="noop">    &#34;&#34;&#34;Durchfluss Voränder (discharge of both forelands) [m³].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QVR(sequencetools.LeftRightSequence):
</span><span class="noop">    &#34;&#34;&#34;Durchfluss Vorlandränder (discharge of both outer embankment) [m³].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 1, False, (1., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QG(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Durchfluss gesamt (total discharge) [m³].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class RK(sequencetools.FluxSequence):
</span><span class="noop">    &#34;&#34;&#34;Schwerpunktlaufzeit (traveling time) [s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class FluxSequences(sequencetools.FluxSequences):
</span><span class="noop">    &#34;&#34;&#34;Flux sequences of HydPy-L-Stream.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (QRef, H, AM, AV, AVR, AG, UM, UV, UVR, UG,
</span><span class="noop">                   QM, QV, QVR, QG, RK)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream/lstream_inlets.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream/lstream_inlets.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Q(sequencetools.LinkSequence):
</span><span class="noop">    &#34;&#34;&#34;Abfluss (runoff) [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 1, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class InletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Upstream link sequences of HydPy-L-Stream.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Q,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream/lstream_model.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream/lstream_model.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
23 &nbsp;
24 &nbsp;
25 &nbsp;
26 &nbsp;
27 &nbsp;
28 &nbsp;
29 &nbsp;
30 &nbsp;
31 &nbsp;
32 &nbsp;
33 &nbsp;
34 &nbsp;
35 &nbsp;
36 &nbsp;
37 &nbsp;
38 &nbsp;
39 &nbsp;
40 &nbsp;
41 &nbsp;
42 &nbsp;
43 &nbsp;
44 &nbsp;
45 &nbsp;
46 &nbsp;
47 &nbsp;
48 &nbsp;
49 &nbsp;
50 &nbsp;
51 &nbsp;
52 &nbsp;
53 &nbsp;
54 &nbsp;
55 &nbsp;
56 &nbsp;
57 &nbsp;
58 &nbsp;
59 &nbsp;
60 &nbsp;
61 &nbsp;
62 &nbsp;
63 &nbsp;
64 &nbsp;
65 &nbsp;
66 &nbsp;
67 &nbsp;
68 &nbsp;
69 &nbsp;
70 &nbsp;
71 &nbsp;
72 &nbsp;
73 &nbsp;
74 &nbsp;
75 &nbsp;
76 &nbsp;
77 &nbsp;
78 &nbsp;
79 &nbsp;
80 &nbsp;
81 &nbsp;
82 &nbsp;
83 &nbsp;
84 &nbsp;
85 &nbsp;
86 &nbsp;
87 &nbsp;
88 &nbsp;
89 &nbsp;
90 &nbsp;
91 &nbsp;
92 &nbsp;
93 &nbsp;
94 &nbsp;
95 &nbsp;
96 &nbsp;
97 &nbsp;
98 &nbsp;
99 &nbsp;
100 &nbsp;
101 &nbsp;
102 &nbsp;
103 &nbsp;
104 &nbsp;
105 &nbsp;
106 &nbsp;
107 &nbsp;
108 &nbsp;
109 &nbsp;
110 &nbsp;
111 &nbsp;
112 &nbsp;
113 &nbsp;
114 &nbsp;
115 &nbsp;
116 &nbsp;
117 &nbsp;
118 &nbsp;
119 &nbsp;
120 &nbsp;
121 &nbsp;
122 &nbsp;
123 &nbsp;
124 &nbsp;
125 &nbsp;
126 &nbsp;
127 &nbsp;
128 &nbsp;
129 &nbsp;
130 &nbsp;
131 &nbsp;
132 &nbsp;
133 &nbsp;
134 &nbsp;
135 &nbsp;
136 &nbsp;
137 &nbsp;
138 &nbsp;
139 &nbsp;
140 &nbsp;
141 &nbsp;
142 &nbsp;
143 &nbsp;
144 &nbsp;
145 &nbsp;
146 &nbsp;
147 &nbsp;
148 &nbsp;
149 &nbsp;
150 &nbsp;
151 &nbsp;
152 &nbsp;
153 &nbsp;
154 &nbsp;
155 &nbsp;
156 &nbsp;
157 &nbsp;
158 &nbsp;
159 &nbsp;
160 &nbsp;
161 &nbsp;
162 &nbsp;
163 &nbsp;
164 &nbsp;
165 &nbsp;
166 &nbsp;
167 &nbsp;
168 &nbsp;
169 &nbsp;
170 &nbsp;
171 &nbsp;
172 &nbsp;
173 &nbsp;
174 &nbsp;
175 &nbsp;
176 &nbsp;
177 &nbsp;
178 &nbsp;
179 &nbsp;
180 &nbsp;
181 &nbsp;
182 &nbsp;
183 &nbsp;
184 &nbsp;
185 &nbsp;
186 &nbsp;
187 &nbsp;
188 &nbsp;
189 &nbsp;
190 &nbsp;
191 &nbsp;
192 &nbsp;
193 &nbsp;
194 &nbsp;
195 &nbsp;
196 &nbsp;
197 &nbsp;
198 &nbsp;
199 &nbsp;
200 &nbsp;
201 &nbsp;
202 &nbsp;
203 &nbsp;
204 &nbsp;
205 &nbsp;
206 &nbsp;
207 &nbsp;
208 &nbsp;
209 &nbsp;
210 &nbsp;
211 &nbsp;
212 &nbsp;
213 &nbsp;
214 &nbsp;
215 &nbsp;
216 &nbsp;
217 &nbsp;
218 &nbsp;
219 &nbsp;
220 &nbsp;
221 &nbsp;
222 &nbsp;
223 &nbsp;
224 &nbsp;
225 &nbsp;
226 &nbsp;
227 &nbsp;
228 &nbsp;
229 &nbsp;
230 &nbsp;
231 &nbsp;
232 &nbsp;
233 &nbsp;
234 &nbsp;
235 &nbsp;
236 &nbsp;
237 &nbsp;
238 &nbsp;
239 &nbsp;
240 &nbsp;
241 &nbsp;
242 &nbsp;
243 &nbsp;
244 &nbsp;
245 &nbsp;
246 &nbsp;
247 &nbsp;
248 &nbsp;
249 &nbsp;
250 &nbsp;
251 &nbsp;
252 &nbsp;
253 &nbsp;
254 &nbsp;
255 &nbsp;
256 &nbsp;
257 &nbsp;
258 &nbsp;
259 &nbsp;
260 &nbsp;
261 &nbsp;
262 &nbsp;
263 &nbsp;
264 &nbsp;
265 &nbsp;
266 &nbsp;
267 &nbsp;
268 &nbsp;
269 &nbsp;
270 &nbsp;
271 &nbsp;
272 &nbsp;
273 &nbsp;
274 &nbsp;
275 &nbsp;
276 &nbsp;
277 &nbsp;
278 &nbsp;
279 &nbsp;
280 &nbsp;
281 &nbsp;
282 &nbsp;
283 &nbsp;
284 &nbsp;
285 &nbsp;
286 &nbsp;
287 &nbsp;
288 &nbsp;
289 &nbsp;
290 &nbsp;
291 &nbsp;
292 &nbsp;
293 &nbsp;
294 &nbsp;
295 &nbsp;
296 &nbsp;
297 &nbsp;
298 &nbsp;
299 &nbsp;
300 &nbsp;
301 &nbsp;
302 &nbsp;
303 &nbsp;
304 &nbsp;
305 &nbsp;
306 &nbsp;
307 &nbsp;
308 &nbsp;
309 &nbsp;
310 &nbsp;
311 &nbsp;
312 &nbsp;
313 &nbsp;
314 &nbsp;
315 &nbsp;
316 &nbsp;
317 &nbsp;
318 &nbsp;
319 &nbsp;
320 &nbsp;
321 &nbsp;
322 &nbsp;
323 &nbsp;
324 &nbsp;
325 &nbsp;
326 &nbsp;
327 &nbsp;
328 &nbsp;
329 &nbsp;
330 &nbsp;
331 &nbsp;
332 &nbsp;
333 &nbsp;
334 &nbsp;
335 &nbsp;
336 &nbsp;
337 &nbsp;
338 &nbsp;
339 &nbsp;
340 &nbsp;
341 &nbsp;
342 &nbsp;
343 &nbsp;
344 &nbsp;
345 &nbsp;
346 &nbsp;
347 &nbsp;
348 &nbsp;
349 &nbsp;
350 &nbsp;
351 &nbsp;
352 &nbsp;
353 &nbsp;
354 &nbsp;
355 &nbsp;
356 &nbsp;
357 &nbsp;
358 &nbsp;
359 &nbsp;
360 &nbsp;
361 &nbsp;
362 &nbsp;
363 &nbsp;
364 &nbsp;
365 &nbsp;
366 &nbsp;
367 &nbsp;
368 &nbsp;
369 &nbsp;
370 &nbsp;
371 &nbsp;
372 &nbsp;
373 &nbsp;
374 &nbsp;
375 &nbsp;
376 &nbsp;
377 &nbsp;
378 &nbsp;
379 &nbsp;
380 &nbsp;
381 &nbsp;
382 &nbsp;
383 &nbsp;
384 &nbsp;
385 &nbsp;
386 &nbsp;
387 &nbsp;
388 &nbsp;
389 &nbsp;
390 &nbsp;
391 &nbsp;
392 &nbsp;
393 &nbsp;
394 &nbsp;
395 &nbsp;
396 &nbsp;
397 &nbsp;
398 &nbsp;
399 &nbsp;
400 &nbsp;
401 &nbsp;
402 &nbsp;
403 &nbsp;
404 &nbsp;
405 &nbsp;
406 &nbsp;
407 &nbsp;
408 &nbsp;
409 &nbsp;
410 &nbsp;
411 &nbsp;
412 &nbsp;
413 &nbsp;
414 &nbsp;
415 &nbsp;
416 &nbsp;
417 &nbsp;
418 &nbsp;
419 &nbsp;
420 &nbsp;
421 &nbsp;
422 &nbsp;
423 &nbsp;
424 &nbsp;
425 &nbsp;
426 &nbsp;
427 &nbsp;
428 &nbsp;
429 &nbsp;
430 &nbsp;
431 &nbsp;
432 &nbsp;
433 &nbsp;
434 &nbsp;
435 &nbsp;
436 &nbsp;
437 &nbsp;
438 &nbsp;
439 &nbsp;
440 &nbsp;
441 &nbsp;
442 &nbsp;
443 &nbsp;
444 &nbsp;
445 &nbsp;
446 &nbsp;
447 &nbsp;
448 &nbsp;
449 &nbsp;
450 &nbsp;
451 &nbsp;
452 &nbsp;
453 &nbsp;
454 &nbsp;
455 &nbsp;
456 &nbsp;
457 &nbsp;
458 &nbsp;
459 &nbsp;
460 &nbsp;
461 &nbsp;
462 &nbsp;
463 &nbsp;
464 &nbsp;
465 &nbsp;
466 &nbsp;
467 &nbsp;
468 &nbsp;
469 &nbsp;
470 &nbsp;
471 &nbsp;
472 &nbsp;
473 &nbsp;
474 &nbsp;
475 &nbsp;
476 &nbsp;
477 &nbsp;
478 &nbsp;
479 &nbsp;
480 &nbsp;
481 &nbsp;
482 &nbsp;
483 &nbsp;
484 &nbsp;
485 &nbsp;
486 &nbsp;
487 &nbsp;
488 &nbsp;
489 &nbsp;
490 &nbsp;
491 &nbsp;
492 &nbsp;
493 &nbsp;
494 &nbsp;
495 &nbsp;
496 &nbsp;
497 &nbsp;
498 &nbsp;
499 &nbsp;
500 &nbsp;
501 &nbsp;
502 &nbsp;
503 &nbsp;
504 &nbsp;
505 &nbsp;
506 &nbsp;
507 &nbsp;
508 &nbsp;
509 &nbsp;
510 &nbsp;
511 &nbsp;
512 &nbsp;
513 &nbsp;
514 &nbsp;
515 &nbsp;
516 &nbsp;
517 &nbsp;
518 &nbsp;
519 &nbsp;
520 &nbsp;
521 &nbsp;
522 &nbsp;
523 &nbsp;
524 &nbsp;
525 &nbsp;
526 &nbsp;
527 &nbsp;
528 &nbsp;
529 &nbsp;
530 &nbsp;
531 &nbsp;
532 &nbsp;
533 &nbsp;
534 &nbsp;
535 &nbsp;
536 &nbsp;
537 &nbsp;
538 &nbsp;
539 &nbsp;
540 &nbsp;
541 &nbsp;
542 &nbsp;
543 &nbsp;
544 &nbsp;
545 &nbsp;
546 &nbsp;
547 &nbsp;
548 &nbsp;
549 &nbsp;
550 &nbsp;
551 &nbsp;
552 &nbsp;
553 &nbsp;
554 &nbsp;
555 &nbsp;
556 &nbsp;
557 &nbsp;
558 &nbsp;
559 &nbsp;
560 &nbsp;
561 &nbsp;
562 &nbsp;
563 &nbsp;
564 &nbsp;
565 &nbsp;
566 &nbsp;
567 &nbsp;
568 &nbsp;
569 &nbsp;
570 &nbsp;
571 &nbsp;
572 &nbsp;
573 &nbsp;
574 &nbsp;
575 &nbsp;
576 &nbsp;
577 &nbsp;
578 &nbsp;
579 &nbsp;
580 &nbsp;
581 &nbsp;
582 &nbsp;
583 &nbsp;
584 &nbsp;
585 &nbsp;
586 &nbsp;
587 &nbsp;
588 &nbsp;
589 &nbsp;
590 &nbsp;
591 &nbsp;
592 &nbsp;
593 &nbsp;
594 &nbsp;
595 &nbsp;
596 &nbsp;
597 &nbsp;
598 &nbsp;
599 &nbsp;
600 &nbsp;
601 &nbsp;
602 &nbsp;
603 &nbsp;
604 &nbsp;
605 &nbsp;
606 &nbsp;
607 &nbsp;
608 &nbsp;
609 &nbsp;
610 &nbsp;
611 &nbsp;
612 &nbsp;
613 &nbsp;
614 &nbsp;
615 &nbsp;
616 &nbsp;
617 &nbsp;
618 &nbsp;
619 &nbsp;
620 &nbsp;
621 &nbsp;
622 &nbsp;
623 &nbsp;
624 &nbsp;
625 &nbsp;
626 &nbsp;
627 &nbsp;
628 &nbsp;
629 &nbsp;
630 &nbsp;
631 &nbsp;
632 &nbsp;
633 &nbsp;
634 &nbsp;
635 &nbsp;
636 &nbsp;
637 &nbsp;
638 &nbsp;
639 &nbsp;
640 &nbsp;
641 &nbsp;
642 &nbsp;
643 &nbsp;
644 &nbsp;
645 &nbsp;
646 &nbsp;
647 &nbsp;
648 &nbsp;
649 &nbsp;
650 &nbsp;
651 &nbsp;
652 &nbsp;
653 &nbsp;
654 &nbsp;
655 &nbsp;
656 &nbsp;
657 &nbsp;
658 &nbsp;
659 &nbsp;
660 &nbsp;
661 &nbsp;
662 &nbsp;
663 &nbsp;
664 &nbsp;
665 &nbsp;
666 &nbsp;
667 &nbsp;
668 &nbsp;
669 &nbsp;
670 &nbsp;
671 &nbsp;
672 &nbsp;
673 &nbsp;
674 &nbsp;
675 &nbsp;
676 &nbsp;
677 &nbsp;
678 &nbsp;
679 &nbsp;
680 &nbsp;
681 &nbsp;
682 &nbsp;
683 &nbsp;
684 &nbsp;
685 &nbsp;
686 &nbsp;
687 &nbsp;
688 &nbsp;
689 &nbsp;
690 &nbsp;
691 &nbsp;
692 &nbsp;
693 &nbsp;
694 &nbsp;
695 &nbsp;
696 &nbsp;
697 &nbsp;
698 &nbsp;
699 &nbsp;
700 &nbsp;
701 &nbsp;
702 &nbsp;
703 &nbsp;
704 &nbsp;
705 &nbsp;
706 &nbsp;
707 &nbsp;
708 &nbsp;
709 &nbsp;
710 &nbsp;
711 &nbsp;
712 &nbsp;
713 &nbsp;
714 &nbsp;
715 &nbsp;
716 &nbsp;
717 &nbsp;
718 &nbsp;
719 &nbsp;
720 &nbsp;
721 &nbsp;
722 &nbsp;
723 &nbsp;
724 &nbsp;
725 &nbsp;
726 &nbsp;
727 &nbsp;
728 &nbsp;
729 &nbsp;
730 &nbsp;
731 &nbsp;
732 &nbsp;
733 &nbsp;
734 &nbsp;
735 &nbsp;
736 &nbsp;
737 &nbsp;
738 &nbsp;
739 &nbsp;
740 &nbsp;
741 &nbsp;
742 &nbsp;
743 &nbsp;
744 &nbsp;
745 &nbsp;
746 &nbsp;
747 &nbsp;
748 &nbsp;
749 &nbsp;
750 &nbsp;
751 &nbsp;
752 &nbsp;
753 &nbsp;
754 &nbsp;
755 &nbsp;
756 &nbsp;
757 &nbsp;
758 &nbsp;
759 &nbsp;
760 &nbsp;
761 &nbsp;
762 &nbsp;
763 &nbsp;
764 &nbsp;
765 &nbsp;
766 &nbsp;
767 &nbsp;
768 &nbsp;
769 &nbsp;
770 &nbsp;
771 &nbsp;
772 &nbsp;
773 &nbsp;
774 &nbsp;
775 &nbsp;
776 &nbsp;
777 &nbsp;
778 &nbsp;
779 &nbsp;
780 &nbsp;
781 &nbsp;
782 &nbsp;
783 &nbsp;
784 &nbsp;
785 &nbsp;
786 &nbsp;
787 &nbsp;
788 &nbsp;
789 &nbsp;
790 &nbsp;
791 &nbsp;
792 &nbsp;
793 &nbsp;
794 &nbsp;
795 &nbsp;
796 &nbsp;
797 &nbsp;
798 &nbsp;
799 &nbsp;
800 &nbsp;
801 &nbsp;
802 &nbsp;
803 &nbsp;
804 &nbsp;
805 &nbsp;
806 &nbsp;
807 &nbsp;
808 &nbsp;
809 &nbsp;
810 &nbsp;
811 &nbsp;
812 &nbsp;
813 &nbsp;
814 &nbsp;
815 &nbsp;
816 &nbsp;
817 &nbsp;
818 &nbsp;
819 &nbsp;
820 &nbsp;
821 &nbsp;
822 &nbsp;
823 &nbsp;
824 &nbsp;
825 &nbsp;
826 &nbsp;
827 &nbsp;
828 &nbsp;
829 &nbsp;
830 &nbsp;
831 &nbsp;
832 &nbsp;
833 &nbsp;
834 &nbsp;
835 &nbsp;
836 &nbsp;
837 &nbsp;
838 &nbsp;
839 &nbsp;
840 &nbsp;
841 &nbsp;
842 &nbsp;
843 &nbsp;
844 &nbsp;
845 &nbsp;
846 &nbsp;
847 &nbsp;
848 &nbsp;
849 &nbsp;
850 &nbsp;
851 &nbsp;
852 &nbsp;
853 &nbsp;
854 &nbsp;
855 &nbsp;
856 &nbsp;
857 &nbsp;
858 &nbsp;
859 &nbsp;
860 &nbsp;
861 &nbsp;
862 &nbsp;
863 &nbsp;
864 &nbsp;
865 &nbsp;
866 &nbsp;
867 &nbsp;
868 &nbsp;
869 &nbsp;
870 &nbsp;
871 &nbsp;
872 &nbsp;
873 &nbsp;
874 &nbsp;
875 &nbsp;
876 &nbsp;
877 &nbsp;
878 &nbsp;
879 &nbsp;
880 &nbsp;
881 &nbsp;
882 &nbsp;
883 &nbsp;
884 &nbsp;
885 &nbsp;
886 &nbsp;
887 &nbsp;
888 &nbsp;
889 &nbsp;
890 &nbsp;
891 &nbsp;
892 &nbsp;
893 &nbsp;
894 &nbsp;
895 &nbsp;
896 &nbsp;
897 &nbsp;
898 &nbsp;
899 &nbsp;
900 &nbsp;
901 &nbsp;
902 &nbsp;
903 &nbsp;
904 &nbsp;
905 &nbsp;
906 &nbsp;
907 &nbsp;
908 &nbsp;
909 &nbsp;
910 &nbsp;
911 &nbsp;
912 &nbsp;
913 &nbsp;
914 &nbsp;
915 &nbsp;
916 &nbsp;
917 &nbsp;
918 &nbsp;
919 &nbsp;
920 &nbsp;
921 &nbsp;
922 &nbsp;
923 &nbsp;
924 &nbsp;
925 &nbsp;
926 &nbsp;
927 &nbsp;
928 &nbsp;
929 &nbsp;
930 &nbsp;
931 &nbsp;
932 &nbsp;
933 &nbsp;
934 &nbsp;
935 &nbsp;
936 &nbsp;
937 &nbsp;
938 &nbsp;
939 &nbsp;
940 &nbsp;
941 &nbsp;
942 &nbsp;
943 &nbsp;
944 &nbsp;
945 &nbsp;
946 &nbsp;
947 &nbsp;
948 &nbsp;
949 &nbsp;
950 &nbsp;
951 &nbsp;
952 &nbsp;
953 &nbsp;
954 &nbsp;
955 &nbsp;
956 &nbsp;
957 &nbsp;
958 &nbsp;
959 &nbsp;
960 &nbsp;
961 &nbsp;
962 &nbsp;
963 &nbsp;
964 &nbsp;
965 &nbsp;
966 &nbsp;
967 &nbsp;
968 &nbsp;
969 &nbsp;
970 &nbsp;
971 &nbsp;
972 &nbsp;
973 &nbsp;
974 &nbsp;
975 &nbsp;
976 &nbsp;
977 &nbsp;
978 &nbsp;
979 &nbsp;
980 &nbsp;
981 &nbsp;
982 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import modeltools
</span><span class="hit">from hydpy.cythons import modelutils
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qref_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Determine the reference discharge within the given space-time intervall.
</span><span class="noop">
</span><span class="noop">    Required state sequences:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_states.QZ`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_states.QA`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.QRef`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`QRef = \\frac{QZ_{new}+QZ_{old}+QA_{old}}{3}`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lstream import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; states.qz.new = 3.
</span><span class="noop">        &gt;&gt;&gt; states.qz.old = 2.
</span><span class="noop">        &gt;&gt;&gt; states.qa.old = 1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qref_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qref
</span><span class="noop">        qref(2.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    new = self.sequences.states.fastaccess_new
</span><span class="hit">    old = self.sequences.states.fastaccess_old
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    flu.qref = (new.qz+old.qz+old.qa)/3.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_rk_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Determine the actual traveling time of the water (not of the wave!).
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_derived.Sek`
</span><span class="noop">
</span><span class="noop">    Required flux sequences:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.A`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.QRef`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.RK`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">      :math:`RK = \\frac{Laen \\cdot A}{QRef}`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        First, note that the traveling time is determined in the unit of the
</span><span class="noop">        actual simulation step size:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lstream import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; laen(25.)
</span><span class="noop">        &gt;&gt;&gt; derived.sek(24*60*60)
</span><span class="noop">        &gt;&gt;&gt; fluxes.ag = 10.
</span><span class="noop">        &gt;&gt;&gt; fluxes.qref = 1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_rk_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.rk
</span><span class="noop">        rk(2.893519)
</span><span class="noop">
</span><span class="noop">        Second, for negative values or zero values of
</span><span class="noop">        :class:`~hydpy.model.lstream.lstream_fluxes.A` or
</span><span class="noop">        :class:`~hydpy.model.lstream.lstream_fluxes.QRef`, the value of
</span><span class="noop">        :class:`~hydpy.model.lstream.lstream_fluxes.RK` is set to zero:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.ag = 0.
</span><span class="noop">        &gt;&gt;&gt; fluxes.qref = 1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_rk_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.rk
</span><span class="noop">        rk(0.0)
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.ag = 0.
</span><span class="noop">        &gt;&gt;&gt; fluxes.qref = 1.
</span><span class="noop">        &gt;&gt;&gt; model.calc_rk_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.rk
</span><span class="noop">        rk(0.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    if (flu.ag &gt; 0.) and (flu.qref &gt; 0.):
</span><span class="hit">        flu.rk = (1000.*con.laen*flu.ag)/(der.sek*flu.qref)
</span><span class="noop">    else:
</span><span class="hit">        flu.rk = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_am_um_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the flown through area and the wetted perimeter
</span><span class="noop">    of the main channel.
</span><span class="noop">
</span><span class="noop">    Note that the main channel is assumed to have identical slopes on
</span><span class="noop">    both sides and that water flowing exactly above the main channel is
</span><span class="noop">    contributing to :class:`~hydpy.model.lstream.lstream_fluxes.AM`.
</span><span class="noop">    Both theoretical surfaces seperating water above the main channel
</span><span class="noop">    from water above both forelands are contributing to
</span><span class="noop">    :class:`~hydpy.model.lstream.lstream_fluxes.UM`.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.HM`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.BM`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.BNM`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.H`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.AM`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.UM`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        Generally, a trapezoid with reflection symmetry is assumed.  Here its
</span><span class="noop">        smaller base (bottom) has a length of 2 meters, its legs show an
</span><span class="noop">        inclination of 1 meter per 4 meters, and its height (depths) is 1
</span><span class="noop">        meter:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lstream import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; bm(2.)
</span><span class="noop">        &gt;&gt;&gt; bnm(4.)
</span><span class="noop">        &gt;&gt;&gt; hm(1.)
</span><span class="noop">
</span><span class="noop">        The first example deals with normal flow conditions, where water flows
</span><span class="noop">        within the main channel completely:
</span><span class="noop">        (:class:`~hydpy.model.lstream.lstream_fluxes.H` &lt;
</span><span class="noop">        :class:`~hydpy.model.lstream.lstream_control.HM`):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.h = .5
</span><span class="noop">        &gt;&gt;&gt; model.calc_am_um_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.am
</span><span class="noop">        am(2.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.um
</span><span class="noop">        um(6.123106)
</span><span class="noop">
</span><span class="noop">        The second example deals with high flow conditions, where water flows
</span><span class="noop">        over the foreland also:
</span><span class="noop">        (:class:`~hydpy.model.lstream.lstream_fluxes.H` &gt;
</span><span class="noop">        :class:`~hydpy.model.lstream.lstream_control.HM`):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.h = 1.5
</span><span class="noop">        &gt;&gt;&gt; model.calc_am_um_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.am
</span><span class="noop">        am(11.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.um
</span><span class="noop">        um(11.246211)
</span><span class="noop">
</span><span class="noop">        The third example checks the special case of a main channel with zero
</span><span class="noop">        height:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; hm(0.)
</span><span class="noop">        &gt;&gt;&gt; model.calc_am_um_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.am
</span><span class="noop">        am(3.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.um
</span><span class="noop">        um(5.0)
</span><span class="noop">
</span><span class="noop">        The fourth example checks the special case of the actual water stage
</span><span class="noop">        not beeing larger than zero (empty channel):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.h = 0.
</span><span class="noop">        &gt;&gt;&gt; hm(1.)
</span><span class="noop">        &gt;&gt;&gt; model.calc_am_um_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.am
</span><span class="noop">        am(0.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.um
</span><span class="noop">        um(0.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    if flu.h &lt;= 0.:
</span><span class="hit">        flu.am = 0.
</span><span class="hit">        flu.um = 0.
</span><span class="hit">    elif flu.h &lt; con.hm:
</span><span class="hit">        flu.am = flu.h*(con.bm+flu.h*con.bnm)
</span><span class="hit">        flu.um = con.bm+2.*flu.h*(1.+con.bnm**2)**.5
</span><span class="noop">    else:
</span><span class="hit">        flu.am = (con.hm*(con.bm+con.hm*con.bnm) +
</span><span class="noop">                  ((flu.h-con.hm)*(con.bm+2.*con.hm*con.bnm)))
</span><span class="hit">        flu.um = (con.bm)+(2.*con.hm*(1.+con.bnm**2)**.5)+(2*(flu.h-con.hm))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qm_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the discharge of the main channel after Manning-Strickler.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.EKM`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.SKM`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.Gef`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.AM`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.UM`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.QM`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        For appropriate strictly positive values:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lstream import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; ekm(2.)
</span><span class="noop">        &gt;&gt;&gt; skm(50.)
</span><span class="noop">        &gt;&gt;&gt; gef(.01)
</span><span class="noop">        &gt;&gt;&gt; fluxes.am = 3.
</span><span class="noop">        &gt;&gt;&gt; fluxes.um = 7.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qm_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qm
</span><span class="noop">        qm(17.053102)
</span><span class="noop">
</span><span class="noop">        For zero or negative values of the flown through surface or
</span><span class="noop">        the wetted perimeter:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.am = -1.
</span><span class="noop">        &gt;&gt;&gt; fluxes.um = 7.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qm_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qm
</span><span class="noop">        qm(0.0)
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.am = 3.
</span><span class="noop">        &gt;&gt;&gt; fluxes.um = 0.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qm_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qm
</span><span class="noop">        qm(0.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    if (flu.am &gt; 0.) and (flu.um &gt; 0.):
</span><span class="hit">        flu.qm = con.ekm*con.skm*flu.am**(5./3.)/flu.um**(2./3.)*con.gef**.5
</span><span class="noop">    else:
</span><span class="hit">        flu.qm = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_av_uv_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the flown through area and the wetted perimeter of both
</span><span class="noop">    forelands.
</span><span class="noop">
</span><span class="noop">    Note that the each foreland lies between the main channel and one
</span><span class="noop">    outer embankment and that water flowing exactly above the a foreland
</span><span class="noop">    is contributing to :class:`~hydpy.model.lstream.lstream_fluxes.AV`.
</span><span class="noop">    The theoretical surface seperating water above the main channel from
</span><span class="noop">    water above the foreland is not contributing to
</span><span class="noop">    :class:`~hydpy.model.lstream.lstream_fluxes.UV`, but the surface
</span><span class="noop">    seperating water above the foreland from water above its outer embankment
</span><span class="noop">    is contributing to :class:`~hydpy.model.lstream.lstream_fluxes.UV`.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.HM`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.BV`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.BNV`
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_derived.HV`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.H`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.AV`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.UV`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        Generally, right trapezoids are assumed.  Here, for simplicity, both
</span><span class="noop">        forelands are assumed to be symmetrical.  Their smaller bases (bottoms)
</span><span class="noop">        hava a length of 2 meters, their non-vertical legs show an inclination
</span><span class="noop">        of 1 meter per 4 meters, and their height (depths) is 1 meter.  Both
</span><span class="noop">        forelands lie 1 meter above the main channels bottom.
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lstream import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; hm(1.)
</span><span class="noop">        &gt;&gt;&gt; bv(2.)
</span><span class="noop">        &gt;&gt;&gt; bnv(4.)
</span><span class="noop">        &gt;&gt;&gt; derived.hv(1.)
</span><span class="noop">
</span><span class="noop">        The first example deals with normal flow conditions, where water flows
</span><span class="noop">        within the main channel completely:
</span><span class="noop">        (:class:`~hydpy.model.lstream.lstream_fluxes.H` &lt;
</span><span class="noop">        :class:`~hydpy.model.lstream.lstream_control.HM`):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.h = .5
</span><span class="noop">        &gt;&gt;&gt; model.calc_av_uv_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.av
</span><span class="noop">        av(0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.uv
</span><span class="noop">        uv(0.0, 0.0)
</span><span class="noop">
</span><span class="noop">        The second example deals with moderate high flow conditions, where
</span><span class="noop">        water flows over both forelands, but not over their embankments:
</span><span class="noop">        (:class:`~hydpy.model.lstream.lstream_control.HM` &lt;
</span><span class="noop">        :class:`~hydpy.model.lstream.lstream_fluxes.H` &lt;
</span><span class="noop">        (:class:`~hydpy.model.lstream.lstream_control.HM` +
</span><span class="noop">        :class:`~hydpy.model.lstream.lstream_derived.HV`)):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.h = 1.5
</span><span class="noop">        &gt;&gt;&gt; model.calc_av_uv_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.av
</span><span class="noop">        av(1.5, 1.5)
</span><span class="noop">        &gt;&gt;&gt; fluxes.uv
</span><span class="noop">        uv(4.061553, 4.061553)
</span><span class="noop">
</span><span class="noop">        The third example deals with extreme high flow conditions, where
</span><span class="noop">        water flows over the both foreland and their outer embankments:
</span><span class="noop">        ((:class:`~hydpy.model.lstream.lstream_control.HM` +
</span><span class="noop">        :class:`~hydpy.model.lstream.lstream_derived.HV`) &lt;
</span><span class="noop">        :class:`~hydpy.model.lstream.lstream_fluxes.H`):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.h = 2.5
</span><span class="noop">        &gt;&gt;&gt; model.calc_av_uv_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.av
</span><span class="noop">        av(7.0, 7.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.uv
</span><span class="noop">        uv(6.623106, 6.623106)
</span><span class="noop">
</span><span class="noop">        The forth example assures that zero widths or hights of the forelands
</span><span class="noop">        are handled properly:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; bv.left = 0.
</span><span class="noop">        &gt;&gt;&gt; derived.hv.right = 0.
</span><span class="noop">        &gt;&gt;&gt; model.calc_av_uv_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.av
</span><span class="noop">        av(4.0, 3.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.uv
</span><span class="noop">        uv(4.623106, 3.5)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    for i in range(2):
</span><span class="hit">        if flu.h &lt;= con.hm:
</span><span class="hit">            flu.av[i] = 0.
</span><span class="hit">            flu.uv[i] = 0.
</span><span class="hit">        elif flu.h &lt;= (con.hm+der.hv[i]):
</span><span class="hit">            flu.av[i] = (flu.h-con.hm)*(con.bv[i]+(flu.h-con.hm)*con.bnv[i]/2.)
</span><span class="hit">            flu.uv[i] = con.bv[i]+(flu.h-con.hm)*(1.+con.bnv[i]**2)**.5
</span><span class="noop">        else:
</span><span class="hit">            flu.av[i] = (der.hv[i]*(con.bv[i]+der.hv[i]*con.bnv[i]/2.) +
</span><span class="noop">                         ((flu.h-(con.hm+der.hv[i])) *
</span><span class="noop">                          (con.bv[i]+der.hv[i]*con.bnv[i])))
</span><span class="hit">            flu.uv[i] = ((con.bv[i])+(der.hv[i]*(1.+con.bnv[i]**2)**.5) +
</span><span class="noop">                         (flu.h-(con.hm+der.hv[i])))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qv_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the discharge of both forelands after Manning-Strickler.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.EKV`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.SKV`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.Gef`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.AV`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.UV`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.QV`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        For appropriate strictly positive values:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lstream import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; ekv(2.)
</span><span class="noop">        &gt;&gt;&gt; skv(50.)
</span><span class="noop">        &gt;&gt;&gt; gef(.01)
</span><span class="noop">        &gt;&gt;&gt; fluxes.av = 3.
</span><span class="noop">        &gt;&gt;&gt; fluxes.uv = 7.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qv_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qv
</span><span class="noop">        qv(17.053102, 17.053102)
</span><span class="noop">
</span><span class="noop">        For zero or negative values of the flown through surface or
</span><span class="noop">        the wetted perimeter:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.av = -1., 3.
</span><span class="noop">        &gt;&gt;&gt; fluxes.uv = 7., 0.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qv_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qv
</span><span class="noop">        qv(0.0, 0.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    for i in range(2):
</span><span class="hit">        if (flu.av[i] &gt; 0.) and (flu.uv[i] &gt; 0.):
</span><span class="hit">            flu.qv[i] = (con.ekv[i]*con.skv[i] *
</span><span class="noop">                         flu.av[i]**(5./3.)/flu.uv[i]**(2./3.)*con.gef**.5)
</span><span class="noop">        else:
</span><span class="hit">            flu.qv[i] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_avr_uvr_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the flown through area and the wetted perimeter of both
</span><span class="noop">    outer embankments.
</span><span class="noop">
</span><span class="noop">    Note that each outer embankment lies beyond its foreland and that all
</span><span class="noop">    water flowing exactly above the a embankment is added to
</span><span class="noop">    :class:`~hydpy.model.lstream.lstream_fluxes.AVR`.
</span><span class="noop">    The theoretical surface seperating water above the foreland from water
</span><span class="noop">    above its embankment is not contributing to
</span><span class="noop">    :class:`~hydpy.model.lstream.lstream_fluxes.UVR`.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.HM`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.BNVR`
</span><span class="noop">
</span><span class="noop">    Required derived parameter:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_derived.HV`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.H`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.AVR`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.UVR`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        Generally, right trapezoids are assumed.  Here, for simplicity, both
</span><span class="noop">        forelands are assumed to be symmetrical.  Their smaller bases (bottoms)
</span><span class="noop">        hava a length of 2 meters, their non-vertical legs show an inclination
</span><span class="noop">        of 1 meter per 4 meters, and their height (depths) is 1 meter.  Both
</span><span class="noop">        forelands lie 1 meter above the main channels bottom.
</span><span class="noop">
</span><span class="noop">        Generally, a triangles are assumed, with the vertical side
</span><span class="noop">        seperating the foreland from its outer embankment.  Here, for
</span><span class="noop">        simplicity, both forelands are assumed to be symmetrical.  Their
</span><span class="noop">        inclinations are 1 meter per 4 meters and their lowest point is
</span><span class="noop">        1 meter above the forelands bottom and 2 meters above the main
</span><span class="noop">        channels bottom:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lstream import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; hm(1.)
</span><span class="noop">        &gt;&gt;&gt; bnvr(4.)
</span><span class="noop">        &gt;&gt;&gt; derived.hv(1.)
</span><span class="noop">
</span><span class="noop">        The first example deals with moderate high flow conditions, where
</span><span class="noop">        water flows over the forelands, but not over their outer embankments:
</span><span class="noop">        (:class:`~hydpy.model.lstream.lstream_control.HM` &lt;
</span><span class="noop">        :class:`~hydpy.model.lstream.lstream_fluxes.H` &lt;
</span><span class="noop">        (:class:`~hydpy.model.lstream.lstream_control.HM` +
</span><span class="noop">        :class:`~hydpy.model.lstream.lstream_derived.HV`)):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.h = 1.5
</span><span class="noop">        &gt;&gt;&gt; model.calc_avr_uvr_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.avr
</span><span class="noop">        avr(0.0, 0.0)
</span><span class="noop">        &gt;&gt;&gt; fluxes.uvr
</span><span class="noop">        uvr(0.0, 0.0)
</span><span class="noop">
</span><span class="noop">        The second example deals with extreme high flow conditions, where
</span><span class="noop">        water flows over the both foreland and their outer embankments:
</span><span class="noop">        ((:class:`~hydpy.model.lstream.lstream_control.HM` +
</span><span class="noop">        :class:`~hydpy.model.lstream.lstream_derived.HV`) &lt;
</span><span class="noop">        :class:`~hydpy.model.lstream.lstream_fluxes.H`):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.h = 2.5
</span><span class="noop">        &gt;&gt;&gt; model.calc_avr_uvr_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.avr
</span><span class="noop">        avr(0.5, 0.5)
</span><span class="noop">        &gt;&gt;&gt; fluxes.uvr
</span><span class="noop">        uvr(2.061553, 2.061553)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    for i in range(2):
</span><span class="hit">        if flu.h &lt;= (con.hm+der.hv[i]):
</span><span class="hit">            flu.avr[i] = 0.
</span><span class="hit">            flu.uvr[i] = 0.
</span><span class="noop">        else:
</span><span class="hit">            flu.avr[i] = (flu.h-(con.hm+der.hv[i]))**2*con.bnvr[i]/2.
</span><span class="hit">            flu.uvr[i] = (flu.h-(con.hm+der.hv[i]))*(1.+con.bnvr[i]**2)**.5
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qvr_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the discharge of both outer embankments after
</span><span class="noop">    Manning-Strickler.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.EKV`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.SKV`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.Gef`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.AVR`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.UVR`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.QVR`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        For appropriate strictly positive values:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lstream import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; ekv(2.)
</span><span class="noop">        &gt;&gt;&gt; skv(50.)
</span><span class="noop">        &gt;&gt;&gt; gef(.01)
</span><span class="noop">        &gt;&gt;&gt; fluxes.avr = 3.
</span><span class="noop">        &gt;&gt;&gt; fluxes.uvr = 7.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qvr_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qvr
</span><span class="noop">        qvr(17.053102, 17.053102)
</span><span class="noop">
</span><span class="noop">        For zero or negative values of the flown through surface or
</span><span class="noop">        the wetted perimeter:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.avr = -1., 3.
</span><span class="noop">        &gt;&gt;&gt; fluxes.uvr = 7., 0.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qvr_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.qvr
</span><span class="noop">        qvr(0.0, 0.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    for i in range(2):
</span><span class="hit">        if (flu.avr[i] &gt; 0.) and (flu.uvr[i] &gt; 0.):
</span><span class="hit">            flu.qvr[i] = (con.ekv[i]*con.skv[i] *
</span><span class="noop">                          flu.avr[i]**(5./3.)/flu.uvr[i]**(2./3.)*con.gef**.5)
</span><span class="noop">        else:
</span><span class="hit">            flu.qvr[i] = 0.
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_ag_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Sum the through flown area of the total cross section.
</span><span class="noop">
</span><span class="noop">    Required flux sequences:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.AM`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.AV`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.AVR`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.AG`
</span><span class="noop">
</span><span class="noop">    Example:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lstream import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; fluxes.am = 1.
</span><span class="noop">        &gt;&gt;&gt; fluxes.av= 2., 3.
</span><span class="noop">        &gt;&gt;&gt; fluxes.avr = 4., 5.
</span><span class="noop">        &gt;&gt;&gt; model.calc_ag_v1()
</span><span class="noop">        &gt;&gt;&gt; fluxes.ag
</span><span class="noop">        ag(15.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    flu.ag = flu.am+flu.av[0]+flu.av[1]+flu.avr[0]+flu.avr[1]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qg_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate the discharge of the total cross section.
</span><span class="noop">
</span><span class="noop">    Method :func:`calc_qg_v1` applies the actual versions of all methods
</span><span class="noop">    for calculating the flown through areas, wetted perimeters and discharges
</span><span class="noop">    of the different cross section compartments.  Hence its requirements
</span><span class="noop">    might be different for various application models.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    self.calc_am_um()
</span><span class="hit">    self.calc_qm()
</span><span class="hit">    self.calc_av_uv()
</span><span class="hit">    self.calc_qv()
</span><span class="hit">    self.calc_avr_uvr()
</span><span class="hit">    self.calc_qvr()
</span><span class="hit">    flu.qg = flu.qm+flu.qv[0]+flu.qv[1]+flu.qvr[0]+flu.qvr[1]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_hmin_qmin_hmax_qmax_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Determine an starting interval for iteration methods as the one
</span><span class="noop">    implemented in method :func:`calc_h_v1`.
</span><span class="noop">
</span><span class="noop">    The resulting interval is determined in a manner, that on the
</span><span class="noop">    one hand :math:`Qmin \\leq QRef \\leq Qmax` is fulfilled and on the
</span><span class="noop">    other hand the results of method :func:`calc_qg_v1` are continuous
</span><span class="noop">    for :math:`Hmin \\leq H \\leq Hmax`.
</span><span class="noop">
</span><span class="noop">    Required control parameter:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.HM`
</span><span class="noop">
</span><span class="noop">    Required derived paramters:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_derived.HV`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_derived.QM`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_derived.QV`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.QRef`
</span><span class="noop">
</span><span class="noop">    Calculated aide sequences:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_aides.HMin`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_aides.HMax`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_aides.QMin`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_aides.QMax`
</span><span class="noop">
</span><span class="noop">    Besides the mentioned required parameters and sequences, those of the
</span><span class="noop">    actual method for calculating the discharge of the total cross section
</span><span class="noop">    might be required.  This is the case whenever water flows on both outer
</span><span class="noop">    embankments.  In such occasions no previously determined upper boundary
</span><span class="noop">    values are available and method :func:`calc_hmin_qmin_hmax_qmax_v1` needs
</span><span class="noop">    to increase the value of :math:`HMax` successively until the condition
</span><span class="noop">    :math:`QG \\leq QMax` is met.
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    der = self.parameters.derived.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    aid = self.sequences.aides.fastaccess
</span><span class="hit">    if flu.qref &lt;= der.qm:
</span><span class="hit">        aid.hmin = 0.
</span><span class="hit">        aid.qmin = 0.
</span><span class="hit">        aid.hmax = con.hm
</span><span class="hit">        aid.qmax = der.qm
</span><span class="hit">    elif flu.qref &lt;= min(der.qv):
</span><span class="hit">        aid.hmin = con.hm
</span><span class="hit">        aid.qmin = der.qm
</span><span class="hit">        aid.hmax = con.hm+min(der.hv)
</span><span class="hit">        aid.qmax = min(der.qv)
</span><span class="hit">    elif flu.qref &lt; max(der.qv):
</span><span class="hit">        aid.hmin = con.hm+min(der.hv)
</span><span class="hit">        aid.qmin = min(der.qv)
</span><span class="hit">        aid.hmax = con.hm+max(der.hv)
</span><span class="hit">        aid.qmax = max(der.qv)
</span><span class="noop">    else:
</span><span class="hit">        flu.h = con.hm+max(der.hv)
</span><span class="hit">        aid.hmin = flu.h
</span><span class="hit">        aid.qmin = flu.qg
</span><span class="hit">        while True:
</span><span class="hit">            flu.h *= 2.
</span><span class="hit">            self.calc_qg()
</span><span class="hit">            if flu.qg &lt; flu.qref:
</span><span class="hit">                aid.hmin = flu.h
</span><span class="hit">                aid.qmin = flu.qg
</span><span class="noop">            else:
</span><span class="hit">                aid.hmax = flu.h
</span><span class="hit">                aid.qmax = flu.qg
</span><span class="hit">                break
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_h_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Approximate the water stage resulting in a certain reference discarge
</span><span class="noop">    with the Pegasus iteration method.
</span><span class="noop">
</span><span class="noop">    Required control parameters:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.QTol`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_control.HTol`
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.QRef`
</span><span class="noop">
</span><span class="noop">    Calculated aide sequences:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_aides.HMin`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_aides.HMax`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_aides.QMin`
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_aides.QMax`
</span><span class="noop">
</span><span class="noop">    Calculated flux sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.H`
</span><span class="noop">
</span><span class="noop">    Besides the parameters and sequences given above, those of the
</span><span class="noop">    actual method for calculating the discharge of the total cross section
</span><span class="noop">    are required.
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">        Essentially, the Pegasus method is a root finding algorithm which
</span><span class="noop">        sequentially decreases its search radius (like the simple bisection
</span><span class="noop">        algorithm) and shows superlinear convergence properties (like the
</span><span class="noop">        Newton-Raphson algorithm).  Ideally, its convergence should be proved
</span><span class="noop">        for each application model to be derived from HydPy-L-Stream.
</span><span class="noop">        The following examples focus on the methods
</span><span class="noop">        :func:`calc_hmin_qmin_hmax_qmax_v1` and :func:`calc_qg_v1`
</span><span class="noop">        (including their submethods) only:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lstream import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; model.calc_hmin_qmin_hmax_qmax = model.calc_hmin_qmin_hmax_qmax_v1
</span><span class="noop">        &gt;&gt;&gt; model.calc_qg = model.calc_qg_v1
</span><span class="noop">        &gt;&gt;&gt; model.calc_qm = model.calc_qm_v1
</span><span class="noop">        &gt;&gt;&gt; model.calc_av_uv = model.calc_av_uv_v1
</span><span class="noop">        &gt;&gt;&gt; model.calc_qv = model.calc_qv_v1
</span><span class="noop">        &gt;&gt;&gt; model.calc_avr_uvr = model.calc_avr_uvr_v1
</span><span class="noop">        &gt;&gt;&gt; model.calc_qvr = model.calc_qvr_v1
</span><span class="noop">
</span><span class="noop">        Define the geometry and roughness values for the first test channel:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; bm(2.)
</span><span class="noop">        &gt;&gt;&gt; bnm(4.)
</span><span class="noop">        &gt;&gt;&gt; hm(1.)
</span><span class="noop">        &gt;&gt;&gt; bv(.5, 10.)
</span><span class="noop">        &gt;&gt;&gt; bbv(1., 2.)
</span><span class="noop">        &gt;&gt;&gt; bnv(1., 8.)
</span><span class="noop">        &gt;&gt;&gt; bnvr(20.)
</span><span class="noop">        &gt;&gt;&gt; ekm(1.)
</span><span class="noop">        &gt;&gt;&gt; skm(20.)
</span><span class="noop">        &gt;&gt;&gt; ekv(1.)
</span><span class="noop">        &gt;&gt;&gt; skv(60., 80.)
</span><span class="noop">        &gt;&gt;&gt; gef(.01)
</span><span class="noop">
</span><span class="noop">        Set the error tolerances of the iteration small enough, not to
</span><span class="noop">        compromise the shown first six decimal places of the following results:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; qtol(1e-10)
</span><span class="noop">        &gt;&gt;&gt; htol(1e-10)
</span><span class="noop">
</span><span class="noop">        Derive the required secondary parameters:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.hv.update()
</span><span class="noop">        &gt;&gt;&gt; derived.qm.update()
</span><span class="noop">        &gt;&gt;&gt; derived.qv.update()
</span><span class="noop">
</span><span class="noop">        Define a test function, accepting a reference discharge and printing
</span><span class="noop">        both the approximated water stage and the related discharge value:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; def test(qref):
</span><span class="noop">        ...     fluxes.qref = qref
</span><span class="noop">        ...     model.calc_hmin_qmin_hmax_qmax()
</span><span class="noop">        ...     model.calc_h()
</span><span class="noop">        ...     print(repr(fluxes.h))
</span><span class="noop">        ...     print(repr(fluxes.qg))
</span><span class="noop">
</span><span class="noop">        Zero discharge and the following discharge values are related to the
</span><span class="noop">        only discontinuities of the given root finding problem:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; derived.qm
</span><span class="noop">        qm(8.399238)
</span><span class="noop">        &gt;&gt;&gt; derived.qv
</span><span class="noop">        qv(154.463234, 23.073584)
</span><span class="noop">
</span><span class="noop">        The related water stages are the ones (directly or indirectly)
</span><span class="noop">        defined above:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; test(0.)
</span><span class="noop">        h(0.0)
</span><span class="noop">        qg(0.0)
</span><span class="noop">        &gt;&gt;&gt; test(derived.qm)
</span><span class="noop">        h(1.0)
</span><span class="noop">        qg(8.399238)
</span><span class="noop">        &gt;&gt;&gt; test(derived.qv.left)
</span><span class="noop">        h(2.0)
</span><span class="noop">        qg(154.463234)
</span><span class="noop">        &gt;&gt;&gt; test(derived.qv.right)
</span><span class="noop">        h(1.25)
</span><span class="noop">        qg(23.073584)
</span><span class="noop">
</span><span class="noop">        Test some intermediate water stages, inundating the only the main
</span><span class="noop">        channel, the main channel along with the right foreland, and the
</span><span class="noop">        main channel along with both forelands respectively:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; test(6.)
</span><span class="noop">        h(0.859452)
</span><span class="noop">        qg(6.0)
</span><span class="noop">        &gt;&gt;&gt; test(10.)
</span><span class="noop">        h(1.047546)
</span><span class="noop">        qg(10.0)
</span><span class="noop">        &gt;&gt;&gt; test(100)
</span><span class="noop">        h(1.77455)
</span><span class="noop">        qg(100.0)
</span><span class="noop">
</span><span class="noop">        Finally, test two extreme water stages, inundating both outer
</span><span class="noop">        foreland embankments:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; test(200.)
</span><span class="noop">        h(2.152893)
</span><span class="noop">        qg(200.0)
</span><span class="noop">        &gt;&gt;&gt; test(2000.)
</span><span class="noop">        h(4.240063)
</span><span class="noop">        qg(2000.0)
</span><span class="noop">
</span><span class="noop">        There is a potential risk of the implemented iteration method to fail
</span><span class="noop">        for special channel geometries.  To test such cases in a more
</span><span class="noop">        condensed manner, the following test methods evaluates different water
</span><span class="noop">        stages automatically in accordance with the example above.  An error
</span><span class="noop">        message is printed only, the estimated discharge does not approximate
</span><span class="noop">        the reference discharge with six decimal places:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; def test():
</span><span class="noop">        ...     derived.hv.update()
</span><span class="noop">        ...     derived.qm.update()
</span><span class="noop">        ...     derived.qv.update()
</span><span class="noop">        ...     qm, qv = derived.qm, derived.qv
</span><span class="noop">        ...     for qref in [0., qm, qv.left, qv.right,
</span><span class="noop">        ...                  2./3.*qm+1./3.*min(qv),
</span><span class="noop">        ...                  2./3.*min(qv)+1./3.*max(qv),
</span><span class="noop">        ...                  3.*max(qv), 30.*max(qv)]:
</span><span class="noop">        ...         fluxes.qref = qref
</span><span class="noop">        ...         model.calc_hmin_qmin_hmax_qmax()
</span><span class="noop">        ...         model.calc_h()
</span><span class="noop">        ...         if abs(round(fluxes.qg-qref) &gt; 0.):
</span><span class="noop">        ...             print(&#39;Error!&#39;, &#39;qref:&#39;, qref, &#39;qg:&#39;, fluxes.qg)
</span><span class="noop">
</span><span class="noop">        Check for a triangle main channel:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; bm(0.)
</span><span class="noop">        &gt;&gt;&gt; test()
</span><span class="noop">        &gt;&gt;&gt; bm(2.)
</span><span class="noop">
</span><span class="noop">        Check for a completely flat main channel:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; hm(0.)
</span><span class="noop">        &gt;&gt;&gt; test()
</span><span class="noop">        &gt;&gt;&gt; hm(1.)
</span><span class="noop">
</span><span class="noop">        Check for a nonexistend main channel:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; bm(0.)
</span><span class="noop">        &gt;&gt;&gt; bnm(0.)
</span><span class="noop">        &gt;&gt;&gt; test()
</span><span class="noop">        &gt;&gt;&gt; bm(2.)
</span><span class="noop">        &gt;&gt;&gt; bnm(4.)
</span><span class="noop">
</span><span class="noop">        Check for a nonexistend forelands:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; bv(0.)
</span><span class="noop">        &gt;&gt;&gt; bbv(0.)
</span><span class="noop">        &gt;&gt;&gt; test()
</span><span class="noop">        &gt;&gt;&gt; bv(.5, 10.)
</span><span class="noop">        &gt;&gt;&gt; bbv(1., 2.)
</span><span class="noop">
</span><span class="noop">        Check for nonexistend outer foreland embankments:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; bnvr(0.)
</span><span class="noop">        &gt;&gt;&gt; test()
</span><span class="noop">
</span><span class="noop">        To take the last test as an illustrative example, one can see that
</span><span class="noop">        the given reference discharge is met by the estimated total discharge,
</span><span class="noop">        which consists of components related to the main channel and the
</span><span class="noop">        forelands only:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.qref
</span><span class="noop">        qref(3932.452785)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qg
</span><span class="noop">        qg(3932.452785)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qm
</span><span class="noop">        qm(530.074621)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qv
</span><span class="noop">        qv(113.780226, 3288.597937)
</span><span class="noop">        &gt;&gt;&gt; fluxes.qvr
</span><span class="noop">        qvr(0.0, 0.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    con = self.parameters.control.fastaccess
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    aid = self.sequences.aides.fastaccess
</span><span class="hit">    aid.qmin -= flu.qref
</span><span class="hit">    aid.qmax -= flu.qref
</span><span class="hit">    if modelutils.fabs(aid.qmin) &lt; con.qtol:
</span><span class="hit">        flu.h = aid.hmin
</span><span class="hit">        self.calc_qg()
</span><span class="hit">    elif modelutils.fabs(aid.qmax) &lt; con.qtol:
</span><span class="hit">        flu.h = aid.hmax
</span><span class="hit">        self.calc_qg()
</span><span class="hit">    elif modelutils.fabs(aid.hmax-aid.hmin) &lt; con.htol:
</span><span class="miss">        flu.h = (aid.hmin+aid.hmax)/2.
</span><span class="miss">        self.calc_qg()
</span><span class="noop">    else:
</span><span class="hit">        while True:
</span><span class="hit">            flu.h = aid.hmin-aid.qmin*(aid.hmax-aid.hmin)/(aid.qmax-aid.qmin)
</span><span class="hit">            self.calc_qg()
</span><span class="hit">            aid.qtest = flu.qg-flu.qref
</span><span class="hit">            if modelutils.fabs(aid.qtest) &lt; con.qtol:
</span><span class="hit">                return
</span><span class="hit">            elif (((aid.qmax &lt; 0.) and (aid.qtest &lt; 0.)) or
</span><span class="noop">                    ((aid.qmax &gt; 0.) and (aid.qtest &gt; 0.))):
</span><span class="hit">                aid.qmin *= aid.qmax/(aid.qmax+aid.qtest)
</span><span class="noop">            else:
</span><span class="hit">                aid.hmin = aid.hmax
</span><span class="hit">                aid.qmin = aid.qmax
</span><span class="hit">            aid.hmax = flu.h
</span><span class="hit">            aid.qmax = aid.qtest
</span><span class="hit">            if modelutils.fabs(aid.hmax-aid.hmin) &lt; con.htol:
</span><span class="hit">                return
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def calc_qa_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Calculate outflow.
</span><span class="noop">
</span><span class="noop">    The working equation is the analytical solution of the linear storage
</span><span class="noop">    equation under the assumption of constant change in inflow during
</span><span class="noop">    the simulation time step.
</span><span class="noop">
</span><span class="noop">    Required flux sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_fluxes.RK`
</span><span class="noop">
</span><span class="noop">    Required state sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_states.QZ`
</span><span class="noop">
</span><span class="noop">    Updated state sequence:
</span><span class="noop">      :class:`~hydpy.model.lstream.lstream_states.QA`
</span><span class="noop">
</span><span class="noop">    Basic equation:
</span><span class="noop">       :math:`QA_{neu} = QA_{alt} +
</span><span class="noop">       (QZ_{alt}-QA_{alt}) \\cdot (1-exp(-RK^{-1})) +
</span><span class="noop">       (QZ_{neu}-QZ_{alt}) \\cdot (1-KR\\cdot(1-exp(-KR^{-1})))`
</span><span class="noop">
</span><span class="noop">    Examples:
</span><span class="noop">
</span><span class="noop">        A normal test case:
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; from hydpy.models.lstream import *
</span><span class="noop">        &gt;&gt;&gt; parameterstep()
</span><span class="noop">        &gt;&gt;&gt; fluxes.rk(0.1)
</span><span class="noop">        &gt;&gt;&gt; states.qz.old = 2.
</span><span class="noop">        &gt;&gt;&gt; states.qz.new = 4.
</span><span class="noop">        &gt;&gt;&gt; states.qa.old = 3.
</span><span class="noop">        &gt;&gt;&gt; model.calc_qa_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qa
</span><span class="noop">        qa(3.800054)
</span><span class="noop">
</span><span class="noop">        First extreme test case (zero division is circumvented):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.rk(0.)
</span><span class="noop">        &gt;&gt;&gt; model.calc_qa_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qa
</span><span class="noop">        qa(4.0)
</span><span class="noop">
</span><span class="noop">        Second extreme test case (numerical overflow is circumvented):
</span><span class="noop">
</span><span class="noop">        &gt;&gt;&gt; fluxes.rk(1e200)
</span><span class="noop">        &gt;&gt;&gt; model.calc_qa_v1()
</span><span class="noop">        &gt;&gt;&gt; states.qa
</span><span class="noop">        qa(5.0)
</span><span class="noop">    &#34;&#34;&#34;
</span><span class="hit">    flu = self.sequences.fluxes.fastaccess
</span><span class="hit">    old = self.sequences.states.fastaccess_old
</span><span class="hit">    new = self.sequences.states.fastaccess_new
</span><span class="hit">    aid = self.sequences.aides.fastaccess
</span><span class="hit">    if flu.rk &lt;= 0.:
</span><span class="hit">        new.qa = new.qz
</span><span class="hit">    elif flu.rk &gt; 1e200:
</span><span class="miss">        new.qa = old.qa+new.qz-old.qz
</span><span class="noop">    else:
</span><span class="hit">        aid.temp = (1.-modelutils.exp(-1./flu.rk))
</span><span class="hit">        new.qa = (old.qa +
</span><span class="noop">                  (old.qz-old.qa)*aid.temp +
</span><span class="noop">                  (new.qz-old.qz)*(1.-flu.rk*aid.temp))
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def update_inlets_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Update inflow.&#34;&#34;&#34;
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    inl = self.sequences.inlets.fastaccess
</span><span class="hit">    sta.qz = 0.
</span><span class="hit">    for idx in range(inl.len_q):
</span><span class="hit">        sta.qz += inl.q[idx][0]
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">def update_outlets_v1(self):
</span><span class="noop">    &#34;&#34;&#34;Update outflow.&#34;&#34;&#34;
</span><span class="hit">    sta = self.sequences.states.fastaccess
</span><span class="hit">    out = self.sequences.outlets.fastaccess
</span><span class="hit">    out.q[0] += sta.qa
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Model(modeltools.Model):
</span><span class="noop">    &#34;&#34;&#34;The HydPy-H-Stream model.&#34;&#34;&#34;
</span><span class="hit">    _RUNMETHODS = (update_inlets_v1,
</span><span class="noop">                   calc_qref_v1,
</span><span class="noop">                   calc_hmin_qmin_hmax_qmax_v1,
</span><span class="noop">                   calc_h_v1,
</span><span class="noop">                   calc_ag_v1,
</span><span class="noop">                   calc_rk_v1,
</span><span class="noop">                   calc_qa_v1,
</span><span class="noop">                   update_outlets_v1)
</span><span class="hit">    _ADDMETHODS = (calc_am_um_v1,
</span><span class="noop">                   calc_qm_v1,
</span><span class="noop">                   calc_av_uv_v1,
</span><span class="noop">                   calc_qv_v1,
</span><span class="noop">                   calc_avr_uvr_v1,
</span><span class="noop">                   calc_qvr_v1,
</span><span class="noop">                   calc_qg_v1)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream/lstream_outlets.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream/lstream_outlets.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class Q(sequencetools.LinkSequence):
</span><span class="noop">    &#34;&#34;&#34;Abfluss (runoff) [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC = 0, False
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class OutletSequences(sequencetools.LinkSequences):
</span><span class="noop">    &#34;&#34;&#34;Downstream link sequences of HydPy-L-Stream.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (Q,)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4 id="/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream/lstream_states.py">/home/travis/virtualenv/python2.7.9/lib/python2.7/site-packages/hydpy/models/lstream/lstream_states.py</h4>
<table class="code u-max-full-width">
  <tbody>
    <tr>
      <td class="lineno">
        <pre>1 &nbsp;
2 &nbsp;
3 &nbsp;
4 &nbsp;
5 &nbsp;
6 &nbsp;
7 &nbsp;
8 &nbsp;
9 &nbsp;
10 &nbsp;
11 &nbsp;
12 &nbsp;
13 &nbsp;
14 &nbsp;
15 &nbsp;
16 &nbsp;
17 &nbsp;
18 &nbsp;
19 &nbsp;
20 &nbsp;
21 &nbsp;
22 &nbsp;
</pre>
      </td>
      <td class="source">
        <pre><span class="noop"># -*- coding: utf-8 -*-
</span><span class="noop">
</span><span class="noop"># import...
</span><span class="noop"># ...from standard library
</span><span class="hit">from __future__ import division, print_function
</span><span class="noop"># ...HydPy specific
</span><span class="hit">from hydpy.core import sequencetools
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QZ(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Zufluss in Gerinnestrecke (inflow into the channel) [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class QA(sequencetools.StateSequence):
</span><span class="noop">    &#34;&#34;&#34;Abfluss aus Gerinnestrecke (outflow out of the channel) [m³/s].&#34;&#34;&#34;
</span><span class="hit">    NDIM, NUMERIC, SPAN = 0, False, (0., None)
</span><span class="noop">
</span><span class="noop">
</span><span class="hit">class StateSequences(sequencetools.StateSequences):
</span><span class="noop">    &#34;&#34;&#34;State sequences of HydPy-L-Stream.&#34;&#34;&#34;
</span><span class="hit">    _SEQCLASSES = (QZ, QA)
</span></pre>
      </td>
    </tr>
  </tbody>
</table>
    </div>
  </body>
</html>